'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var plateStyledComponents = require('@udecode/plate-styled-components');
var _styled = require('styled-components');
var React = require('react');
var plateCore = require('@udecode/plate-core');
var plateFloating = require('@udecode/plate-floating');
var plateMedia = require('@udecode/plate-media');
var slateReact = require('slate-react');
var plateLink = require('@udecode/plate-link');
var plateUiToolbar = require('@udecode/plate-ui-toolbar');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _styled__default = /*#__PURE__*/_interopDefaultLegacy(_styled);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

var global$1 = (typeof global !== "undefined" ? global :
            typeof self !== "undefined" ? self :
            typeof window !== "undefined" ? window : {});

if (typeof global$1.setTimeout === 'function') ;
if (typeof global$1.clearTimeout === 'function') ;

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance = global$1.performance || {};
performance.now        ||
  performance.mozNow     ||
  performance.msNow      ||
  performance.oNow       ||
  performance.webkitNow  ||
  function(){ return (new Date()).getTime() };

function getSide(placement) {
  return placement.split('-')[0];
}

function getAlignment(placement) {
  return placement.split('-')[1];
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';
}

function getLengthFromAxis(axis) {
  return axis === 'y' ? 'height' : 'width';
}

function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}

function getSideObjectFromPadding(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}

function rectToClientRect(rect) {
  return { ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
async function detectOverflow(middlewareArguments, options) {
  var _await$platform$isEle;

  if (options === void 0) {
    options = {};
  }

  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: elementContext === 'floating' ? { ...rects.floating,
      x,
      y
    } : rects.reference,
    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),
    strategy
  }) : rects[elementContext]);
  return {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
}

const min = Math.min;
const max = Math.max;

function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}

const hash$1 = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);
}

function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }

  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';

  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }

  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}

const hash = {
  start: 'end',
  end: 'start'
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, matched => hash[matched]);
}

function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}

/**
 * Changes the placement of the floating element to one that will fit if the
 * initially specified `placement` does not.
 * @see https://floating-ui.com/docs/flip
 */
const flip = function (options) {
  if (options === void 0) {
    options = {};
  }

  return {
    name: 'flip',
    options,

    async fn(middlewareArguments) {
      var _middlewareData$flip;

      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        flipAlignment = true,
        ...detectOverflowOptions
      } = options;
      const side = getSide(placement);
      const isBasePlacement = side === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];

      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }

      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));
        overflows.push(overflow[main], overflow[cross]);
      }

      overflowsData = [...overflowsData, {
        placement,
        overflows
      }]; // One or more sides is overflowing

      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip2;

        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements[nextIndex];

        if (nextPlacement) {
          // Try next placement and re-run the lifecycle
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }

        let resetPlacement = 'bottom';

        switch (fallbackStrategy) {
          case 'bestFit':
            {
              var _overflowsData$map$so;

              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;

              if (placement) {
                resetPlacement = placement;
              }

              break;
            }

          case 'initialPlacement':
            resetPlacement = initialPlacement;
            break;
        }

        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }

      return {};
    }

  };
};

async function convertValueToCoords(middlewareArguments, value) {
  const {
    placement,
    platform,
    elements
  } = middlewareArguments;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === 'x';
  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const

  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === 'number' ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };

  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }

  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
/**
 * Displaces the floating element from its reference element.
 * @see https://floating-ui.com/docs/offset
 */

const offset = function (value) {
  if (value === void 0) {
    value = 0;
  }

  return {
    name: 'offset',
    options: value,

    async fn(middlewareArguments) {
      const {
        x,
        y
      } = middlewareArguments;
      const diffCoords = await convertValueToCoords(middlewareArguments, value);
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }

  };
};

function getCrossAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/**
 * Shifts the floating element in order to keep it in view when it will overflow
 * a clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = function (options) {
  if (options === void 0) {
    options = {};
  }

  return {
    name: 'shift',
    options,

    async fn(middlewareArguments) {
      const {
        x,
        y,
        placement
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: _ref => {
            let {
              x,
              y
            } = _ref;
            return {
              x,
              y
            };
          }
        },
        ...detectOverflowOptions
      } = options;
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];

      if (checkMainAxis) {
        const minSide = mainAxis === 'y' ? 'top' : 'left';
        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min, mainAxisCoord, max);
      }

      if (checkCrossAxis) {
        const minSide = crossAxis === 'y' ? 'top' : 'left';
        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min, crossAxisCoord, max);
      }

      const limitedCoords = limiter.fn({ ...middlewareArguments,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return { ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }

  };
};

const mediaFloatingOptions = {
  middleware: [offset(-6), flip({
    padding: 96
  }), shift()]
};

const getResizableCss = ({
  focused,
  selected,
  align
} = {}) => {
  const handle = _styled.css(["", " ::after{", ";", ";", ";", ";", ";content:' ';width:3px;height:64px;border-radius:6px;}:hover,:focus,:active{::after{", ";}}"], {
    "display": "flex",
    "flexDirection": "column",
    "justifyContent": "center",
    "position": "absolute",
    "userSelect": "none",
    "width": "1.5rem",
    "height": "100%",
    "top": "0px",
    "zIndex": "10"
  }, {
    "opacity": "0"
  }, focused && selected && {
    "opacity": "1"
  }, {
    ".group:hover &": {
      "opacity": "1"
    }
  }, {
    "display": "flex"
  }, {
    "--tw-bg-opacity": "1",
    "backgroundColor": "rgba(156, 163, 175, var(--tw-bg-opacity))"
  }, {
    "--tw-bg-opacity": "1",
    "backgroundColor": "rgba(59, 130, 246, var(--tw-bg-opacity))"
  });
  const resizable = [align === 'center' && {
    "marginLeft": "auto",
    "marginRight": "auto"
  }, align === 'right' && {
    "marginLeft": "auto"
  }];
  const handleLeft = [...handle, {
    "left": "-0.75rem",
    "marginLeft": "-0.75rem",
    "paddingLeft": "0.75rem"
  }];
  const handleRight = [...handle, {
    "alignItems": "flex-end",
    "right": "-0.75rem",
    "marginRight": "-0.75rem",
    "paddingRight": "0.75rem"
  }];
  return {
    resizable,
    handleLeft,
    handleRight
  };
};
const getCaptionCss = ({
  align,
  caption
} = {}) => {
  return {
    figcaption: [align === 'center' && {
      "marginLeft": "auto",
      "marginRight": "auto"
    }, align === 'right' && {
      "marginLeft": "auto"
    }],
    caption: [{
      "width": "100%",
      "borderStyle": "none",
      ":focus": {
        "outline": "2px solid transparent",
        "outlineOffset": "2px"
      },
      "marginTop": "0.5rem",
      "padding": "0px",
      "resize": "none"
    }, (caption === null || caption === void 0 ? void 0 : caption.align) === 'center' && {
      "textAlign": "center"
    }, (caption === null || caption === void 0 ? void 0 : caption.align) === 'right' && {
      "textAlign": "right"
    }, _styled.css(["font:inherit;color:inherit;background-color:inherit;:focus{::placeholder{opacity:0;}}"])]
  };
};
const getImageElementStyles = props => {
  const {
    focused,
    selected,
    align = 'center',
    caption = {
      align: 'center'
    }
  } = props;
  return plateStyledComponents.createStyles({
    prefixClassNames: 'ImageElement',
    ...props
  }, {
    root: [{
      "paddingTop": "0.625rem",
      "paddingBottom": "0.625rem"
    }],
    figure: [{
      "margin": "0px",
      "position": "relative"
    }],
    img: [{
      "display": "block",
      "maxWidth": "100%",
      "paddingLeft": "0px",
      "paddingRight": "0px",
      "cursor": "pointer",
      "width": "100%"
    }, {
      "borderRadius": "3px",
      "objectFit": "cover"
    }, focused && selected && {
      "boxShadow": "0 0 0 1px rgb(59,130,249)"
    }],
    ...getCaptionCss({
      caption,
      align
    }),
    ...getResizableCss({
      selected,
      focused,
      align
    })
  });
};

function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$1.apply(this, arguments);
}

const getMediaEmbedElementStyles = props => {
  const {
    selected,
    readOnly,
    provider,
    focused
  } = props;
  let boxShadow;

  if (!readOnly && selected) {
    boxShadow = `0 0 0 1px rgb(59 130 249)`;
  }

  const providersPadding = {
    youtube: '56.2061%',
    vimeo: '75%',
    youku: '56.25%',
    dailymotion: '56.0417%',
    coub: '51.25%'
  };
  const providerPadding = provider !== 'twitter' ? provider && providersPadding[provider] || '56.0417%' : undefined;
  const resizable = getResizableCss({
    align: 'center',
    focused,
    selected
  });
  return plateStyledComponents.createStyles({
    prefixClassNames: 'MediaEmbedElement',
    ...props
  }, {
    root: {
      "position": "relative",
      "paddingTop": "0.625rem",
      "paddingBottom": "0.625rem"
    },
    figure: [{
      "margin": "0px",
      "position": "relative",
      "width": "100%"
    }, provider === 'twitter' && _styled.css([".twitter-tweet{margin:0 auto !important;padding:2px;box-shadow:", ";}"], boxShadow)],
    iframeWrapper: _styled.css(["padding-bottom:", ";"], providerPadding),
    iframe: [{
      "position": "absolute",
      "top": "0px",
      "left": "0px",
      "width": "100%",
      "height": "100%"
    }, _styled.css(["border-radius:3px;box-shadow:", ";"], boxShadow)],
    ...getCaptionCss({
      align: 'center',
      caption: {
        align: 'center'
      }
    }),
    ...resizable,
    handleRight: [...resizable.handleRight, provider === 'twitter' && {
      "marginRight": "-1rem"
    }]
  });
};

const Button = plateCore.createComponentAs(props => plateCore.createElementAs('button', props));

const plateButtonCss = [{
  "position": "relative",
  "display": "inline-flex",
  "justifyContent": "center",
  "alignItems": "center",
  "textAlign": "center",
  "maxWidth": "100%",
  "padding": "0px"
}, {
  "borderWidth": "0px",
  "fontWeight": "500",
  "cursor": "pointer"
}, {
  "--tw-bg-opacity": "1",
  "backgroundColor": "rgba(255, 255, 255, var(--tw-bg-opacity))",
  ":hover": {
    "--tw-bg-opacity": "1",
    "backgroundColor": "rgba(243, 244, 246, var(--tw-bg-opacity))"
  },
  ":active": {
    "--tw-bg-opacity": "1",
    "backgroundColor": "rgba(229, 231, 235, var(--tw-bg-opacity))"
  }
}, {
  "paddingLeft": "0.625rem",
  "paddingRight": "0.625rem",
  "paddingTop": "0.25rem",
  "paddingBottom": "0.25rem"
}, _styled.css(["font-family:inherit;font-size:14px;border-radius:3px;color:inherit;:active{color:inherit;}:visited{color:inherit;}"])];

const PlateButton = ({
  size,
  px,
  py,
  css: _css,
  ...props
}) => /*#__PURE__*/React__default["default"].createElement(_StyledButton, props);

var _StyledButton = _styled__default["default"](Button).withConfig({
  displayName: "PlateButton___StyledButton",
  componentId: "sc-wfqywr-0"
})(["", ""], plateButtonCss);

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

const Icon = /*#__PURE__*/React.forwardRef((props, ref) => {
  const {
    children,
    iconVerticalAlign,
    size,
    title,
    ...otherProps
  } = props;
  const iconProps = {
    height: props.height !== undefined ? props.height : size,
    width: props.width !== undefined ? props.width : size,
    'aria-hidden': title == null ? 'true' : undefined,
    focusable: 'false',
    role: title != null ? 'img' : undefined,
    ...otherProps
  };
  return /*#__PURE__*/React__default["default"].createElement("svg", _extends({}, iconProps, {
    ref: ref
  }), title && /*#__PURE__*/React__default["default"].createElement("title", {
    key: "icon-title"
  }, title), children);
});

const StyledIcon = _styled__default["default"](Icon).withConfig({
  displayName: "StyledIcon",
  componentId: "sc-1lmwuuu-0"
})(["display:inline-block;vertical-align:", ";overflow:hidden;height:100%;"], props => props.iconVerticalAlign);

const DeleteIcon = props => /*#__PURE__*/React__default["default"].createElement(StyledIcon, _extends({
  viewBox: "0 0 24 24",
  fill: "currentColor"
}, props), /*#__PURE__*/React__default["default"].createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0z"
}), /*#__PURE__*/React__default["default"].createElement("path", {
  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"
}));

const RemoveNodeButton = ({
  element,
  ...props
}) => {
  const editor = plateCore.useEditorRef();
  return /*#__PURE__*/React__default["default"].createElement(_StyledPlateButton, _extends({
    onClick: () => {
      const path = plateCore.findNodePath(editor, element);
      plateCore.removeNodes(editor, {
        at: path
      });
      plateCore.focusEditor(editor, editor.selection);
    }
  }, props, {
    $_css: [{
      "paddingTop": "0.25rem",
      "paddingBottom": "0.25rem",
      "paddingLeft": "0px",
      "paddingRight": "0px"
    }, `
        width: 24px;
        height: 24px;
      `]
  }), /*#__PURE__*/React__default["default"].createElement(DeleteIcon, null));
};

var _StyledPlateButton = _styled__default["default"](PlateButton).withConfig({
  displayName: "RemoveNodeButton___StyledPlateButton",
  componentId: "sc-nzabn0-0"
})(["", ""], p => p.$_css);

_styled__default["default"](StyledIcon).withConfig({
  displayName: "ChevronDownIcon___StyledStyledIcon",
  componentId: "sc-1mognml-0"
})({
  "display": "inline",
  "textAlign": "center",
  "userSelect": "none",
  "overflow": "hidden",
  "pointerEvents": "none",
  "maxWidth": "100%",
  "maxHeight": "100%",
  "height": "100%",
  "verticalAlign": "middle"
});

const PlateFloatingMedia = ({
  pluginKey
}) => {
  const isEditing = plateMedia.useFloatingMediaSelectors().isEditing();
  const element = plateCore.useElement();
  return /*#__PURE__*/React__default["default"].createElement(_StyledDiv$1, null, !isEditing ? /*#__PURE__*/React__default["default"].createElement(_StyledDiv2, null, /*#__PURE__*/React__default["default"].createElement(_StyledFloatingMediaEditButton, null, "Edit link"), /*#__PURE__*/React__default["default"].createElement(plateUiToolbar.FloatingVerticalDivider, null), /*#__PURE__*/React__default["default"].createElement(_StyledRemoveNodeButton, {
    element: element
  })) : /*#__PURE__*/React__default["default"].createElement(_StyledDiv3, null, /*#__PURE__*/React__default["default"].createElement(plateUiToolbar.FloatingInputWrapper, null, /*#__PURE__*/React__default["default"].createElement(plateUiToolbar.FloatingIconWrapper, null, /*#__PURE__*/React__default["default"].createElement(plateLink.LinkIcon, {
    width: 18
  })), /*#__PURE__*/React__default["default"].createElement(_StyledFloatingMediaUrlInput, {
    placeholder: "Paste the embed link...",
    pluginKey: pluginKey
  }))));
};

var _StyledDiv$1 = _styled__default["default"]("div").withConfig({
  displayName: "PlateFloatingMedia___StyledDiv",
  componentId: "sc-1sqs53t-0"
})(["", ""], plateUiToolbar.floatingRootCss);

var _StyledDiv2 = _styled__default["default"]("div").withConfig({
  displayName: "PlateFloatingMedia___StyledDiv2",
  componentId: "sc-1sqs53t-1"
})(["", ""], plateUiToolbar.floatingRowCss);

var _StyledFloatingMediaEditButton = _styled__default["default"](plateMedia.FloatingMedia.EditButton).withConfig({
  displayName: "PlateFloatingMedia___StyledFloatingMediaEditButton",
  componentId: "sc-1sqs53t-2"
})(["", ""], plateButtonCss);

var _StyledRemoveNodeButton = _styled__default["default"](RemoveNodeButton).withConfig({
  displayName: "PlateFloatingMedia___StyledRemoveNodeButton",
  componentId: "sc-1sqs53t-3"
})(["", ""], plateUiToolbar.floatingButtonCss);

var _StyledDiv3 = _styled__default["default"]("div").withConfig({
  displayName: "PlateFloatingMedia___StyledDiv3",
  componentId: "sc-1sqs53t-4"
})({
  "display": "flex",
  "flexDirection": "column",
  "width": "330px"
});

var _StyledFloatingMediaUrlInput = _styled__default["default"](plateMedia.FloatingMedia.UrlInput).withConfig({
  displayName: "PlateFloatingMedia___StyledFloatingMediaUrlInput",
  componentId: "sc-1sqs53t-5"
})(["", ""], plateUiToolbar.floatingInputCss);

const MediaEmbedElement = props => {
  var _styles$figure, _styles$resizable, _styles$handleLeft, _styles$handleLeft2, _styles$handleRight, _styles$handleRight2, _styles$resizable2, _styles$iframeWrapper, _styles$iframeWrapper2, _styles$iframe, _styles$iframe2, _styles$figcaption, _styles$figcaption2, _styles$caption, _styles$caption2;

  const {
    children,
    nodeProps
  } = props;
  const {
    as,
    ...rootProps
  } = props;
  const focused = slateReact.useFocused();
  const selected = slateReact.useSelected();
  const readOnly = slateReact.useReadOnly();
  const {
    provider
  } = plateMedia.useMediaStore().get.urlData();
  const styles = getMediaEmbedElementStyles({ ...props,
    provider,
    selected,
    focused,
    readOnly
  });
  return /*#__PURE__*/React__default["default"].createElement(plateFloating.ElementPopover, {
    content: /*#__PURE__*/React__default["default"].createElement(PlateFloatingMedia, {
      pluginKey: plateMedia.ELEMENT_MEDIA_EMBED
    }),
    floatingOptions: mediaFloatingOptions
  }, /*#__PURE__*/React__default["default"].createElement(_StyledMediaRoot$1, _extends$1({}, rootProps, {
    $_css: styles.root.css
  }), /*#__PURE__*/React__default["default"].createElement(_StyledFigure$1, {
    className: "group",
    contentEditable: false,
    $_css2: (_styles$figure = styles.figure) === null || _styles$figure === void 0 ? void 0 : _styles$figure.css
  }, /*#__PURE__*/React__default["default"].createElement(_StyledMediaResizable$1, {
    className: (_styles$resizable = styles.resizable) === null || _styles$resizable === void 0 ? void 0 : _styles$resizable.className,
    maxWidth: provider === 'twitter' ? 550 : '100%',
    minWidth: provider === 'twitter' ? 300 : 100,
    handleComponent: {
      left: /*#__PURE__*/React__default["default"].createElement(_StyledBox$1, {
        className: (_styles$handleLeft = styles.handleLeft) === null || _styles$handleLeft === void 0 ? void 0 : _styles$handleLeft.className,
        $_css4: [(_styles$handleLeft2 = styles.handleLeft) === null || _styles$handleLeft2 === void 0 ? void 0 : _styles$handleLeft2.css]
      }),
      right: /*#__PURE__*/React__default["default"].createElement(_StyledBox2$1, {
        className: (_styles$handleRight = styles.handleRight) === null || _styles$handleRight === void 0 ? void 0 : _styles$handleRight.className,
        $_css5: (_styles$handleRight2 = styles.handleRight) === null || _styles$handleRight2 === void 0 ? void 0 : _styles$handleRight2.css
      })
    },
    $_css3: (_styles$resizable2 = styles.resizable) === null || _styles$resizable2 === void 0 ? void 0 : _styles$resizable2.css
  }, /*#__PURE__*/React__default["default"].createElement(_StyledDiv, {
    className: (_styles$iframeWrapper = styles.iframeWrapper) === null || _styles$iframeWrapper === void 0 ? void 0 : _styles$iframeWrapper.className,
    $_css6: (_styles$iframeWrapper2 = styles.iframeWrapper) === null || _styles$iframeWrapper2 === void 0 ? void 0 : _styles$iframeWrapper2.css
  }, /*#__PURE__*/React__default["default"].createElement(_StyledMediaEmbed, _extends$1({
    className: (_styles$iframe = styles.iframe) === null || _styles$iframe === void 0 ? void 0 : _styles$iframe.className
  }, nodeProps, {
    $_css7: (_styles$iframe2 = styles.iframe) === null || _styles$iframe2 === void 0 ? void 0 : _styles$iframe2.css
  })))), /*#__PURE__*/React__default["default"].createElement(_StyledCaptionRoot$1, {
    className: (_styles$figcaption = styles.figcaption) === null || _styles$figcaption === void 0 ? void 0 : _styles$figcaption.className,
    $_css8: (_styles$figcaption2 = styles.figcaption) === null || _styles$figcaption2 === void 0 ? void 0 : _styles$figcaption2.css
  }, /*#__PURE__*/React__default["default"].createElement(_StyledCaptionTextarea$1, {
    className: (_styles$caption = styles.caption) === null || _styles$caption === void 0 ? void 0 : _styles$caption.className,
    placeholder: "Write a caption...",
    $_css9: (_styles$caption2 = styles.caption) === null || _styles$caption2 === void 0 ? void 0 : _styles$caption2.css
  }))), children));
};

var _StyledMediaRoot$1 = _styled__default["default"](plateMedia.Media.Root).withConfig({
  displayName: "MediaEmbedElement___StyledMediaRoot",
  componentId: "sc-v088o8-0"
})(["", ""], p => p.$_css);

var _StyledFigure$1 = _styled__default["default"]("figure").withConfig({
  displayName: "MediaEmbedElement___StyledFigure",
  componentId: "sc-v088o8-1"
})(["", ""], p => p.$_css2);

var _StyledMediaResizable$1 = _styled__default["default"](plateMedia.Media.Resizable).withConfig({
  displayName: "MediaEmbedElement___StyledMediaResizable",
  componentId: "sc-v088o8-2"
})(["", ""], p => p.$_css3);

var _StyledBox$1 = _styled__default["default"](plateCore.Box).withConfig({
  displayName: "MediaEmbedElement___StyledBox",
  componentId: "sc-v088o8-3"
})(["", ""], p => p.$_css4);

var _StyledBox2$1 = _styled__default["default"](plateCore.Box).withConfig({
  displayName: "MediaEmbedElement___StyledBox2",
  componentId: "sc-v088o8-4"
})(["", ""], p => p.$_css5);

var _StyledDiv = _styled__default["default"]("div").withConfig({
  displayName: "MediaEmbedElement___StyledDiv",
  componentId: "sc-v088o8-5"
})(["", ""], p => p.$_css6);

var _StyledMediaEmbed = _styled__default["default"](plateMedia.MediaEmbed).withConfig({
  displayName: "MediaEmbedElement___StyledMediaEmbed",
  componentId: "sc-v088o8-6"
})(["", ""], p => p.$_css7);

var _StyledCaptionRoot$1 = _styled__default["default"](plateMedia.Caption.Root).withConfig({
  displayName: "MediaEmbedElement___StyledCaptionRoot",
  componentId: "sc-v088o8-7"
})(["", ""], p => p.$_css8);

var _StyledCaptionTextarea$1 = _styled__default["default"](plateMedia.Caption.Textarea).withConfig({
  displayName: "MediaEmbedElement___StyledCaptionTextarea",
  componentId: "sc-v088o8-8"
})(["", ""], p => p.$_css9);

const ImageElement = props => {
  var _styles$figure, _styles$figure2, _styles$resizable, _styles$handleLeft, _styles$handleLeft2, _styles$handleRight, _styles$handleRight2, _styles$resizable2, _styles$img, _styles$img2, _styles$figcaption, _styles$figcaption2, _styles$caption, _caption$placeholder, _styles$caption2;

  const {
    children,
    nodeProps,
    caption = {},
    resizableProps,
    align = 'center',
    ignoreReadOnly = false
  } = props;
  const {
    as,
    ...rootProps
  } = props;
  const focused = slateReact.useFocused();
  const selected = slateReact.useSelected();
  const readOnly = slateReact.useReadOnly();
  const styles = getImageElementStyles({ ...props,
    align,
    focused,
    selected
  });
  return /*#__PURE__*/React__default["default"].createElement(plateFloating.ElementPopover, {
    content: /*#__PURE__*/React__default["default"].createElement(PlateFloatingMedia, {
      pluginKey: plateMedia.ELEMENT_IMAGE
    }),
    floatingOptions: mediaFloatingOptions
  }, /*#__PURE__*/React__default["default"].createElement(_StyledMediaRoot, _extends$1({}, rootProps, {
    $_css: styles.root.css
  }), /*#__PURE__*/React__default["default"].createElement(_StyledFigure, {
    className: `group ${(_styles$figure = styles.figure) === null || _styles$figure === void 0 ? void 0 : _styles$figure.className}`,
    contentEditable: false,
    $_css2: (_styles$figure2 = styles.figure) === null || _styles$figure2 === void 0 ? void 0 : _styles$figure2.css
  }, /*#__PURE__*/React__default["default"].createElement(_StyledMediaResizable, _extends$1({
    className: (_styles$resizable = styles.resizable) === null || _styles$resizable === void 0 ? void 0 : _styles$resizable.className,
    handleComponent: {
      left: /*#__PURE__*/React__default["default"].createElement(_StyledBox, {
        className: (_styles$handleLeft = styles.handleLeft) === null || _styles$handleLeft === void 0 ? void 0 : _styles$handleLeft.className,
        $_css4: [(_styles$handleLeft2 = styles.handleLeft) === null || _styles$handleLeft2 === void 0 ? void 0 : _styles$handleLeft2.css]
      }),
      right: /*#__PURE__*/React__default["default"].createElement(_StyledBox2, {
        className: (_styles$handleRight = styles.handleRight) === null || _styles$handleRight === void 0 ? void 0 : _styles$handleRight.className,
        $_css5: (_styles$handleRight2 = styles.handleRight) === null || _styles$handleRight2 === void 0 ? void 0 : _styles$handleRight2.css
      })
    },
    align: align,
    readOnly: !ignoreReadOnly && readOnly
  }, resizableProps, {
    $_css3: (_styles$resizable2 = styles.resizable) === null || _styles$resizable2 === void 0 ? void 0 : _styles$resizable2.css
  }), /*#__PURE__*/React__default["default"].createElement(_StyledImage, _extends$1({
    className: (_styles$img = styles.img) === null || _styles$img === void 0 ? void 0 : _styles$img.className
  }, nodeProps, {
    $_css6: (_styles$img2 = styles.img) === null || _styles$img2 === void 0 ? void 0 : _styles$img2.css
  }))), !caption.disabled && /*#__PURE__*/React__default["default"].createElement(_StyledCaptionRoot, {
    className: (_styles$figcaption = styles.figcaption) === null || _styles$figcaption === void 0 ? void 0 : _styles$figcaption.className,
    $_css7: (_styles$figcaption2 = styles.figcaption) === null || _styles$figcaption2 === void 0 ? void 0 : _styles$figcaption2.css
  }, /*#__PURE__*/React__default["default"].createElement(_StyledCaptionTextarea, {
    className: (_styles$caption = styles.caption) === null || _styles$caption === void 0 ? void 0 : _styles$caption.className,
    placeholder: (_caption$placeholder = caption.placeholder) !== null && _caption$placeholder !== void 0 ? _caption$placeholder : 'Write a caption...',
    readOnly: !ignoreReadOnly && readOnly || !!caption.readOnly,
    $_css8: (_styles$caption2 = styles.caption) === null || _styles$caption2 === void 0 ? void 0 : _styles$caption2.css
  }))), children));
};

var _StyledMediaRoot = _styled__default["default"](plateMedia.Media.Root).withConfig({
  displayName: "ImageElement___StyledMediaRoot",
  componentId: "sc-uh8bwd-0"
})(["", ""], p => p.$_css);

var _StyledFigure = _styled__default["default"]("figure").withConfig({
  displayName: "ImageElement___StyledFigure",
  componentId: "sc-uh8bwd-1"
})(["", ""], p => p.$_css2);

var _StyledMediaResizable = _styled__default["default"](plateMedia.Media.Resizable).withConfig({
  displayName: "ImageElement___StyledMediaResizable",
  componentId: "sc-uh8bwd-2"
})(["", ""], p => p.$_css3);

var _StyledBox = _styled__default["default"](plateCore.Box).withConfig({
  displayName: "ImageElement___StyledBox",
  componentId: "sc-uh8bwd-3"
})(["", ""], p => p.$_css4);

var _StyledBox2 = _styled__default["default"](plateCore.Box).withConfig({
  displayName: "ImageElement___StyledBox2",
  componentId: "sc-uh8bwd-4"
})(["", ""], p => p.$_css5);

var _StyledImage = _styled__default["default"](plateMedia.Image).withConfig({
  displayName: "ImageElement___StyledImage",
  componentId: "sc-uh8bwd-5"
})(["", ""], p => p.$_css6);

var _StyledCaptionRoot = _styled__default["default"](plateMedia.Caption.Root).withConfig({
  displayName: "ImageElement___StyledCaptionRoot",
  componentId: "sc-uh8bwd-6"
})(["", ""], p => p.$_css7);

var _StyledCaptionTextarea = _styled__default["default"](plateMedia.Caption.Textarea).withConfig({
  displayName: "ImageElement___StyledCaptionTextarea",
  componentId: "sc-uh8bwd-7"
})(["", ""], p => p.$_css8);

const ImageToolbarButton = ({
  id,
  getImageUrl,
  ...props
}) => {
  const editor = plateCore.usePlateEditorRef(plateCore.useEventPlateId(id));
  return /*#__PURE__*/React__default["default"].createElement(plateUiToolbar.ToolbarButton, _extends$1({
    tooltip: {
      content: 'Image'
    },
    onClick: async e => {
      e.preventDefault();
      e.stopPropagation();
      let url;

      if (getImageUrl) {
        url = await getImageUrl();
      } else {
        url = window.prompt('Enter the URL of the image:');
      }

      if (!url) return;
      plateMedia.insertImage(editor, url);
      plateCore.focusEditor(editor);
    }
  }, props));
};

const MediaEmbedToolbarButton = ({
  id,
  getEmbedUrl,
  ...props
}) => {
  const editor = plateCore.usePlateEditorRef(plateCore.useEventPlateId(id));
  return /*#__PURE__*/React__default["default"].createElement(plateUiToolbar.ToolbarButton, _extends$1({
    tooltip: {
      content: 'Embed'
    },
    onClick: async e => {
      e.preventDefault();
      e.stopPropagation();
      let url;

      if (getEmbedUrl) {
        url = await getEmbedUrl();
      } else {
        url = window.prompt('Enter the URL of the embed:');
      }

      if (!url) return;
      plateMedia.insertMediaEmbed(editor, {
        url
      });
      plateCore.focusEditor(editor);
    }
  }, props));
};

exports.ImageElement = ImageElement;
exports.ImageToolbarButton = ImageToolbarButton;
exports.MediaEmbedElement = MediaEmbedElement;
exports.MediaEmbedToolbarButton = MediaEmbedToolbarButton;
exports.PlateFloatingMedia = PlateFloatingMedia;
exports.getCaptionCss = getCaptionCss;
exports.getImageElementStyles = getImageElementStyles;
exports.getMediaEmbedElementStyles = getMediaEmbedElementStyles;
exports.getResizableCss = getResizableCss;
exports.mediaFloatingOptions = mediaFloatingOptions;
//# sourceMappingURL=index.js.map
