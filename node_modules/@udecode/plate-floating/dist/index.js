'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var reactDomInteractions = require('@floating-ui/react-dom-interactions');
var React = require('react');
var plateCore = require('@udecode/plate-core');
var slateReact = require('slate-react');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

const getDefaultBoundingClientRect = () => ({
  width: 0,
  height: 0,
  x: 0,
  y: 0,
  top: -9999,
  left: -9999,
  right: 9999,
  bottom: 9999
});
const createVirtualElement = () => ({
  getBoundingClientRect: getDefaultBoundingClientRect
});

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

/**
 * Popover displayed over children, rendering `content`
 */
const Popover = ({
  floatingOptions,
  children,
  content,
  ...props
}) => {
  const {
    x,
    y,
    reference,
    floating,
    strategy
  } = reactDomInteractions.useFloating({
    middleware: [reactDomInteractions.offset(12), reactDomInteractions.flip({
      padding: 96
    }), reactDomInteractions.shift()],
    whileElementsMounted: reactDomInteractions.autoUpdate,
    ...floatingOptions
  });
  const {
    getReferenceProps
  } = reactDomInteractions.useInteractions();
  return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React.cloneElement(children, getReferenceProps({
    ref: reference,
    ...children.props
  })), (floatingOptions === null || floatingOptions === void 0 ? void 0 : floatingOptions.open) && plateCore.createElementAs('div', {
    ref: floating,
    style: {
      position: strategy,
      top: y !== null && y !== void 0 ? y : 0,
      left: x !== null && x !== void 0 ? x : 0,
      zIndex: 1
    },
    contentEditable: false,
    children: content,
    ...props
  }));
};

/**
 * Popover displayed over an element if:
 * - not read-only
 * - element selected
 */

const ElementPopover = ({
  floatingOptions = {},
  ...props
}) => {
  const readOnly = slateReact.useReadOnly();
  const selected = slateReact.useSelected();
  const editor = plateCore.usePlateEditorState();
  return /*#__PURE__*/React__default["default"].createElement(Popover, _extends({
    floatingOptions: {
      open: !readOnly && selected && plateCore.isCollapsed(editor.selection),
      ...floatingOptions
    }
  }, props));
};

/**
 * Get bounding client rect by slate range
 */

const getRangeBoundingClientRect = (editor, at) => {
  if (!at) return getDefaultBoundingClientRect();
  const domRange = plateCore.toDOMRange(editor, at);
  if (!domRange) return getDefaultBoundingClientRect();
  return domRange.getBoundingClientRect();
};

/**
 * Get bounding client rect of the window selection
 */

const getSelectionBoundingClientRect = () => {
  const domSelection = window.getSelection();

  if (!domSelection || domSelection.rangeCount < 1) {
    return getDefaultBoundingClientRect();
  }

  const domRange = domSelection.getRangeAt(0);
  return domRange.getBoundingClientRect();
};

/**
 * `useFloating` with a controlled virtual element. Used to follow cursor position.
 *
 * Default options:
 * - `whileElementsMounted: autoUpdate`
 *
 * Additional options:
 * - `getBoundingClientRect` to get the bounding client rect.
 * - `hidden` to hide the floating element
 *
 * Additional returns:
 * - `style` to apply to the floating element
 * - `virtualElementRef`
 *
 * @see useFloating
 * @see https://floating-ui.com/docs/react-dom#virtual-element
 */
const useVirtualFloating = ({
  getBoundingClientRect = getSelectionBoundingClientRect,
  ...floatingOptions
}) => {
  const virtualElementRef = React.useRef(createVirtualElement());
  const [visible, setVisible] = React.useState(true);
  const floatingResult = reactDomInteractions.useFloating({
    // update on scroll and resize
    whileElementsMounted: reactDomInteractions.autoUpdate,
    ...floatingOptions
  });
  const {
    reference,
    middlewareData,
    strategy,
    x,
    y,
    update
  } = floatingResult;
  React.useLayoutEffect(() => {
    virtualElementRef.current.getBoundingClientRect = getBoundingClientRect;
  }, [getBoundingClientRect, update]);
  React.useLayoutEffect(() => {
    reference(virtualElementRef.current);
  }, [reference]);
  React.useLayoutEffect(() => {
    if (!(middlewareData !== null && middlewareData !== void 0 && middlewareData.hide)) return;
    const {
      referenceHidden
    } = middlewareData.hide;
    setVisible(!referenceHidden);
  }, [middlewareData.hide]);
  return { ...floatingResult,
    virtualElementRef,
    style: {
      position: strategy,
      top: y !== null && y !== void 0 ? y : 0,
      left: x !== null && x !== void 0 ? x : 0,
      display: floatingOptions.open === false ? 'none' : undefined,
      visibility: !visible ? 'hidden' : undefined
    }
  };
};

Object.defineProperty(exports, 'arrow', {
  enumerable: true,
  get: function () { return reactDomInteractions.arrow; }
});
Object.defineProperty(exports, 'autoPlacement', {
  enumerable: true,
  get: function () { return reactDomInteractions.autoPlacement; }
});
Object.defineProperty(exports, 'autoUpdate', {
  enumerable: true,
  get: function () { return reactDomInteractions.autoUpdate; }
});
Object.defineProperty(exports, 'computePosition', {
  enumerable: true,
  get: function () { return reactDomInteractions.computePosition; }
});
Object.defineProperty(exports, 'detectOverflow', {
  enumerable: true,
  get: function () { return reactDomInteractions.detectOverflow; }
});
Object.defineProperty(exports, 'flip', {
  enumerable: true,
  get: function () { return reactDomInteractions.flip; }
});
Object.defineProperty(exports, 'getOverflowAncestors', {
  enumerable: true,
  get: function () { return reactDomInteractions.getOverflowAncestors; }
});
Object.defineProperty(exports, 'hide', {
  enumerable: true,
  get: function () { return reactDomInteractions.hide; }
});
Object.defineProperty(exports, 'inline', {
  enumerable: true,
  get: function () { return reactDomInteractions.inline; }
});
Object.defineProperty(exports, 'limitShift', {
  enumerable: true,
  get: function () { return reactDomInteractions.limitShift; }
});
Object.defineProperty(exports, 'offset', {
  enumerable: true,
  get: function () { return reactDomInteractions.offset; }
});
Object.defineProperty(exports, 'safePolygon', {
  enumerable: true,
  get: function () { return reactDomInteractions.safePolygon; }
});
Object.defineProperty(exports, 'shift', {
  enumerable: true,
  get: function () { return reactDomInteractions.shift; }
});
Object.defineProperty(exports, 'size', {
  enumerable: true,
  get: function () { return reactDomInteractions.size; }
});
Object.defineProperty(exports, 'useClick', {
  enumerable: true,
  get: function () { return reactDomInteractions.useClick; }
});
Object.defineProperty(exports, 'useDelayGroup', {
  enumerable: true,
  get: function () { return reactDomInteractions.useDelayGroup; }
});
Object.defineProperty(exports, 'useDelayGroupContext', {
  enumerable: true,
  get: function () { return reactDomInteractions.useDelayGroupContext; }
});
Object.defineProperty(exports, 'useDismiss', {
  enumerable: true,
  get: function () { return reactDomInteractions.useDismiss; }
});
Object.defineProperty(exports, 'useFloating', {
  enumerable: true,
  get: function () { return reactDomInteractions.useFloating; }
});
Object.defineProperty(exports, 'useFloatingNodeId', {
  enumerable: true,
  get: function () { return reactDomInteractions.useFloatingNodeId; }
});
Object.defineProperty(exports, 'useFloatingParentNodeId', {
  enumerable: true,
  get: function () { return reactDomInteractions.useFloatingParentNodeId; }
});
Object.defineProperty(exports, 'useFloatingPortalNode', {
  enumerable: true,
  get: function () { return reactDomInteractions.useFloatingPortalNode; }
});
Object.defineProperty(exports, 'useFloatingTree', {
  enumerable: true,
  get: function () { return reactDomInteractions.useFloatingTree; }
});
Object.defineProperty(exports, 'useFocus', {
  enumerable: true,
  get: function () { return reactDomInteractions.useFocus; }
});
Object.defineProperty(exports, 'useHover', {
  enumerable: true,
  get: function () { return reactDomInteractions.useHover; }
});
Object.defineProperty(exports, 'useId', {
  enumerable: true,
  get: function () { return reactDomInteractions.useId; }
});
Object.defineProperty(exports, 'useInteractions', {
  enumerable: true,
  get: function () { return reactDomInteractions.useInteractions; }
});
Object.defineProperty(exports, 'useListNavigation', {
  enumerable: true,
  get: function () { return reactDomInteractions.useListNavigation; }
});
Object.defineProperty(exports, 'useRole', {
  enumerable: true,
  get: function () { return reactDomInteractions.useRole; }
});
Object.defineProperty(exports, 'useTypeahead', {
  enumerable: true,
  get: function () { return reactDomInteractions.useTypeahead; }
});
exports.ElementPopover = ElementPopover;
exports.Popover = Popover;
exports.createVirtualElement = createVirtualElement;
exports.getDefaultBoundingClientRect = getDefaultBoundingClientRect;
exports.getRangeBoundingClientRect = getRangeBoundingClientRect;
exports.getSelectionBoundingClientRect = getSelectionBoundingClientRect;
exports.useVirtualFloating = useVirtualFloating;
//# sourceMappingURL=index.js.map
