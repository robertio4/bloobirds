/// <reference types="react" />
import { PlateProps } from '../components/plate/Plate';
import { TEditor, Value } from '../slate/editor/TEditor';
import { PlateEditor } from '../types/plate/PlateEditor';
export interface WithPlateOptions<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> extends Pick<PlateProps<V, E>, 'disableCorePlugins' | 'plugins'> {
    id?: any;
}
/**
 * Apply `withInlineVoid` and all plate plugins `withOverrides`.
 * Overrides:
 * - `id`: id of the editor.
 * - `key`: random key for the <Slate> component so each time the editor is created, the component resets.
 * - `options`: Plate options
 */
export declare const withPlate: <V extends Value = Value, E extends TEditor<V> = TEditor<V>>(e: E, { id, plugins, disableCorePlugins, }?: WithPlateOptions<V, E & Omit<import("slate").BaseEditor, "children" | "operations" | "marks" | "isInline" | "isVoid" | "markableVoid" | "normalizeNode" | "apply" | "getFragment" | "insertFragment" | "insertNode" | "getDirtyPaths" | "id"> & {
    id: any;
    children: V;
    operations: import("..").TOperation<import("..").TDescendant>[];
    marks: Record<string, any> | null;
    isInline: <N extends import("..").TElement>(element: N) => boolean;
    isVoid: <N_1 extends import("..").TElement>(element: N_1) => boolean;
    markableVoid: <N_2 extends import("..").TElement>(element: N_2) => boolean;
    normalizeNode: <N_3 extends import("..").TNode>(entry: import("..").TNodeEntry<N_3>) => void;
    apply: <N_4 extends import("..").TDescendant>(operation: import("..").TOperation<N_4>) => void;
    getFragment: <N_5 extends import("..").TDescendant>() => N_5[];
    insertFragment: <N_6 extends import("..").TDescendant>(fragment: N_6[]) => void;
    insertNode: <N_7 extends import("..").TDescendant>(node: N_7) => void;
    getDirtyPaths: <N_8 extends import("..").TDescendant>(operation: import("..").TOperation<N_8>) => import("slate").Path[];
} & import("..").UnknownObject & Pick<import("slate-history").HistoryEditor, "history" | "undo" | "redo"> & Pick<import("slate-react").ReactEditor, "insertData" | "insertFragmentData" | "insertTextData" | "setFragmentData" | "hasRange" | "hasTarget" | "hasEditableTarget" | "hasSelectableTarget" | "isTargetInsideNonReadonlyVoid"> & {
    key: any;
    plugins: import("..").WithPlatePlugin<{}, V, PlateEditor<V>>[];
    pluginsByKey: Record<string, import("..").WithPlatePlugin<{}, V, PlateEditor<V>>>;
    prevSelection: import("slate").BaseRange | null;
    blockFactory: (node?: Partial<import("..").TElement> | undefined, path?: import("slate").Path | undefined) => import("..").ElementOf<TEditor<V>>;
    childrenFactory: () => V;
    currentKeyboardEvent: import("react").KeyboardEvent<Element> | null;
}>) => E & Omit<import("slate").BaseEditor, "children" | "operations" | "marks" | "isInline" | "isVoid" | "markableVoid" | "normalizeNode" | "apply" | "getFragment" | "insertFragment" | "insertNode" | "getDirtyPaths" | "id"> & {
    id: any;
    children: V;
    operations: import("..").TOperation<import("..").TDescendant>[];
    marks: Record<string, any> | null;
    isInline: <N extends import("..").TElement>(element: N) => boolean;
    isVoid: <N_1 extends import("..").TElement>(element: N_1) => boolean;
    markableVoid: <N_2 extends import("..").TElement>(element: N_2) => boolean;
    normalizeNode: <N_3 extends import("..").TNode>(entry: import("..").TNodeEntry<N_3>) => void;
    apply: <N_4 extends import("..").TDescendant>(operation: import("..").TOperation<N_4>) => void;
    getFragment: <N_5 extends import("..").TDescendant>() => N_5[];
    insertFragment: <N_6 extends import("..").TDescendant>(fragment: N_6[]) => void;
    insertNode: <N_7 extends import("..").TDescendant>(node: N_7) => void;
    getDirtyPaths: <N_8 extends import("..").TDescendant>(operation: import("..").TOperation<N_8>) => import("slate").Path[];
} & import("..").UnknownObject & Pick<import("slate-history").HistoryEditor, "history" | "undo" | "redo"> & Pick<import("slate-react").ReactEditor, "insertData" | "insertFragmentData" | "insertTextData" | "setFragmentData" | "hasRange" | "hasTarget" | "hasEditableTarget" | "hasSelectableTarget" | "isTargetInsideNonReadonlyVoid"> & {
    key: any;
    plugins: import("..").WithPlatePlugin<{}, V, PlateEditor<V>>[];
    pluginsByKey: Record<string, import("..").WithPlatePlugin<{}, V, PlateEditor<V>>>;
    prevSelection: import("slate").BaseRange | null;
    blockFactory: (node?: Partial<import("..").TElement> | undefined, path?: import("slate").Path | undefined) => import("..").ElementOf<TEditor<V>>;
    childrenFactory: () => V;
    currentKeyboardEvent: import("react").KeyboardEvent<Element> | null;
};
//# sourceMappingURL=withPlate.d.ts.map