import { getPlugin, withoutNormalizing, focusEditor, insertText, withoutMergingHistory, deleteText, getPointBefore, getEditorString, getRange, moveSelection, isCollapsed, createPluginFactory } from '@udecode/plate-core';
import { createRef, useReducer, useRef, useCallback, useEffect } from 'react';
import emojiMartData from '@emoji-mart/data';
import { comboboxActions } from '@udecode/plate-combobox';
import { Range } from 'slate';

const EmojiCategory = {
  Activity: 'activity',
  Custom: 'custom',
  Flags: 'flags',
  Foods: 'foods',
  Frequent: 'frequent',
  Nature: 'nature',
  Objects: 'objects',
  People: 'people',
  Places: 'places',
  Symbols: 'symbols'
};

const KEY_EMOJI = 'emoji';
const EMOJI_TRIGGER = ':';
const EMOJI_MAX_SEARCH_RESULT = 60;
const EMOJI_TRIGGERING_CONTROLLER_OPTIONS = {
  limitTriggeringChars: 3,
  maxTextToSearch: 30
};
const defaultCategories = [EmojiCategory.People, EmojiCategory.Nature, EmojiCategory.Foods, EmojiCategory.Activity, EmojiCategory.Places, EmojiCategory.Objects, EmojiCategory.Symbols, EmojiCategory.Flags];
const EmojiSettings = {
  buttonSize: {
    value: 36
  },
  perLine: {
    value: 8
  },
  showFrequent: {
    value: true,
    limit: 16
  },
  categories: {
    value: undefined
  }
};
const DEFAULT_FREQUENTLY_USED_EMOJI = {
  '+1': 1,
  grinning: 1,
  kissing_heart: 1,
  heart_eyes: 1,
  pray: 1,
  laughing: 1,
  clap: 1,
  joy: 1,
  scream: 1,
  rocket: 1,
  see_no_evil: 1,
  hugging_face: 1,
  heart: 1
};
const NUM_OF_CATEGORIES = Object.values(EmojiCategory).length;
const i18n = {
  search: 'Search all emoji',
  clear: 'Clear',
  searchNoResultsTitle: 'Oh no!',
  searchNoResultsSubtitle: 'That emoji couldnâ€™t be found',
  pick: 'Pick an emoji...',
  searchResult: 'Search Results',
  categories: {
    activity: 'Activity',
    custom: 'Custom',
    flags: 'Flags',
    foods: 'Food & Drink',
    frequent: 'Frequently used',
    nature: 'Animals & Nature',
    objects: 'Objects',
    people: 'Smileys & People',
    places: 'Travel & Places',
    symbols: 'Symbols'
  },
  skins: {
    choose: 'Choose default skin tone',
    '1': 'Default',
    '2': 'Light',
    '3': 'Medium-Light',
    '4': 'Medium',
    '5': 'Medium-Dark',
    '6': 'Dark'
  }
};

const setVisibleSections = (entries, visibleSections) => {
  for (const entry of entries) {
    const id = entry.target.dataset.id;
    visibleSections.set(id, entry.isIntersecting);
  }
};

const getSectionInFocus = visibleSections => {
  for (const [id, ratio] of visibleSections) {
    if (ratio) {
      return id;
    }
  }
};

const observeCategories = ({
  ancestorRef,
  emojiLibrary,
  setFocusedAndVisibleSections
}) => {
  const observerOptions = {
    root: ancestorRef.current,
    threshold: 0
  };
  const visibleSections = new Map();
  const observer = new IntersectionObserver(entries => {
    setVisibleSections(entries, visibleSections);
    const focusedSectionId = getSectionInFocus(visibleSections);
    setFocusedAndVisibleSections(visibleSections, focusedSectionId);
  }, observerOptions);

  for (const section of emojiLibrary.getGrid().sections()) {
    if (section.root.current) observer.observe(section.root.current);
  }

  return observer;
};

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

class EmojiTriggeringController {
  constructor(trigger = ':', options = EMOJI_TRIGGERING_CONTROLLER_OPTIONS) {
    this.trigger = trigger;
    this.options = options;

    _defineProperty(this, "text", '');

    _defineProperty(this, "pos", void 0);

    _defineProperty(this, "isTriggering", false);

    _defineProperty(this, "hasTriggeringMark", false);
  }

  setText(text) {
    this.text = text;
    this.hasTriggeringMark = this.isWithTriggeringMark(text);
    this.isTriggering = this.hasTriggeringMark && this.text.length >= this.options.limitTriggeringChars;
  }

  isWithTriggeringMark(text) {
    return new RegExp(`^${this.trigger}.*`).test(text);
  }

  getText() {
    return this.hasTriggeringMark ? this.text.slice(1) : this.text;
  }

  getOptions() {
    return this.options;
  }

  getTextSize() {
    return this.text.length;
  }

  reset() {
    this.text = '';
    this.isTriggering = false;
    this.hasTriggeringMark = false;
  }

}

class Grid {
  constructor() {
    _defineProperty(this, "rowsCount", 1);

    _defineProperty(this, "sectionsIds", []);

    _defineProperty(this, "grid", new Map());
  }

  addSection(sectionId, section, elements) {
    section.setIndexRowStart(this.rowsCount).addElements(elements[sectionId]);
    this.rowsCount += section.rowsNum;
    this.grid.set(sectionId, section);
    this.sectionsIds.push(sectionId);
    return this;
  }

  get size() {
    return this.grid.size;
  }

  indexOf(sectionId) {
    return this.sectionsIds.indexOf(sectionId);
  }

  sections() {
    return Array.from(this.grid.values());
  }

  section(sectionId) {
    return this.grid.get(sectionId);
  }

  updateSection(sectionId, elements) {
    if (this.grid.has(sectionId)) {
      const section = this.grid.get(sectionId);
      section.updateElements(elements);
    }

    return this;
  }

}

class AGridSection {
  constructor(_id, perLine = 8) {
    this._id = _id;
    this.perLine = perLine;

    _defineProperty(this, "rows", []);

    _defineProperty(this, "_root", void 0);

    _defineProperty(this, "_rowsNum", 0);

    _defineProperty(this, "_indexRowStart", 0);

    this.createRootRef();
  }

  setIndexRowStart(start) {
    this._indexRowStart = start;
    return this;
  }

  addElements(elements) {
    this._rowsNum = Math.ceil(elements.length / this.perLine);
    this.initRows(elements);
    return this;
  }

  updateElements(elements) {
    this.rows = [];
    this.addElements(elements);
    return this;
  }

  initRows(elements) {
    let i = 0;

    while (i < this.rowsNum) {
      this.addRow(elements, i++);
    }
  }

  addRow(elements, lastPosition) {
    const start = lastPosition * this.perLine;
    const end = start + this.perLine;
    this.rows.push({
      elements: elements.slice(start, end),
      id: this._indexRowStart + lastPosition
    });
  }

  get rowsNum() {
    return this._rowsNum;
  }

  get id() {
    return this._id;
  }

  get root() {
    return this._root;
  }

  getRows() {
    return this.rows;
  }

}

class EmojiFloatingGrid extends Grid {
  createRootRef() {
    return /*#__PURE__*/createRef();
  }

}
class EmojiGridSectionWithRoot extends AGridSection {
  createRootRef() {
    this._root = /*#__PURE__*/createRef();
  }

}

class EmojiFloatingGridBuilder {
  constructor(localStorage, sections, elements, settings) {
    this.localStorage = localStorage;
    this.sections = sections;
    this.elements = elements;
    this.settings = settings;

    _defineProperty(this, "grid", new EmojiFloatingGrid());
  }

  addFrequent() {
    if (this.settings.showFrequent.value) {
      const id = 'frequent';
      this.grid.addSection(id, new EmojiGridSectionWithRoot(id, this.settings.perLine.value), {
        [id]: this.localStorage.getList()
      });
    }
  }

  build() {
    this.addFrequent();
    this.sections.forEach(id => {
      this.grid.addSection(id, new EmojiGridSectionWithRoot(id, this.settings.perLine.value), this.elements);
    });
    return this.grid;
  }

}

class EmojiInlineLibrary {
  constructor(library = emojiMartData) {
    _defineProperty(this, "_hash", {});

    _defineProperty(this, "_keys", []);

    _defineProperty(this, "_emojis", void 0);

    this._emojis = library.emojis;
    this.init();
  }

  init() {
    Object.values(this._emojis).forEach(emoji => {
      const searchableString = this.createSearchableString(emoji);

      this._keys.push(searchableString);

      this._hash[searchableString] = emoji.id;
    });
  }

  createSearchableString(emoji) {
    const {
      id,
      name,
      keywords
    } = emoji;
    return `${id},${this.getName(name)},${keywords.join(',')}`;
  }

  getName(name) {
    return name.toLowerCase().split(' ').join(',');
  }

  get keys() {
    return this._keys;
  }

  getEmoji(id) {
    return this._emojis[id];
  }

  getEmojiId(key) {
    return this._hash[key];
  }

}

class EmojiFloatingLibrary extends EmojiInlineLibrary {
  constructor(settings, localStorage, library = emojiMartData) {
    var _settings$categories$;

    super(library);
    this.settings = settings;
    this.localStorage = localStorage;
    this.library = library;

    _defineProperty(this, "categories", defaultCategories);

    _defineProperty(this, "emojis", {});

    _defineProperty(this, "grid", void 0);

    this.categories = (_settings$categories$ = settings.categories.value) !== null && _settings$categories$ !== void 0 ? _settings$categories$ : this.categories;
    this.initEmojis(library.categories);
    this.grid = new EmojiFloatingGridBuilder(this.localStorage, this.categories, this.emojis, settings).build();
  }

  static getInstance(settings, localStorage, library = emojiMartData) {
    if (!EmojiFloatingLibrary.instance) {
      EmojiFloatingLibrary.instance = new EmojiFloatingLibrary(settings, localStorage, library);
    }

    return EmojiFloatingLibrary.instance;
  }

  initEmojis(categoriesLibrary) {
    for (const category of categoriesLibrary) {
      this.emojis[category.id] = category.emojis;
    }
  }

  updateFrequentCategory(emojiId) {
    this.localStorage.update(emojiId);
    this.grid.updateSection(EmojiCategory.Frequent, this.localStorage.getList());
  }

  getGrid() {
    return this.grid;
  }

  indexOf(focusedCategory) {
    const index = this.grid.indexOf(focusedCategory);
    return index < 1 ? 0 : index;
  }

}

_defineProperty(EmojiFloatingLibrary, "instance", void 0);

const initialState = {
  isOpen: false,
  searchValue: '',
  emoji: undefined,
  hasFound: false,
  isSearching: false,
  searchResult: [],
  focusedCategory: undefined,
  visibleCategories: new Map(),
  frequentEmoji: undefined
};
const EmojiPickerState = () => {
  const [cache, dispatch] = useReducer((state, action) => {
    const {
      type,
      payload
    } = action;

    switch (type) {
      case 'CLEAR_SEARCH':
        return { ...state,
          searchValue: '',
          isSearching: false,
          hasFound: false,
          focusedCategory: EmojiCategory.Frequent
        };

      case 'UPDATE_SEARCH_RESULT':
        return { ...state,
          ...payload,
          isSearching: true,
          focusedCategory: undefined
        };

      case 'SET_FOCUSED_CATEGORY':
        return { ...state,
          ...payload,
          searchValue: '',
          isSearching: false,
          hasFound: false
        };

      case 'SET_OPEN':
        return { ...state,
          isOpen: true
        };

      case 'SET_CLOSE':
        return { ...state,
          emoji: undefined,
          isOpen: false
        };

      case 'UPDATE_FREQUENT_EMOJIS':
        return { ...state,
          ...payload,
          emoji: undefined
        };

      case 'SET_SEARCH':
      case 'SET_EMOJI':
      case 'SET_FOCUSED_AND_VISIBLE_CATEGORIES':
        return { ...state,
          ...payload
        };

      default:
        {
          throw new Error(`Unhandled action type: ${type}`);
        }
    }
  }, initialState);
  return [cache, dispatch];
};

const getEmojiOnInsert = ({
  key = KEY_EMOJI
} = {}) => (editor, item) => {
  const {
    options: {
      createEmoji
    }
  } = getPlugin(editor, key);
  withoutNormalizing(editor, () => {
    focusEditor(editor);
    const value = createEmoji(item);
    insertText(editor, value);
  });
};

const useEmojiPicker = ({
  editor,
  emojiLibrary,
  indexSearch,
  closeOnSelect
}) => {
  const [state, dispatch] = EmojiPickerState();
  const refs = useRef({
    contentRoot: /*#__PURE__*/createRef(),
    content: /*#__PURE__*/createRef()
  });
  const onToggle = useCallback(() => {
    dispatch({
      type: state.isOpen ? 'SET_CLOSE' : 'SET_OPEN'
    });
  }, [dispatch, state.isOpen]);
  const setFocusedAndVisibleSections = useCallback((visibleSections, categoryId) => {
    dispatch({
      type: 'SET_FOCUSED_AND_VISIBLE_CATEGORIES',
      payload: {
        focusedCategory: categoryId,
        visibleCategories: visibleSections
      }
    });
  }, [dispatch]);
  const handleSearchInput = useCallback(input => {
    const value = String(input).replace(/\s/g, '');

    if (!value && !input) {
      dispatch({
        type: 'CLEAR_SEARCH'
      });
      return;
    }

    const hasFound = indexSearch.search(value).hasFound();
    dispatch({
      type: 'UPDATE_SEARCH_RESULT',
      payload: {
        searchValue: value,
        hasFound,
        searchResult: indexSearch.get()
      }
    });
  }, [dispatch, indexSearch]);
  const setSearch = useCallback(value => {
    value ? handleSearchInput(value) : dispatch({
      type: 'CLEAR_SEARCH'
    });
  }, [dispatch, handleSearchInput]);
  const clearSearch = useCallback(() => {
    dispatch({
      type: 'CLEAR_SEARCH'
    });
  }, [dispatch]);
  const onMouseOver = useCallback(emoji => {
    dispatch({
      type: 'SET_EMOJI',
      payload: {
        emoji
      }
    });
  }, [dispatch]);
  const updateFrequentEmojis = useCallback(emojiId => {
    emojiLibrary.updateFrequentCategory(emojiId);
    dispatch({
      type: 'UPDATE_FREQUENT_EMOJIS',
      payload: {
        frequentEmoji: emojiId,
        isOpen: closeOnSelect ? false : state.isOpen
      }
    });
  }, [closeOnSelect, dispatch, emojiLibrary, state.isOpen]);
  const onSelectEmoji = useCallback(emoji => {
    const selectItem = getEmojiOnInsert();
    selectItem(editor, {
      key: emoji.id,
      text: emoji.name,
      data: {
        id: emoji.id,
        emoji: emoji.skins[0].native,
        name: emoji.name,
        text: emoji.name
      }
    });
    updateFrequentEmojis(emoji.id);
  }, [editor, updateFrequentEmojis]);
  const handleCategoryClick = useCallback(categoryId => {
    dispatch({
      type: 'SET_FOCUSED_CATEGORY',
      payload: {
        focusedCategory: categoryId
      }
    });

    const getSectionPositionToScrollIntoView = () => {
      var _refs$current$content, _refs$current$content2, _refs$current$content3, _refs$current$content4, _section$root$current, _section$root$current2;

      const trashHold = 1;
      const section = emojiLibrary.getGrid().section(categoryId);
      const contentRootScrollTop = (_refs$current$content = (_refs$current$content2 = refs.current.contentRoot.current) === null || _refs$current$content2 === void 0 ? void 0 : _refs$current$content2.scrollTop) !== null && _refs$current$content !== void 0 ? _refs$current$content : 0;
      const contentRootTopPosition = (_refs$current$content3 = (_refs$current$content4 = refs.current.contentRoot.current) === null || _refs$current$content4 === void 0 ? void 0 : _refs$current$content4.getBoundingClientRect().top) !== null && _refs$current$content3 !== void 0 ? _refs$current$content3 : 0;
      const sectionTopPosition = (_section$root$current = section === null || section === void 0 ? void 0 : (_section$root$current2 = section.root.current) === null || _section$root$current2 === void 0 ? void 0 : _section$root$current2.getBoundingClientRect().top) !== null && _section$root$current !== void 0 ? _section$root$current : 0;
      return trashHold + contentRootScrollTop + sectionTopPosition - contentRootTopPosition;
    };

    if (refs.current.contentRoot.current) {
      refs.current.contentRoot.current.scrollTop = getSectionPositionToScrollIntoView();
    }
  }, [dispatch, emojiLibrary]);
  useEffect(() => {
    if (state.isOpen && !state.isSearching) {
      observeCategories({
        ancestorRef: refs.current.contentRoot,
        emojiLibrary,
        setFocusedAndVisibleSections
      });
    }
  }, [emojiLibrary, state.isOpen, state.isSearching, setFocusedAndVisibleSections]);
  return {
    onToggle,
    i18n,
    setSearch,
    clearSearch,
    emoji: state.emoji,
    onMouseOver,
    onSelectEmoji,
    emojiLibrary,
    handleCategoryClick,
    refs,
    ...state
  };
};

class AIndexSearch {
  constructor(library) {
    this.library = library;

    _defineProperty(this, "result", []);

    _defineProperty(this, "scores", {});

    _defineProperty(this, "maxResult", EMOJI_MAX_SEARCH_RESULT);
  }

  search(input) {
    const value = input.toLowerCase();

    if (value) {
      this.createSearchResult(value);
      this.sortResultByScores(this.result, this.scores);
    } else {
      this.scores = {};
      this.result = [];
    }

    return this;
  }

  createSearchResult(value) {
    this.scores = {};
    this.result = [];

    for (const key of this.library.keys) {
      const score = key.indexOf(`${value}`);
      if (score === -1) continue;
      const emojiId = this.library.getEmojiId(key);
      this.result.push(emojiId);
      this.scores[emojiId] || (this.scores[emojiId] = 0);
      this.scores[emojiId] += emojiId === value ? 0 : score + 1;
    }
  }

  sortResultByScores(result, scores) {
    result.sort((a, b) => {
      const aScore = scores[a];
      const bScore = scores[b];

      if (aScore === bScore) {
        return a.localeCompare(b);
      }

      return aScore - bScore;
    });
  }

  hasFound() {
    return !!this.result.length;
  }

  get() {
    const emojis = [];

    for (const key of this.result) {
      var _this$library;

      const emoji = (_this$library = this.library) === null || _this$library === void 0 ? void 0 : _this$library.getEmoji(key);
      emojis.push(this.transform(emoji));
      if (emojis.length >= this.maxResult) break;
    }

    return emojis;
  }

}

class EmojiFloatingIndexSearch extends AIndexSearch {
  constructor(library) {
    super(library);
    this.library = library;
  }

  static getInstance(library) {
    if (!EmojiFloatingIndexSearch.instance) {
      EmojiFloatingIndexSearch.instance = new EmojiFloatingIndexSearch(library);
    }

    return EmojiFloatingIndexSearch.instance;
  }

  transform(emoji) {
    return emoji;
  }

}

_defineProperty(EmojiFloatingIndexSearch, "instance", void 0);

class EmojiInlineIndexSearch extends AIndexSearch {
  constructor(library) {
    super(library);
    this.library = library;
  }

  static getInstance() {
    if (!EmojiInlineIndexSearch.instance) {
      EmojiInlineIndexSearch.instance = new EmojiInlineIndexSearch(new EmojiInlineLibrary());
    }

    return EmojiInlineIndexSearch.instance;
  }

  transform(emoji) {
    const {
      id,
      name,
      skins
    } = emoji;
    return {
      key: id,
      text: name,
      data: {
        id,
        emoji: skins[0].native,
        name,
        text: name
      }
    };
  }

}

_defineProperty(EmojiInlineIndexSearch, "instance", void 0);

const getEmojiOnSelectItem = ({
  key = KEY_EMOJI
} = {}) => (editor, item) => {
  const {
    options: {
      createEmoji,
      emojiTriggeringController
    }
  } = getPlugin(editor, key);
  withoutNormalizing(editor, () => {
    withoutMergingHistory(editor, () => deleteText(editor, {
      distance: emojiTriggeringController.getTextSize(),
      reverse: true
    }));
    emojiTriggeringController.reset();
    const value = createEmoji(item);
    insertText(editor, value);
  });
  return comboboxActions.reset();
};

const getNextPoint = (editor, endPoint) => getPointBefore(editor, endPoint, {
  unit: 'character',
  distance: 1
});

const getFoundText = (editor, start, end) => getEditorString(editor, getRange(editor, start, end));

const isBreakingCharInText = text => /^\s/.test(text);

const getFindTriggeringInput = (editor, emojiTriggeringController) => (text = '') => {
  const selection = editor.selection;
  const startPoint = editor.selection;
  let currentText = text;
  let endPoint = selection.anchor;
  let nextPoint;
  let repeat = emojiTriggeringController.getOptions().maxTextToSearch;

  do {
    if (!endPoint) break;
    emojiTriggeringController.setText(currentText);
    if (emojiTriggeringController.hasTriggeringMark) break;
    nextPoint = getNextPoint(editor, endPoint);
    const foundText = getFoundText(editor, startPoint, nextPoint);
    endPoint = nextPoint;
    currentText = `${foundText}${text}`;

    if (isBreakingCharInText(foundText)) {
      emojiTriggeringController.reset();
      break;
    }
  } while (--repeat > 0);
};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var lib = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Constants.
 */

// We make this a function so it can be tested in describe block mocks with Jest.
var IS_MAC = () => typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);

var MODIFIERS = {
  alt: 'altKey',
  control: 'ctrlKey',
  meta: 'metaKey',
  shift: 'shiftKey'
};

// We make this a function so it can be tested in describe block mocks with Jest.
var ALIASES = () => ({
  add: '+',
  break: 'pause',
  cmd: 'meta',
  command: 'meta',
  ctl: 'control',
  ctrl: 'control',
  del: 'delete',
  down: 'arrowdown',
  esc: 'escape',
  ins: 'insert',
  left: 'arrowleft',
  mod: IS_MAC() ? 'meta' : 'control',
  opt: 'alt',
  option: 'alt',
  return: 'enter',
  right: 'arrowright',
  space: ' ',
  spacebar: ' ',
  up: 'arrowup',
  win: 'meta',
  windows: 'meta'
});

var CODES = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  ' ': 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ';': 186,
  '=': 187,
  ',': 188,
  '-': 189,
  '.': 190,
  '/': 191,
  '`': 192,
  '[': 219,
  '\\': 220,
  ']': 221,
  '\'': 222
};

for (var f = 1; f < 20; f++) {
  CODES['f' + f] = 111 + f;
}

/**
 * Is hotkey?
 */

function isHotkey(hotkey, options, event) {
  if (options && !('byKey' in options)) {
    event = options;
    options = null;
  }

  if (!Array.isArray(hotkey)) {
    hotkey = [hotkey];
  }

  var array = hotkey.map(function (string) {
    return parseHotkey(string, options);
  });
  var check = function check(e) {
    return array.some(function (object) {
      return compareHotkey(object, e);
    });
  };
  var ret = event == null ? check : check(event);
  return ret;
}

function isCodeHotkey(hotkey, event) {
  return isHotkey(hotkey, event);
}

function isKeyHotkey(hotkey, event) {
  return isHotkey(hotkey, { byKey: true }, event);
}

/**
 * Parse.
 */

function parseHotkey(hotkey, options) {
  var byKey = options && options.byKey;
  var ret = {};

  // Special case to handle the `+` key since we use it as a separator.
  hotkey = hotkey.replace('++', '+add');
  var values = hotkey.split('+');
  var length = values.length;

  // Ensure that all the modifiers are set to false unless the hotkey has them.

  for (var k in MODIFIERS) {
    ret[MODIFIERS[k]] = false;
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var value = _step.value;

      var optional = value.endsWith('?') && value.length > 1;

      if (optional) {
        value = value.slice(0, -1);
      }

      var name = toKeyName(value);
      var modifier = MODIFIERS[name];

      if (length === 1 || !modifier) {
        if (byKey) {
          ret.key = name;
        } else {
          ret.which = toKeyCode(value);
        }
      }

      if (modifier) {
        ret[modifier] = optional ? null : true;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return ret;
}

/**
 * Compare.
 */

function compareHotkey(object, event) {
  for (var key in object) {
    var expected = object[key];
    var actual = void 0;

    if (expected == null) {
      continue;
    }

    if (key === 'key' && event.key != null) {
      actual = event.key.toLowerCase();
    } else if (key === 'which') {
      actual = expected === 91 && event.which === 93 ? 91 : event.which;
    } else {
      actual = event[key];
    }

    if (actual == null && expected === false) {
      continue;
    }

    if (actual !== expected) {
      return false;
    }
  }

  return true;
}

/**
 * Utils.
 */

function toKeyCode(name) {
  name = toKeyName(name);
  var code = CODES[name] || name.toUpperCase().charCodeAt(0);
  return code;
}

function toKeyName(name) {
  name = name.toLowerCase();
  name = ALIASES()[name] || name;
  return name;
}

/**
 * Export.
 */

exports.default = isHotkey;
exports.isHotkey = isHotkey;
exports.isCodeHotkey = isCodeHotkey;
exports.isKeyHotkey = isKeyHotkey;
exports.parseHotkey = parseHotkey;
exports.compareHotkey = compareHotkey;
exports.toKeyCode = toKeyCode;
exports.toKeyName = toKeyName;
});

var isHotkey = unwrapExports(lib);
lib.isHotkey;
lib.isCodeHotkey;
lib.isKeyHotkey;
lib.parseHotkey;
lib.compareHotkey;
lib.toKeyCode;
lib.toKeyName;

/**
 * TODO: move to core
 */

// TODO: move to core
const moveSelectionByOffset = (editor, {
  query = () => true
} = {}) => event => {
  const {
    selection
  } = editor;

  if (!selection || Range.isExpanded(selection) || !query(editor)) {
    return false;
  }

  if (isHotkey('left', event)) {
    event.preventDefault();
    moveSelection(editor, {
      unit: 'offset',
      reverse: true
    });
    return true;
  }

  if (isHotkey('right', event)) {
    event.preventDefault();
    moveSelection(editor, {
      unit: 'offset'
    });
    return true;
  }
}; // ------>


const getOnKeyDownEmoji = options => editor => event => {
  return moveSelectionByOffset(editor, options)(event);
};

const withEmoji = (editor, {
  options: {
    id,
    emojiTriggeringController
  }
}) => {
  const emojiInlineIndexSearch = EmojiInlineIndexSearch.getInstance();
  const findTheTriggeringInput = getFindTriggeringInput(editor, emojiTriggeringController);
  const {
    apply,
    insertText
  } = editor;

  editor.insertText = text => {
    const {
      selection
    } = editor;
    if (!selection || !isCollapsed(selection)) return insertText(text);
    findTheTriggeringInput(text);
    return insertText(text);
  };

  editor.apply = operation => {
    apply(operation);

    if (!(emojiTriggeringController !== null && emojiTriggeringController !== void 0 && emojiTriggeringController.hasTriggeringMark)) {
      return;
    }

    switch (operation.type) {
      case 'set_selection':
        emojiTriggeringController.reset();
        comboboxActions.reset();
        break;

      case 'insert_text':
        if (emojiTriggeringController.isTriggering) {
          const searchText = emojiTriggeringController.getText();
          comboboxActions.items(emojiInlineIndexSearch.search(searchText).get());
          comboboxActions.open({
            activeId: id,
            text: '',
            targetRange: editor.selection
          });
        }

        break;

      case 'remove_text':
        findTheTriggeringInput();

        if (emojiTriggeringController.isTriggering) {
          const searchText = emojiTriggeringController.getText();
          comboboxActions.items(emojiInlineIndexSearch.search(searchText).get());
          comboboxActions.open({
            activeId: id,
            text: '',
            targetRange: editor.selection
          });
          break;
        }

        emojiTriggeringController.reset();
        comboboxActions.reset();
        break;
    }
  };

  return editor;
};

const createEmojiPlugin = createPluginFactory({
  key: KEY_EMOJI,
  // handlers: {
  //   onKeyDown: getOnKeyDownEmoji(),
  // },
  withOverrides: withEmoji,
  options: {
    trigger: EMOJI_TRIGGER,
    createEmoji: item => item.data.emoji,
    emojiTriggeringController: new EmojiTriggeringController(EMOJI_TRIGGER)
  },
  then: (_, {
    key,
    options: {
      trigger,
      createEmoji,
      emojiTriggeringController
    }
  }) => ({
    options: {
      id: key,
      trigger,
      createEmoji,
      emojiTriggeringController
    }
  })
});

class LocalStorage {
  constructor(key, defaultValue) {
    this.key = key;
    this.defaultValue = defaultValue;
  }

  set(value) {
    window.localStorage.setItem(this.key, JSON.stringify(value));
  }

  get() {
    let value = this.defaultValue;
    const valueInLocalStorage = window.localStorage.getItem(this.key);

    if (valueInLocalStorage) {
      try {
        value = JSON.parse(valueInLocalStorage);
      } catch (error) {
        window.localStorage.removeItem(this.key);
      }
    }

    return value;
  }

}

class FrequentEmojiStorage {
  constructor(props, defaultValue = DEFAULT_FREQUENTLY_USED_EMOJI) {
    var _props$limit, _props$prefix, _props$key;

    this.defaultValue = defaultValue;

    _defineProperty(this, "limit", 8);

    _defineProperty(this, "prefix", 'emoji');

    _defineProperty(this, "key", EmojiCategory.Frequent);

    _defineProperty(this, "localStorage", void 0);

    this.limit = (_props$limit = props.limit) !== null && _props$limit !== void 0 ? _props$limit : this.limit;
    const key = `${(_props$prefix = props.prefix) !== null && _props$prefix !== void 0 ? _props$prefix : this.prefix}:${(_props$key = props.key) !== null && _props$key !== void 0 ? _props$key : this.key}`;
    this.localStorage = new LocalStorage(key, defaultValue);
  }

  update(emojiId) {
    const prevEmojis = this.localStorage.get();
    const count = prevEmojis[emojiId] ? prevEmojis[emojiId] + 1 : 1;
    const emojis = { ...prevEmojis,
      [emojiId]: count
    };
    this.localStorage.set(emojis);
    return emojis;
  }

  get() {
    const data = this.localStorage.get();
    return Object.keys(data).sort((a, b) => data[b] - data[a]).reduce((_sortedObj, key) => ({ ..._sortedObj,
      [key]: data[key]
    }), {});
  }

  getList() {
    return Object.keys(this.get()).splice(0, this.limit);
  }

  set(value) {
    this.localStorage.set(value);
  }

}

export { AGridSection, AIndexSearch, DEFAULT_FREQUENTLY_USED_EMOJI, EMOJI_MAX_SEARCH_RESULT, EMOJI_TRIGGER, EMOJI_TRIGGERING_CONTROLLER_OPTIONS, EmojiCategory, EmojiFloatingGrid, EmojiFloatingGridBuilder, EmojiFloatingIndexSearch, EmojiFloatingLibrary, EmojiGridSectionWithRoot, EmojiInlineIndexSearch, EmojiInlineLibrary, EmojiPickerState, EmojiSettings, EmojiTriggeringController, FrequentEmojiStorage, Grid, KEY_EMOJI, LocalStorage, NUM_OF_CATEGORIES, createEmojiPlugin, defaultCategories, getEmojiOnInsert, getEmojiOnSelectItem, getFindTriggeringInput, getOnKeyDownEmoji, i18n, observeCategories, useEmojiPicker, withEmoji };
//# sourceMappingURL=index.es.js.map
