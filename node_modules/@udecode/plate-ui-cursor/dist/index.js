'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _styled = require('styled-components');
var React = require('react');
var plateStyledComponents = require('@udecode/plate-styled-components');
var plateCore = require('@udecode/plate-core');
var slate = require('slate');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _styled__default = /*#__PURE__*/_interopDefaultLegacy(_styled);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

const getCursorOverlayStyles = props => plateStyledComponents.createStyles({
  prefixClassNames: 'CursorOverlay',
  ...props
}, {
  selectionRect: [{
    "position": "absolute",
    "zIndex": "10",
    "pointerEvents": "none"
  }, _styled.css(["opacity:0.3;"])],
  caret: [{
    "position": "absolute",
    "zIndex": "10",
    "pointerEvents": "none"
  }, _styled.css(["width:2px;"])]
});

const Cursor = ({
  data,
  selectionRects,
  caretPosition,
  disableCaret,
  disableSelection,
  onRenderCaret: Caret,
  onRenderSelectionRect: Rect,
  ...props
}) => {
  if (!data) {
    return null;
  }

  const {
    caret,
    selectionRect
  } = getCursorOverlayStyles(props);
  const {
    style,
    selectionStyle = style
  } = data;
  return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, !disableSelection && selectionRects.map((position, i) => Rect ? /*#__PURE__*/React__default["default"].createElement(Rect, {
    key: i,
    data: data,
    selectionRect: position
  }) : /*#__PURE__*/React__default["default"].createElement(_StyledDiv, {
    key: i,
    className: selectionRect === null || selectionRect === void 0 ? void 0 : selectionRect.className,
    style: { ...selectionStyle,
      ...position
    },
    $_css: selectionRect === null || selectionRect === void 0 ? void 0 : selectionRect.css
  })), !disableCaret && caretPosition && (Caret ? /*#__PURE__*/React__default["default"].createElement(Caret, {
    data: data,
    caretPosition: caretPosition
  }) : /*#__PURE__*/React__default["default"].createElement(_StyledDiv2, {
    className: caret === null || caret === void 0 ? void 0 : caret.className,
    style: { ...caretPosition,
      ...style
    },
    $_css2: caret === null || caret === void 0 ? void 0 : caret.css
  })));
};

var _StyledDiv = _styled__default["default"]("div").withConfig({
  displayName: "Cursor___StyledDiv",
  componentId: "sc-7354n0-0"
})(["", ""], p => p.$_css);

var _StyledDiv2 = _styled__default["default"]("div").withConfig({
  displayName: "Cursor___StyledDiv2",
  componentId: "sc-7354n0-1"
})(["", ""], p => p.$_css2);

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

const useRequestReRender = () => {
  const [, setUpdateCounter] = React.useState(0);
  const animationFrameRef = React.useRef(null);
  const requestReRender = React.useCallback((immediate = false) => {
    if (animationFrameRef.current && !immediate) {
      return;
    }

    if (!immediate) {
      animationFrameRef.current = requestAnimationFrame(() => {
        setUpdateCounter(state => state + 1);
        animationFrameRef.current = null;
      });
      return;
    }

    if (animationFrameRef.current) {
      cancelAnimationFrame(animationFrameRef.current);
      animationFrameRef.current = null;
    }

    setUpdateCounter(state => state + 1);
  }, []);
  React.useEffect(() => {
    if (animationFrameRef.current) {
      cancelAnimationFrame(animationFrameRef.current);
      animationFrameRef.current = null;
    }
  });
  React.useEffect(() => () => {
    if (animationFrameRef.current) {
      cancelAnimationFrame(animationFrameRef.current);
    }
  }, []);
  return requestReRender;
};

const useRefreshOnResize = ({
  containerRef,
  refreshOnResize,
  selectionRectCache
}) => {
  const requestReRender = useRequestReRender(); // Reset the selection rect cache and request re-render.

  const refresh = React.useCallback((sync = false) => {
    selectionRectCache.current = new WeakMap();
    requestReRender(sync);
  }, [requestReRender, selectionRectCache]); // Refresh on container resize

  React.useEffect(() => {
    if (!refreshOnResize || !(containerRef !== null && containerRef !== void 0 && containerRef.current)) {
      return;
    }

    const resizeObserver = new ResizeObserver(() => refresh());
    resizeObserver.observe(containerRef.current);
    return () => resizeObserver.disconnect();
  }, [containerRef, refresh, refreshOnResize]);
  return {
    refresh
  };
};

/**
 * Get the caret position of a range from selectionRects.
 */
const getCaretPosition = (selectionRects, range) => {
  const isCollapsed = range && slate.Range.isCollapsed(range);
  const isBackward = range && slate.Range.isBackward(range);
  const anchorRect = selectionRects[isBackward ? 0 : selectionRects.length - 1];

  if (!anchorRect) {
    return null;
  }

  return {
    height: anchorRect.height,
    top: anchorRect.top,
    left: anchorRect.left + (isBackward || isCollapsed ? 0 : anchorRect.width)
  };
};

/**
 * Get cursor overlay state from selection rects.
 */

const getCursorOverlayState = ({
  cursors: cursorStates,
  selectionRects
}) => {
  if (!cursorStates) return [];
  return Object.entries(cursorStates).map(([key, cursorState]) => {
    var _cursorState$selectio, _selectionRects$key;

    const selection = (_cursorState$selectio = cursorState === null || cursorState === void 0 ? void 0 : cursorState.selection) !== null && _cursorState$selectio !== void 0 ? _cursorState$selectio : null;
    const rects = (_selectionRects$key = selectionRects[key]) !== null && _selectionRects$key !== void 0 ? _selectionRects$key : FROZEN_EMPTY_ARRAY;
    const caretPosition = selection ? getCaretPosition(rects, selection) : null;
    return { ...cursorState,
      selection,
      caretPosition,
      selectionRects: rects
    };
  });
};

const getSelectionRects = (editor, {
  range,
  xOffset,
  yOffset
}) => {
  const [start, end] = slate.Range.edges(range);
  const domRange = plateCore.toDOMRange(editor, range);

  if (!domRange) {
    return [];
  }

  const selectionRects = [];
  const textEntries = plateCore.getNodeEntries(editor, {
    at: range,
    match: plateCore.isText
  });

  for (const [textNode, textPath] of textEntries) {
    const domNode = plateCore.toDOMNode(editor, textNode);

    if (!domNode) {
      return [];
    }

    const isStartNode = slate.Path.equals(textPath, start.path);
    const isEndNode = slate.Path.equals(textPath, end.path);
    let clientRects = null;

    if (isStartNode || isEndNode) {
      const nodeRange = document.createRange();
      nodeRange.selectNode(domNode);

      if (isStartNode) {
        nodeRange.setStart(domRange.startContainer, domRange.startOffset);
      }

      if (isEndNode) {
        nodeRange.setEnd(domRange.endContainer, domRange.endOffset);
      }

      clientRects = nodeRange.getClientRects();
    } else {
      clientRects = domNode.getClientRects();
    }

    for (let i = 0; i < clientRects.length; i++) {
      const clientRect = clientRects.item(i);

      if (!clientRect) {
        continue;
      }

      selectionRects.push({
        width: clientRect.width,
        height: clientRect.height,
        top: clientRect.top - yOffset,
        left: clientRect.left - xOffset
      });
    }
  }

  return selectionRects;
};

const FROZEN_EMPTY_ARRAY = Object.freeze([]);
const useCursorOverlayPositions = ({
  containerRef,
  cursors: cursorStates,
  refreshOnResize = true
} = {}) => {
  const editor = plateCore.useEditorRef();
  const selectionRectCache = React.useRef(new WeakMap());
  const [selectionRects, setSelectionRects] = React.useState({});
  const updateSelectionRects = React.useCallback(() => {
    // We have a container ref but the ref is null => container
    // isn't mounted to we can't calculate the selection rects.
    if (!(containerRef !== null && containerRef !== void 0 && containerRef.current)) return;
    if (!cursorStates) return;
    let xOffset = 0;
    let yOffset = 0;

    if (containerRef) {
      const contentRect = containerRef.current.getBoundingClientRect();
      xOffset = contentRect.x;
      yOffset = contentRect.y;
    }

    let selectionRectsChanged = Object.keys(selectionRects).length !== Object.keys(cursorStates).length;

    const getCachedSelectionRects = ({
      cursor
    }) => {
      const range = cursor.selection;

      if (!range) {
        return FROZEN_EMPTY_ARRAY;
      }

      const cached = selectionRectCache.current.get(range);

      if (cached) {
        return cached;
      }

      const rects = getSelectionRects(editor, {
        range,
        xOffset,
        yOffset
      });
      selectionRectsChanged = true;
      selectionRectCache.current.set(range, rects);
      return rects;
    };

    const updated = Object.fromEntries(Object.entries(cursorStates).map(([key, cursor]) => [key, getCachedSelectionRects({
      cursor
    })]));

    if (selectionRectsChanged) {
      setSelectionRects(updated);
    }
  }, [containerRef, cursorStates, editor, selectionRects]); // Update selection rects after paint
  // eslint-disable-next-line react-hooks/exhaustive-deps

  React.useLayoutEffect(() => {
    updateSelectionRects();
  });
  const cursors = React.useMemo(() => getCursorOverlayState({
    selectionRects,
    cursors: cursorStates
  }), [cursorStates, selectionRects]);
  const {
    refresh
  } = useRefreshOnResize({
    containerRef,
    selectionRectCache,
    refreshOnResize
  });
  return {
    refresh,
    cursors
  };
};

const CursorOverlayContent = ({
  as,
  classNames,
  prefixClassNames,
  styles,
  onRenderCursor: CursorComponent = Cursor,
  onRenderSelectionRect,
  onRenderCaret,
  ...props
}) => {
  const {
    disableCaret,
    disableSelection
  } = props;
  const {
    cursors
  } = useCursorOverlayPositions(props);
  const cursorProps = {
    as,
    classNames,
    prefixClassNames,
    styles,
    onRenderSelectionRect,
    onRenderCaret,
    disableCaret,
    disableSelection
  };
  return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, cursors.map(cursor => /*#__PURE__*/React__default["default"].createElement(CursorComponent, _extends({
    key: cursor.key
  }, cursorProps, cursor))));
};
const CursorOverlay = props => {
  const isRendered = plateCore.usePlateSelectors().isRendered();
  if (!isRendered) return null;
  return /*#__PURE__*/React__default["default"].createElement(CursorOverlayContent, props);
};

exports.Cursor = Cursor;
exports.CursorOverlay = CursorOverlay;
exports.CursorOverlayContent = CursorOverlayContent;
exports.FROZEN_EMPTY_ARRAY = FROZEN_EMPTY_ARRAY;
exports.getCaretPosition = getCaretPosition;
exports.getCursorOverlayState = getCursorOverlayState;
exports.getCursorOverlayStyles = getCursorOverlayStyles;
exports.getSelectionRects = getSelectionRects;
exports.useCursorOverlayPositions = useCursorOverlayPositions;
exports.useRefreshOnResize = useRefreshOnResize;
exports.useRequestReRender = useRequestReRender;
//# sourceMappingURL=index.js.map
