{"version":3,"file":"simpleaggregator.js","sources":["../../../src/metrics/simpleaggregator.ts"],"sourcesContent":["import type { Client, ClientOptions, MeasurementUnit, MetricsAggregator, Primitive } from '@sentry/types';\nimport { timestampInSeconds } from '@sentry/utils';\nimport {\n  DEFAULT_FLUSH_INTERVAL,\n  NAME_AND_TAG_KEY_NORMALIZATION_REGEX,\n  TAG_VALUE_NORMALIZATION_REGEX,\n} from './constants';\nimport { METRIC_MAP } from './instance';\nimport type { MetricType, SimpleMetricBucket } from './types';\nimport { getBucketKey } from './utils';\n\n/**\n * A simple metrics aggregator that aggregates metrics in memory and flushes them periodically.\n * Default flush interval is 5 seconds.\n *\n * @experimental This API is experimental and might change in the future.\n */\nexport class SimpleMetricsAggregator implements MetricsAggregator {\n  private _buckets: SimpleMetricBucket;\n  private readonly _interval: ReturnType<typeof setInterval>;\n\n  public constructor(private readonly _client: Client<ClientOptions>) {\n    this._buckets = new Map();\n    this._interval = setInterval(() => this.flush(), DEFAULT_FLUSH_INTERVAL);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public add(\n    metricType: MetricType,\n    unsanitizedName: string,\n    value: number | string,\n    unit: MeasurementUnit = 'none',\n    unsanitizedTags: Record<string, Primitive> = {},\n    maybeFloatTimestamp = timestampInSeconds(),\n  ): void {\n    const timestamp = Math.floor(maybeFloatTimestamp);\n    const name = unsanitizedName.replace(NAME_AND_TAG_KEY_NORMALIZATION_REGEX, '_');\n    const tags = sanitizeTags(unsanitizedTags);\n\n    const bucketKey = getBucketKey(metricType, name, unit, tags);\n    const bucketItem = this._buckets.get(bucketKey);\n    if (bucketItem) {\n      const [bucketMetric, bucketTimestamp] = bucketItem;\n      bucketMetric.add(value);\n      // TODO(abhi): Do we need this check?\n      if (bucketTimestamp < timestamp) {\n        bucketItem[1] = timestamp;\n      }\n    } else {\n      // @ts-expect-error we don't need to narrow down the type of value here, saves bundle size.\n      const newMetric = new METRIC_MAP[metricType](value);\n      this._buckets.set(bucketKey, [newMetric, timestamp, metricType, name, unit, tags]);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public flush(): void {\n    // short circuit if buckets are empty.\n    if (this._buckets.size === 0) {\n      return;\n    }\n    if (this._client.captureAggregateMetrics) {\n      const metricBuckets = Array.from(this._buckets).map(([, bucketItem]) => bucketItem);\n      this._client.captureAggregateMetrics(metricBuckets);\n    }\n    this._buckets.clear();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(): void {\n    clearInterval(this._interval);\n    this.flush();\n  }\n}\n\nfunction sanitizeTags(unsanitizedTags: Record<string, Primitive>): Record<string, string> {\n  const tags: Record<string, string> = {};\n  for (const key in unsanitizedTags) {\n    if (Object.prototype.hasOwnProperty.call(unsanitizedTags, key)) {\n      const sanitizedKey = key.replace(NAME_AND_TAG_KEY_NORMALIZATION_REGEX, '_');\n      tags[sanitizedKey] = String(unsanitizedTags[key]).replace(TAG_VALUE_NORMALIZATION_REGEX, '_');\n    }\n  }\n  return tags;\n}\n"],"names":["DEFAULT_FLUSH_INTERVAL","timestampInSeconds","NAME_AND_TAG_KEY_NORMALIZATION_REGEX","getBucketKey","METRIC_MAP","TAG_VALUE_NORMALIZATION_REGEX"],"mappings":"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"}