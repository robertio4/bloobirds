"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntegrationAccessor = exports.IntegrationsAccessor = void 0;
const tslib_1 = require("tslib");
const _1 = require(".");
const iframe_1 = require("../iframe");
const accessors_1 = require("../accessors");
const url_join_1 = tslib_1.__importDefault(require("url-join"));
class IntegrationsAccessor {
    constructor(client) {
        this.client = client;
    }
    async find(query) {
        return this.client.get('/integrations', query);
    }
}
exports.IntegrationsAccessor = IntegrationsAccessor;
class IntegrationAccessor extends accessors_1.ElementAccessor {
    constructor(client, idOrKey) {
        super({
            client,
            path: 'integrations',
            idOrKey,
        });
        this.client = client;
        this.idOrKey = idOrKey;
    }
    async getConnectorSpec() {
        return this.client.get(`/integrations/${this.idOrKey}/connector-spec`);
    }
    async createConnection({ parameters }) {
        const spec = await this.getConnectorSpec();
        let iframeElement;
        if (spec.connectionMode === _1.ConnectionMode.IFRAME) {
            iframeElement = createIframeElement();
        }
        return new Promise((resolve, reject) => {
            const connectionUrl = (0, url_join_1.default)(this.client.apiUri, `oauth/new/${this.idOrKey}`, `?token=${this.client.token}&connectionParameters=${JSON.stringify(parameters)}`);
            const urlObj = new URL(connectionUrl);
            const requestId = (Math.random() + 1).toString(36).substring(0, 12);
            const listenerFunc = async (event) => {
                const message = event.data || {};
                if (message.source == 'integration.app' &&
                    message.requestId == requestId) {
                    cleanup();
                    if (message.type == 'newConnectionCreated') {
                        resolve(message.connection);
                    }
                    else if (message.type == 'newConnectionCancel') {
                        resolve(null);
                    }
                    else if (message.type == 'newConnectionFailure') {
                        reject(new Error(message.error));
                    }
                }
            };
            let cancelCheckInterval;
            function cleanup() {
                clearInterval(cancelCheckInterval);
                window.removeEventListener('message', listenerFunc);
            }
            try {
                window.addEventListener('message', listenerFunc);
                urlObj.searchParams.append('requestId', requestId);
                if (iframeElement) {
                    urlObj.searchParams.append('iframe', '1');
                    iframeElement.src = urlObj.toString();
                }
                else {
                    const height = Math.round(screen.height * 0.6);
                    const width = Math.round(screen.width * 0.7);
                    const top = Math.round(screen.height * 0.2);
                    const left = Math.round(screen.height * 0.15);
                    const popup = window.open(urlObj.toString(), null, `popup,width=${width},height=${height},left=${left},top=${top}`);
                    setTimeout(() => {
                        if (!popup) {
                            cleanup();
                            reject({
                                message: 'Popup has been blocked',
                            });
                        }
                    }, 1000);
                    cancelCheckInterval = setInterval(() => {
                        if (popup === null || popup === void 0 ? void 0 : popup.closed) {
                            cleanup();
                            resolve(null);
                        }
                    }, 1000);
                }
            }
            catch (e) {
                reject(e);
            }
        });
    }
    async openNewConnection() {
        (0, iframe_1.showIframeLoader)();
        const uri = this.client.getEmbedUri(`/integrations/${this.idOrKey}/connection/connect`);
        return new Promise((resolve) => {
            (0, iframe_1.openIframe)(uri, {
                onClose: () => resolve(null),
                onSuccess: (connection) => resolve(connection),
            });
        });
    }
    async connect() {
        return this.openNewConnection();
    }
}
exports.IntegrationAccessor = IntegrationAccessor;
function createIframeElement() {
    const iframeElement = document.createElement('iframe');
    iframeElement.style.position = 'absolute';
    iframeElement.style.top = '-100';
    iframeElement.style.left = '-100';
    iframeElement.style.width = '1';
    iframeElement.style.height = '1';
    iframeElement.style.border = 'none';
    iframeElement.style.backgroundColor = 'transparent';
    document.body.appendChild(iframeElement);
    return iframeElement;
}
//# sourceMappingURL=accessors.js.map