"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCompoundSchema = exports.extendSchema = exports.mergeSchemas = exports.createSchema = exports.wrapAnyOfSchema = exports.unwrapSchemas = exports.unwrapSchema = void 0;
function createSchemaFor(value) {
    switch (typeof value) {
        case 'number':
            if (Number.isInteger(value)) {
                return { type: 'integer' };
            }
            return { type: 'number' };
        case 'boolean':
            return { type: 'boolean' };
        case 'string':
            return { type: 'string' };
        case 'object':
            if (value === null) {
                return {};
            }
            if (Array.isArray(value)) {
                return createSchemaForArray(value);
            }
            return createSchemaForObject(value);
        default:
            return null;
    }
}
function createSchemaForArray(arr) {
    if (arr.length === 0) {
        return { type: 'array' };
    }
    const elementSchemas = arr.map((value) => createSchemaFor(value));
    const items = combineSchemas(elementSchemas);
    return { type: 'array', items };
}
function createSchemaForObject(obj) {
    const keys = Object.keys(obj);
    if (keys.length === 0) {
        return {
            type: 'object',
        };
    }
    const properties = Object.entries(obj).reduce((props, [key, val]) => {
        props[key] = createSchemaFor(val);
        return props;
    }, {});
    const schema = { type: 'object', properties };
    return schema;
}
function combineSchemas(schemas) {
    const schemasByType = {
        undefined: [],
        ['null']: [],
        ['boolean']: [],
        ['integer']: [],
        ['number']: [],
        ['string']: [],
        ['array']: [],
        ['object']: [],
    };
    const unwrappedSchemas = unwrapSchemas(schemas);
    for (const unwrappedSchema of unwrappedSchemas) {
        const type = unwrappedSchema.type;
        schemasByType[type].push(unwrappedSchema);
    }
    if (schemasByType['number'].length > 0) {
        schemasByType['number'].push(...schemasByType['integer'].map((r) => ({
            ...r,
            type: 'number',
        })));
        delete schemasByType['integer'];
    }
    const resultSchemasByType = {
        ['null']: combineSameTypeScalarSchemas(schemasByType['null']),
        ['boolean']: combineSameTypeScalarSchemas(schemasByType['boolean']),
        ['number']: combineSameTypeScalarSchemas(schemasByType['number']),
        ['integer']: combineSameTypeScalarSchemas(schemasByType['integer']),
        ['string']: combineSameTypeScalarSchemas(schemasByType['string']),
        ['array']: combineArraySchemas(schemasByType['array']),
        ['object']: combineObjectSchemas(schemasByType['object']),
    };
    const schemasFound = Object.values(resultSchemasByType).filter(Boolean);
    const multiType = schemasFound.length > 1;
    if (multiType) {
        const wrapped = wrapAnyOfSchema({ anyOf: schemasFound });
        return wrapped;
    }
    return schemasFound[0];
}
function combineSameTypeScalarSchemas(schemas) {
    if (!schemas || schemas.length === 0) {
        return undefined;
    }
    const schema = {
        type: schemas[0].type,
    };
    addTitleFromSourceSchemas(schema, schemas);
    return schema;
}
function combineArraySchemas(schemas) {
    if (!schemas || schemas.length === 0) {
        return undefined;
    }
    const itemSchemas = [];
    for (const schema of schemas) {
        if (!schema.items)
            continue;
        const unwrappedSchemas = unwrapSchema(schema.items);
        itemSchemas.push(...unwrappedSchemas);
    }
    const schema = {
        type: 'array',
    };
    addTitleFromSourceSchemas(schema, schemas);
    if (itemSchemas.length > 0) {
        schema.items = combineSchemas(itemSchemas);
    }
    return schema;
}
function combineObjectSchemas(schemas) {
    if (!schemas || schemas.length === 0) {
        return undefined;
    }
    const allPropSchemas = schemas.map((s) => s.properties).filter(Boolean);
    const schemasByProp = Object.create(null);
    for (const propSchemas of allPropSchemas) {
        for (const [prop, schema] of Object.entries(propSchemas)) {
            if (!schemasByProp[prop]) {
                schemasByProp[prop] = [];
            }
            const unwrappedSchemas = unwrapSchema(schema);
            schemasByProp[prop].push(...unwrappedSchemas);
        }
    }
    const properties = Object.entries(schemasByProp).reduce((props, [prop, schemas]) => {
        if (schemas.length === 1) {
            props[prop] = schemas[0];
        }
        else {
            props[prop] = combineSchemas(schemas);
        }
        return props;
    }, {});
    const combinedSchema = {
        type: 'object',
    };
    addTitleFromSourceSchemas(combinedSchema, schemas);
    if (Object.keys(properties).length > 0) {
        combinedSchema.properties = properties;
    }
    return combinedSchema;
}
function unwrapSchema(schema) {
    if (!schema)
        return [];
    if (schema.anyOf) {
        return unwrapSchemas(schema.anyOf);
    }
    if (Array.isArray(schema.type)) {
        return schema.type.map((x) => ({ type: x }));
    }
    return [schema];
}
exports.unwrapSchema = unwrapSchema;
function unwrapSchemas(schemas) {
    if (!schemas || schemas.length === 0)
        return [];
    const unwrappedSchemas = schemas.flatMap((schema) => unwrapSchema(schema));
    return unwrappedSchemas;
}
exports.unwrapSchemas = unwrapSchemas;
function wrapAnyOfSchema(schema) {
    const simpleSchemas = [];
    const complexSchemas = [];
    for (const subSchema of schema.anyOf) {
        if (Array.isArray(subSchema.type)) {
            simpleSchemas.push(...subSchema.type);
        }
        else if (isSimpleSchema(subSchema)) {
            simpleSchemas.push(subSchema.type);
        }
        else {
            complexSchemas.push(subSchema);
        }
    }
    if (complexSchemas.length === 0) {
        return { type: simpleSchemas };
    }
    const anyOf = [];
    if (simpleSchemas.length > 0) {
        anyOf.push({
            type: simpleSchemas.length > 1 ? simpleSchemas : simpleSchemas[0],
        });
    }
    anyOf.push(...complexSchemas);
    return { anyOf };
}
exports.wrapAnyOfSchema = wrapAnyOfSchema;
function isSimpleSchema(schema) {
    const keys = Object.keys(schema);
    return keys.length === 1 && keys[0] === 'type';
}
function createSchema(value) {
    if (typeof value === 'undefined')
        value = null;
    const clone = JSON.parse(JSON.stringify(value));
    return createSchemaFor(clone);
}
exports.createSchema = createSchema;
function mergeSchemas(schemas) {
    const mergedSchema = combineSchemas(schemas);
    return mergedSchema;
}
exports.mergeSchemas = mergeSchemas;
function extendSchema(schema, value) {
    const valueSchema = createSchema(value);
    const mergedSchema = combineSchemas([schema, valueSchema]);
    return mergedSchema;
}
exports.extendSchema = extendSchema;
function createCompoundSchema(values) {
    const schemas = values.map((value) => createSchema(value));
    return mergeSchemas(schemas);
}
exports.createCompoundSchema = createCompoundSchema;
function addTitleFromSourceSchemas(schema, schemas) {
    var _a;
    const title = (_a = schemas.filter((s) => !!s.title)[0]) === null || _a === void 0 ? void 0 : _a.title;
    if (title) {
        schema.title = title;
    }
}
//# sourceMappingURL=schema-builder.js.map