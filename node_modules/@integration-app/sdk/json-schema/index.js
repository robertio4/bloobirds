"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.valueToSchema = exports.getDefaultsFromSchema = exports.schemaTypeFromValue = exports.isScalar = exports.schemaDiff = exports.JSONSchemaType = void 0;
var JSONSchemaType;
(function (JSONSchemaType) {
    JSONSchemaType["Null"] = "null";
    JSONSchemaType["Boolean"] = "boolean";
    JSONSchemaType["Integer"] = "integer";
    JSONSchemaType["Number"] = "number";
    JSONSchemaType["String"] = "string";
    JSONSchemaType["Object"] = "object";
    JSONSchemaType["Array"] = "array";
})(JSONSchemaType = exports.JSONSchemaType || (exports.JSONSchemaType = {}));
function schemaDiff(first, second) {
    if (!first) {
        return null;
    }
    else if (first.type == JSONSchemaType.Object && first.properties) {
        if ((second === null || second === void 0 ? void 0 : second.type) == JSONSchemaType.Object && second.properties) {
            const diff = {
                type: JSONSchemaType.Object,
                properties: {},
            };
            Object.keys(first.properties).forEach((key) => {
                const keyDiff = schemaDiff(first.properties[key], second.properties[key]);
                if (keyDiff) {
                    diff.properties[key] = keyDiff;
                }
            });
            return Object.keys(diff.properties).length > 0 ? diff : null;
        }
        else {
            return first;
        }
    }
    else if (first.type == JSONSchemaType.Array && first.items) {
        if ((second === null || second === void 0 ? void 0 : second.type) == JSONSchemaType.Array && second.items) {
            const itemsDiff = schemaDiff(first.items, second.items);
            if (itemsDiff) {
                return {
                    type: JSONSchemaType.Array,
                    items: itemsDiff,
                };
            }
            else {
                return null;
            }
        }
        else {
            return first;
        }
    }
    else {
        if (second) {
            return null;
        }
        else {
            return first;
        }
    }
}
exports.schemaDiff = schemaDiff;
function isScalar(schema) {
    return (schema.type != 'array' && schema.type != 'object' && schema.type != 'null');
}
exports.isScalar = isScalar;
function schemaTypeFromValue(value) {
    switch (typeof value) {
        case 'object':
            if (Array.isArray(value)) {
                return 'array';
            }
            else if (value === null) {
                return 'null';
            }
            else {
                return 'object';
            }
        case 'boolean':
            return 'boolean';
        case 'bigint':
        case 'number':
            return 'number';
        default:
            return 'string';
    }
}
exports.schemaTypeFromValue = schemaTypeFromValue;
function getDefaultsFromSchema(schema) {
    if ((schema === null || schema === void 0 ? void 0 : schema.type) === 'object' && schema.properties) {
        const propDefaults = {};
        for (const [key, value] of Object.entries(schema.properties)) {
            const defaults = getDefaultsFromSchema(value);
            if (defaults !== null && defaults !== undefined) {
                propDefaults[key] = defaults;
            }
        }
        if (Object.keys(propDefaults).length > 0) {
            return propDefaults;
        }
        else {
            return undefined;
        }
    }
    else {
        return schema === null || schema === void 0 ? void 0 : schema.default;
    }
}
exports.getDefaultsFromSchema = getDefaultsFromSchema;
function valueToSchema(value, schema, field = '') {
    var _a;
    function throwError(message) {
        throw new Error(`${message}${field ? ` for field ${field}` : ''}`);
    }
    if (value === null || value === undefined) {
        return undefined;
    }
    switch (schema === null || schema === void 0 ? void 0 : schema.type) {
        case 'string':
            return value === null || value === void 0 ? void 0 : value.toString();
        case 'integer':
        case 'number':
            const result = Number(value);
            if (isNaN(result)) {
                throwError(`Cannot convert "${value}" to number`);
            }
            if (schema.type === 'integer' && !Number.isInteger(result)) {
                throwError(`Expected integer but got ${value}`);
            }
            return result;
        case 'boolean':
            if (typeof value === 'boolean') {
                return value;
            }
            else if (typeof value === 'string') {
                if (value === 'true') {
                    return true;
                }
                else if (value === 'false') {
                    return false;
                }
                else {
                    throwError(`Expected true or false but got "${value}"`);
                }
            }
            else if (value) {
                throwError(`Expected true or false but got "${value}"`);
            }
            return undefined;
        case 'list':
            if (Array.isArray(value)) {
                return value.map((item) => valueToSchema(item, schema.items, field));
            }
            else {
                return undefined;
            }
        case 'object':
            if (typeof value === 'object' && value) {
                const result = {};
                for (const [key, fieldValue] of Object.entries(value)) {
                    const fieldSchema = (_a = schema === null || schema === void 0 ? void 0 : schema.properties) === null || _a === void 0 ? void 0 : _a[key];
                    if (!fieldSchema && schema && !schema.additionalProperties) {
                        continue;
                    }
                    result[key] = valueToSchema(fieldValue, fieldSchema, field ? `${field}.${key}` : key);
                }
                return result;
            }
            else {
                return undefined;
            }
        default:
            return value;
    }
}
exports.valueToSchema = valueToSchema;
//# sourceMappingURL=index.js.map