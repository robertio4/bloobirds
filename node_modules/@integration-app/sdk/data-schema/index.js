"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.populateSchemaTitles = exports.addDefaultsToSchema = exports.addRequiredFieldsToSchema = exports.excludeFieldsFromSchema = exports.pickFieldsFromSchema = exports.schemaWithTitle = exports.schemaIsNumber = exports.schemaAllowsCustomValue = exports.schemaHasFixedValues = exports.schemaIsScalar = void 0;
const tslib_1 = require("tslib");
const locators_1 = require("../data-builder/locators");
const structured_clone_1 = tslib_1.__importDefault(require("@ungap/structured-clone"));
function schemaIsScalar(schema) {
    return (schema.type != 'array' && schema.type != 'object' && schema.type != 'null');
}
exports.schemaIsScalar = schemaIsScalar;
function schemaHasFixedValues(schema) {
    if (!schema) {
        return false;
    }
    return (schema.enum ||
        schema.referenceCollectionUri ||
        schema.referenceCollectionPath ||
        schema.referenceRecords ||
        schema.referenceUdm ||
        schema.type === 'boolean');
}
exports.schemaHasFixedValues = schemaHasFixedValues;
function schemaAllowsCustomValue(schema) {
    return !schemaHasFixedValues(schema) || schema.allowCustom;
}
exports.schemaAllowsCustomValue = schemaAllowsCustomValue;
function schemaIsNumber(schema) {
    return schema && (schema.type === 'number' || schema.type === 'integer');
}
exports.schemaIsNumber = schemaIsNumber;
function schemaWithTitle(schema, title) {
    return typeof schema === 'object'
        ? {
            ...schema,
            title,
        }
        : schema;
}
exports.schemaWithTitle = schemaWithTitle;
function pickFieldsFromSchema(schema, fields) {
    const result = {
        type: 'object',
        properties: {},
    };
    if ((schema === null || schema === void 0 ? void 0 : schema.type) === 'object' && (schema === null || schema === void 0 ? void 0 : schema.properties)) {
        for (const field of fields) {
            (0, locators_1.setSchemaAtLocator)(result, field, (0, locators_1.getSchemaByLocator)(schema, field));
        }
    }
    return result;
}
exports.pickFieldsFromSchema = pickFieldsFromSchema;
function excludeFieldsFromSchema(schema, fields) {
    let result = JSON.parse(JSON.stringify(schema));
    for (const field of fields !== null && fields !== void 0 ? fields : []) {
        result = (0, locators_1.setSchemaAtLocator)(result, field, undefined);
    }
    return result;
}
exports.excludeFieldsFromSchema = excludeFieldsFromSchema;
function addRequiredFieldsToSchema(schema, fields) {
    if (!schema) {
        return undefined;
    }
    if (!Array.isArray(fields)) {
        return schema;
    }
    const newSchema = JSON.parse(JSON.stringify(schema));
    for (const field of fields) {
        const steps = (0, locators_1.locatorToSteps)(field);
        const lastStep = steps.pop();
        if (lastStep.type === locators_1.DataLocatorStepType.OBJECT_PROPERTY) {
            const objectLocator = (0, locators_1.stepsToLocator)(steps);
            const objectSchema = (0, locators_1.getSchemaByLocator)(newSchema, objectLocator);
            if (objectSchema) {
                objectSchema.required = [
                    ...(objectSchema.required || []),
                    lastStep.propertyName,
                ];
                (0, locators_1.setSchemaAtLocator)(newSchema, objectLocator, objectSchema);
            }
        }
    }
    return newSchema;
}
exports.addRequiredFieldsToSchema = addRequiredFieldsToSchema;
function addDefaultsToSchema(sourceSchema, defaultValue) {
    var _a;
    const schema = (0, structured_clone_1.default)(sourceSchema);
    const fields = (0, locators_1.getLocatorsFromSchema)(schema);
    for (const field of fields) {
        const fieldDefaultValue = (0, locators_1.getValueAtLocator)(defaultValue, field);
        if (fieldDefaultValue) {
            const fieldSchema = (0, locators_1.getSchemaByLocator)(schema, field);
            fieldSchema.default = (_a = fieldSchema.default) !== null && _a !== void 0 ? _a : fieldDefaultValue;
            (0, locators_1.setSchemaAtLocator)(schema, field, fieldSchema);
        }
    }
    return schema;
}
exports.addDefaultsToSchema = addDefaultsToSchema;
function populateSchemaTitles(schema) {
    if (!schema || typeof schema !== 'object') {
        return schema;
    }
    const fields = (0, locators_1.getLocatorsFromSchema)(schema);
    for (const field of fields) {
        const fieldSchema = (0, locators_1.getSchemaByLocator)(schema, field);
        if (!(fieldSchema === null || fieldSchema === void 0 ? void 0 : fieldSchema.title)) {
            fieldSchema.title = (0, locators_1.getNameForLocator)(schema, field);
            (0, locators_1.setSchemaAtLocator)(schema, field, fieldSchema);
        }
    }
    return schema;
}
exports.populateSchemaTitles = populateSchemaTitles;
//# sourceMappingURL=index.js.map