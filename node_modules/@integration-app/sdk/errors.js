"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildUserFriendlyErrorMessage = exports.extractIntegrationAppErrorData = exports.getErrorFromData = exports.AccessDeniedError = exports.NotAuthenticatedError = exports.NotFoundError = exports.ConnectionError = exports.FlowRunError = exports.FlowConfigurationError = exports.BadRequestError = exports.InternalError = exports.IntegrationAppError = exports.ErrorData = exports.isIntegrationAppError = exports.ConnectionErrorKey = exports.BadRequestErrorKey = exports.ErrorType = void 0;
var ErrorType;
(function (ErrorType) {
    ErrorType["BAD_REQUEST"] = "Bad Request";
    ErrorType["CONNECTION"] = "Connection";
    ErrorType["FLOW_CONFIGURATION"] = "Flow Configuration";
    ErrorType["FLOW_RUN"] = "Flow Run";
    ErrorType["INTERNAL"] = "Internal";
})(ErrorType = exports.ErrorType || (exports.ErrorType = {}));
var BadRequestErrorKey;
(function (BadRequestErrorKey) {
    BadRequestErrorKey["NOT_FOUND"] = "not_found";
    BadRequestErrorKey["NOT_AUTHENTICATED"] = "not_authenticated";
    BadRequestErrorKey["ACCESS_DENIED"] = "access_denied";
    BadRequestErrorKey["ALREADY_EXISTS"] = "already_exists";
})(BadRequestErrorKey = exports.BadRequestErrorKey || (exports.BadRequestErrorKey = {}));
var ConnectionErrorKey;
(function (ConnectionErrorKey) {
    ConnectionErrorKey["CONNECTION_IS_DEFUNCT"] = "connection_is_defunct";
    ConnectionErrorKey["ACCESS_TOKEN_EXPIRED"] = "access_token_expired";
})(ConnectionErrorKey = exports.ConnectionErrorKey || (exports.ConnectionErrorKey = {}));
function isIntegrationAppError(error) {
    return error && error.isIntegrationAppError;
}
exports.isIntegrationAppError = isIntegrationAppError;
class ErrorData {
    constructor(arg) {
        if (arg instanceof Error) {
            this.message = arg.message;
            this.stack = arg.stack;
            this.type = ErrorType.INTERNAL;
        }
        else if (typeof arg === 'string') {
            this.message = arg;
            this.type = ErrorType.INTERNAL;
        }
        else if (typeof arg === 'object' && arg !== null) {
            Object.assign(this, arg);
        }
        else {
            throw new Error('Invalid argument when creating BaseErrorData: ' + JSON.stringify(arg));
        }
    }
}
exports.ErrorData = ErrorData;
class IntegrationAppError extends Error {
    constructor(arg) {
        const errorData = new ErrorData(arg);
        super(errorData.message);
        this.isIntegrationAppError = true;
        this.data = errorData;
        if (!this.data.type) {
            this.data.type = ErrorType.INTERNAL;
        }
        if (typeof window !== 'undefined') {
            this.message = buildUserFriendlyErrorMessage('Integration.app SDK Error', this.data);
        }
    }
}
exports.IntegrationAppError = IntegrationAppError;
class InternalError extends IntegrationAppError {
    constructor(arg) {
        super(arg);
        this.data.type = ErrorType.INTERNAL;
    }
}
exports.InternalError = InternalError;
class BadRequestError extends IntegrationAppError {
    constructor(arg) {
        super(arg);
        this.data.type = ErrorType.BAD_REQUEST;
    }
}
exports.BadRequestError = BadRequestError;
class FlowConfigurationError extends BadRequestError {
    constructor(arg) {
        super(arg);
        this.data.type = ErrorType.FLOW_CONFIGURATION;
    }
}
exports.FlowConfigurationError = FlowConfigurationError;
class FlowRunError extends IntegrationAppError {
    constructor(arg) {
        super(arg);
        this.data.type = ErrorType.FLOW_RUN;
    }
}
exports.FlowRunError = FlowRunError;
class ConnectionError extends IntegrationAppError {
    constructor(arg) {
        super(arg);
        this.data.type = ErrorType.CONNECTION;
    }
}
exports.ConnectionError = ConnectionError;
class NotFoundError extends BadRequestError {
    constructor(arg) {
        super(arg);
        this.data.key = BadRequestErrorKey.NOT_FOUND;
    }
}
exports.NotFoundError = NotFoundError;
class NotAuthenticatedError extends BadRequestError {
    constructor(arg) {
        super(arg);
        this.data.key = BadRequestErrorKey.NOT_AUTHENTICATED;
    }
}
exports.NotAuthenticatedError = NotAuthenticatedError;
class AccessDeniedError extends BadRequestError {
    constructor(arg) {
        super(arg);
        this.data.key = BadRequestErrorKey.ACCESS_DENIED;
    }
}
exports.AccessDeniedError = AccessDeniedError;
function getErrorFromData(data) {
    if (typeof data === 'object' &&
        data !== null &&
        Object.values(ErrorType).includes(data.type)) {
        return new IntegrationAppError(data);
    }
    return null;
}
exports.getErrorFromData = getErrorFromData;
function extractIntegrationAppErrorData(error) {
    const data = error.isIntegrationAppError
        ? error.data
        : new ErrorData({
            message: error.message,
            type: ErrorType.INTERNAL,
        });
    if (!data.message) {
        data.message = error.message;
    }
    if (!data.stack) {
        data.stack = error.stack;
    }
    return data;
}
exports.extractIntegrationAppErrorData = extractIntegrationAppErrorData;
function buildUserFriendlyErrorMessage(prefix, { type, message, docsLink }) {
    return `${prefix}. \n Type: ${type} \n Message: "${message}" \n Docs: ${docsLink}`;
}
exports.buildUserFriendlyErrorMessage = buildUserFriendlyErrorMessage;
//# sourceMappingURL=errors.js.map