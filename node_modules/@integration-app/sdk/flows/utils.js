"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOrderedNodeKeys = exports.getUpstreamNodeKeys = exports.getParentNodeKeys = exports.getDownstreamNodeKeys = exports.getChildNodeKeys = exports.getRootNodeKeys = exports.getFlowNodeSpec = exports.getFlowNode = void 0;
const nodes_1 = require("./nodes");
function getFlowNode(flow, nodeKey) {
    var _a;
    return (_a = flow.nodes) === null || _a === void 0 ? void 0 : _a[nodeKey];
}
exports.getFlowNode = getFlowNode;
function getFlowNodeSpec(node) {
    if (!node) {
        throw new Error(`getFlowNodeSpec called without a node`);
    }
    const spec = nodes_1.FLOW_NODE_SPECS[node.type];
    if (!spec) {
        throw new Error(`Unknow flow node type: ${node.type}`);
    }
    return spec;
}
exports.getFlowNodeSpec = getFlowNodeSpec;
function getRootNodeKeys(flow) {
    var _a, _b;
    const allNodeKeys = Object.keys((_a = flow.nodes) !== null && _a !== void 0 ? _a : {});
    const allLinkKeys = Object.values((_b = flow.nodes) !== null && _b !== void 0 ? _b : {})
        .flatMap((n) => { var _a, _b; return (_b = (_a = n.links) === null || _a === void 0 ? void 0 : _a.map((l) => l.key)) !== null && _b !== void 0 ? _b : []; })
        .filter(Boolean);
    return allNodeKeys.filter((k) => !allLinkKeys.includes(k));
}
exports.getRootNodeKeys = getRootNodeKeys;
function getChildNodeKeys(flow, nodeKey) {
    const node = getFlowNode(flow, nodeKey);
    const nodeLinks = (node === null || node === void 0 ? void 0 : node.links) || [];
    return nodeLinks
        .map((nodeLink) => nodeLink.key)
        .filter(Boolean)
        .filter((k) => { var _a; return !!((_a = flow.nodes) === null || _a === void 0 ? void 0 : _a[k]); });
}
exports.getChildNodeKeys = getChildNodeKeys;
function getDownstreamNodeKeys(flow, nodeKey) {
    const linkedKeys = getChildNodeKeys(flow, nodeKey);
    return linkedKeys.concat(linkedKeys.map((k) => getChildNodeKeys(flow, k)).flat());
}
exports.getDownstreamNodeKeys = getDownstreamNodeKeys;
function getParentNodeKeys(flow, nodeKey) {
    return Object.keys(flow.nodes || {}).filter((key) => {
        var _a;
        const node = getFlowNode(flow, key);
        return (_a = node === null || node === void 0 ? void 0 : node.links) === null || _a === void 0 ? void 0 : _a.some((link) => link.key === nodeKey);
    });
}
exports.getParentNodeKeys = getParentNodeKeys;
function getUpstreamNodeKeys(flow, nodeKey) {
    const parentKeys = getParentNodeKeys(flow, nodeKey);
    return parentKeys.concat(parentKeys.map((n) => getUpstreamNodeKeys(flow, n)).flat());
}
exports.getUpstreamNodeKeys = getUpstreamNodeKeys;
function getOrderedNodeKeys(flow) {
    const rootNodeKeys = getRootNodeKeys(flow);
    const orderedNodeKeys = rootNodeKeys;
    let hasMore = true;
    while (hasMore) {
        hasMore = false;
        for (const nodeKey of orderedNodeKeys) {
            for (const childNodeKey of getChildNodeKeys(flow, nodeKey)) {
                if (!orderedNodeKeys.includes(childNodeKey)) {
                    orderedNodeKeys.push(childNodeKey);
                    hasMore = true;
                }
            }
        }
    }
    return orderedNodeKeys;
}
exports.getOrderedNodeKeys = getOrderedNodeKeys;
//# sourceMappingURL=utils.js.map