"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlowInstanceAccessor = exports.FlowInstancesAccessor = exports.FlowAccessor = exports.FlowsAccessor = void 0;
const tslib_1 = require("tslib");
const flow_runs_1 = require("../flow-runs");
const iframe_1 = require("../iframe");
const _1 = require(".");
const query_string_1 = tslib_1.__importDefault(require("query-string"));
const accessors_1 = require("../accessors");
const MAX_POLLING_ERRORS = 10;
class FlowsAccessor extends accessors_1.ElementListAccessor {
    constructor(client) {
        super(client, 'flows');
    }
}
exports.FlowsAccessor = FlowsAccessor;
class FlowAccessor extends accessors_1.ElementAccessor {
    constructor(client, idOrKey) {
        super({
            client: client,
            path: 'flows',
            idOrKey,
        });
        this.client = client;
    }
    async runAll(params) {
        const flow = await this.get();
        const instancesPage = await this.client.flowInstances.find({
            flowId: flow.id,
            enabled: true,
        });
        const accessors = instancesPage.items.map((instance) => new FlowInstanceAccessor(this.client, instance.id));
        return await Promise.all(accessors.map((accessor) => accessor.run(params)));
    }
    async subscribe(options) {
        const flow = await this.get();
        const channelKey = `${_1.FLOW_CHANNEL_PREFIX}${flow.id}`;
        await this.client.subscribeToChannel(channelKey, options);
    }
    async unsubscribe() {
        const flow = await this.get();
        const channelKey = `${_1.FLOW_INSTANCE_CHANNEL_PREFIX}${flow.id}`;
        await this.client.unsubscribeFromChannel(channelKey);
    }
}
exports.FlowAccessor = FlowAccessor;
class FlowInstancesAccessor extends accessors_1.ElementInstanceListAccessor {
    constructor(client) {
        super(client, 'flow-instances');
    }
}
exports.FlowInstancesAccessor = FlowInstancesAccessor;
class FlowInstanceAccessor extends accessors_1.ElementInstanceAccessor {
    constructor(client, selector) {
        super({
            client,
            selector,
            instancePath: 'flow-instance',
        });
        this.client = client;
        this.selector = selector;
    }
    async enable() {
        return this.patch({ enabled: true });
    }
    async disable() {
        return this.patch({ enabled: false });
    }
    async updateToLatestFlow() {
        const id = await this.getId();
        return this.client.post(`/flow-instances/${id}/update-to-latest-flow`);
    }
    async setup() {
        const id = await this.getId();
        return this.client.post(`/flow-instances/${id}/setup`);
    }
    async reset() {
        const id = await this.getId();
        return this.client.post(`/flow-instances/${id}/reset`);
    }
    async openConfiguration(options = {}) {
        (0, iframe_1.showIframeLoader)();
        const id = await this.getId();
        const queryParams = {
            nodeKey: options.nodeKey,
        };
        const uri = this.client.getEmbedUri(`/flow-instances/${id}/configuration?${query_string_1.default.stringify(queryParams)}`);
        return (0, iframe_1.openIframe)(uri, {
            onClose: options.onClose,
        });
    }
    async run(options = {}) {
        function onUpdate(flowRun) {
            options.onUpdate && options.onUpdate(flowRun);
        }
        const id = await this.getId();
        const flowRun = await this.client.flowRuns.create({
            flowInstanceId: id,
            nodeKey: options.nodeKey,
            input: options.input,
        });
        onUpdate(flowRun);
        const pusher = await this.client.getPusherInstance();
        const pusherChannelName = `${flow_runs_1.FLOW_RUN_CHANNEL_PREFIX}${flowRun.id}`;
        const pusherEventNameFlowRun = 'flow-run-update';
        let pusherChannel;
        let checkFlowRunInterval;
        function cleanup() {
            checkFlowRunInterval && clearInterval(checkFlowRunInterval);
            pusherChannel && pusherChannel.unbind(pusherEventNameFlowRun);
            pusher && pusher.unsubscribe(pusherChannelName);
        }
        return new Promise((resolve, reject) => {
            const handleFlowRunUpdate = async (flowRun) => {
                var _a, _b;
                onUpdate(flowRun);
                if (flowRun.state === flow_runs_1.FlowRunState.COMPLETED) {
                    cleanup();
                    resolve(flowRun);
                }
                else if (flowRun.state === flow_runs_1.FlowRunState.FAILED) {
                    cleanup();
                    reject(new Error(`Flow run ${flowRun.id} failed: ${(_b = (_a = flowRun.errors) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.message}`));
                }
            };
            const fetchFlowRun = async () => {
                handleFlowRunUpdate(await this.client.flowRun(flowRun.id).get());
            };
            let pollingFlowRun = false;
            let errors = 0;
            checkFlowRunInterval = setInterval(async () => {
                if (!pollingFlowRun) {
                    pollingFlowRun = true;
                    try {
                        await fetchFlowRun();
                        errors = 0;
                    }
                    finally {
                        errors += 1;
                        if (errors > MAX_POLLING_ERRORS) {
                            cleanup();
                            reject(new Error(`Got ${errors} errors while polling flow run ${flowRun.id} state - aborting`));
                        }
                        pollingFlowRun = false;
                    }
                }
            }, 1000);
            if (pusher) {
                pusherChannel = pusher.subscribe(pusherChannelName);
                pusherChannel.bind(pusherEventNameFlowRun, fetchFlowRun);
            }
        });
    }
    async subscribe(options) {
        const id = await this.getId();
        const channelKey = `${_1.FLOW_INSTANCE_CHANNEL_PREFIX}${id}`;
        await this.client.subscribeToChannel(channelKey, options);
    }
    async unsubscribe() {
        const id = await this.getId();
        const channelKey = `${_1.FLOW_INSTANCE_CHANNEL_PREFIX}${id}`;
        await this.client.unsubscribeFromChannel(channelKey);
    }
}
exports.FlowInstanceAccessor = FlowInstanceAccessor;
//# sourceMappingURL=accessors.js.map