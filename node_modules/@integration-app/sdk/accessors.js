"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ElementInstanceAccessor = exports.ElementInstanceListAccessor = exports.ElementListAccessor = exports.ElementAccessor = void 0;
const tslib_1 = require("tslib");
const query_string_1 = tslib_1.__importDefault(require("query-string"));
class ElementAccessor {
    constructor(options) {
        this.options = options;
    }
    async get() {
        return this.options.client.get(`${this.options.path}/${this.options.idOrKey}`);
    }
    async create(data) {
        return this.options.client.put(this.options.path, data);
    }
    async put(data) {
        return this.options.client.put(`${this.options.path}/${this.options.idOrKey}`, data);
    }
    async patch(data) {
        return this.options.client.patch(`${this.options.path}/${this.options.idOrKey}`, data);
    }
    async archive() {
        await this.options.client.delete(`${this.options.path}/${this.options.idOrKey}`);
    }
}
exports.ElementAccessor = ElementAccessor;
class ElementListAccessor {
    constructor(client, path) {
        this.client = client;
        this.path = path;
    }
    async find(query) {
        return this.client.get(this.path, query);
    }
    async create(data) {
        return this.client.post(this.path, data);
    }
}
exports.ElementListAccessor = ElementListAccessor;
class ElementInstanceListAccessor {
    constructor(client, path) {
        this.client = client;
        this.path = path;
    }
    async find(query) {
        return this.client.get(this.path, query);
    }
}
exports.ElementInstanceListAccessor = ElementInstanceListAccessor;
class ElementInstanceAccessor {
    constructor(options) {
        this.options = options;
    }
    async get() {
        return this.options.client.get(this.getPath());
    }
    async getId() {
        if (!this.id) {
            if (this.options.selector && typeof this.options.selector === 'string') {
                this.id = this.options.selector;
            }
            else {
                const element = await this.get();
                if (!element) {
                    throw new Error(`Element not found using selector ${JSON.stringify(this.options.selector)}`);
                }
                this.id = element.id;
            }
        }
        return this.id;
    }
    async create(data) {
        if (this.id) {
            throw new Error('Cannot create: element already exists');
        }
        const element = await this.options.client.post(this.getPath(), data);
        this.id = element.id;
        return element;
    }
    async put(data) {
        return this.options.client.put(this.getPath(), data);
    }
    async patch(data) {
        return this.options.client.patch(this.getPath(), data);
    }
    async archive() {
        return this.options.client.delete(this.getPath());
    }
    async delete() {
        return this.options.client.delete(this.getPath());
    }
    getPath(operation = '') {
        return (this.options.instancePath +
            (operation ? `/${operation}` : '') +
            '?' +
            query_string_1.default.stringify(this.getSelector()));
    }
    getSelector() {
        return typeof this.options.selector === 'string'
            ? {
                id: this.options.selector,
            }
            : this.options.selector;
    }
}
exports.ElementInstanceAccessor = ElementInstanceAccessor;
//# sourceMappingURL=accessors.js.map