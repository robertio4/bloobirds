"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFilterFieldValuesByLocator = exports.getOperatorsBySchema = exports.DataFilterCondition = exports.doesMatchFilter = void 0;
const locators_1 = require("../data-builder/locators");
const operators_1 = require("./operators");
function doesMatchFilter(data, filter) {
    if (filter && Array.isArray(filter)) {
        for (const condition of filter) {
            const operator = operators_1.OPERATORS[condition.operator];
            if (!operator) {
                continue;
            }
            let fieldValues = getFilterFieldValuesByLocator(data, condition.field);
            if (!(fieldValues === null || fieldValues === void 0 ? void 0 : fieldValues.length)) {
                fieldValues = [undefined];
            }
            const conditionMatches = fieldValues.some((fieldValue) => operator.handler(fieldValue, condition.value));
            if (!conditionMatches) {
                return false;
            }
        }
        return true;
    }
    else {
        return true;
    }
}
exports.doesMatchFilter = doesMatchFilter;
class DataFilterCondition {
    constructor(field, operator, value) {
        this.field = field;
        this.operator = operator;
        this.value = value;
    }
}
exports.DataFilterCondition = DataFilterCondition;
function getOperatorsBySchema(schema) {
    if (!schema || typeof schema !== 'object') {
        return [];
    }
    const results = [];
    for (const [type, operator] of Object.entries(operators_1.OPERATORS)) {
        if (operator.applicableToSchema(schema)) {
            results.push({
                type,
                name: operator.name,
                operandSchema: operator.getOperandSchema(schema),
            });
        }
    }
    return results;
}
exports.getOperatorsBySchema = getOperatorsBySchema;
function getFilterFieldValuesByLocator(data, locator) {
    const locatorSteps = (0, locators_1.locatorToSteps)(locator);
    const result = [];
    let curValue = data;
    for (let idx = 0; idx < locatorSteps.length; ++idx) {
        if (curValue === null || curValue === undefined) {
            return [];
        }
        const locatorStep = locatorSteps[idx];
        switch (locatorStep.type) {
            case locators_1.DataLocatorStepType.CURRENT_ARRAY_ITEM:
                if (Array.isArray(curValue)) {
                    for (const val of curValue) {
                        result.push(...getFilterFieldValuesByLocator(val, locatorSteps.slice(idx + 1)));
                    }
                    return result;
                }
                else {
                    return [];
                }
            case locators_1.DataLocatorStepType.ARRAY_ITEM:
                if (Array.isArray(curValue)) {
                    curValue = curValue[locatorStep.index];
                    break;
                }
                else {
                    return [];
                }
            case locators_1.DataLocatorStepType.OBJECT_PROPERTY:
                if (Array.isArray(curValue)) {
                    for (const val of curValue) {
                        result.push(...getFilterFieldValuesByLocator(val, locatorSteps.slice(idx)));
                    }
                    return result;
                }
                else {
                    curValue =
                        curValue[locatorStep.propertyName];
                    break;
                }
        }
    }
    if (curValue !== null && curValue !== undefined) {
        result.push(curValue);
    }
    return result;
}
exports.getFilterFieldValuesByLocator = getFilterFieldValuesByLocator;
//# sourceMappingURL=index.js.map