"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OPERATORS = exports.DEFAULT_CONDITION_TYPE_KEY = void 0;
const data_schema_1 = require("../data-schema");
exports.DEFAULT_CONDITION_TYPE_KEY = 'equals';
exports.OPERATORS = {
    is: {
        name: 'is',
        handler: (value, operand) => value == operand,
        applicableToSchema: (schema) => (0, data_schema_1.schemaIsScalar)(schema) && schema.type !== 'boolean',
        getOperandSchema: (schema) => schema,
    },
    is_not: {
        name: 'is not',
        handler: (value, operand) => value != operand,
        applicableToSchema: (schema) => (0, data_schema_1.schemaIsScalar)(schema) && schema.type !== 'boolean',
        getOperandSchema: (schema) => schema,
    },
    is_one_of: {
        name: 'is one of',
        handler: (value, operand) => Array.isArray(operand) && operand.includes(value),
        applicableToSchema: (schema) => (0, data_schema_1.schemaIsScalar)(schema) && schema.type !== 'boolean',
        getOperandSchema: (schema) => ({ type: 'array', items: schema }),
    },
    is_not_one_of: {
        name: 'is not one of',
        handler: (value, operand) => !Array.isArray(operand) || !operand.includes(value),
        applicableToSchema: (schema) => (0, data_schema_1.schemaIsScalar)(schema) && schema.type !== 'boolean',
        getOperandSchema: (schema) => ({ type: 'array', items: schema }),
    },
    is_true: {
        name: 'is true',
        handler: (value) => !!value,
        applicableToSchema: (schema) => schema.type === 'boolean',
        getOperandSchema: () => null,
    },
    is_false: {
        name: 'is false',
        handler: (value) => value === false,
        applicableToSchema: (schema) => schema.type === 'boolean',
        getOperandSchema: () => null,
    },
    contains: {
        name: 'contains',
        handler: (value, operand) => value ? value.toString().includes(operand) : false,
        applicableToSchema: (schema) => (schema === null || schema === void 0 ? void 0 : schema.type) === 'string' && (0, data_schema_1.schemaAllowsCustomValue)(schema),
        getOperandSchema: () => ({ type: 'string' }),
    },
    does_not_contain: {
        name: 'does not contain',
        handler: (value, operand) => value ? !value.toString().includes(operand) : false,
        applicableToSchema: (schema) => (schema === null || schema === void 0 ? void 0 : schema.type) === 'string' && (0, data_schema_1.schemaAllowsCustomValue)(schema),
        getOperandSchema: () => ({ type: 'string' }),
    },
    array_includes: {
        name: 'includes',
        handler: (value, operand) => Array.isArray(value) && value.indexOf(operand) !== -1,
        applicableToSchema: (schema) => (schema === null || schema === void 0 ? void 0 : schema.type) === 'array' && schema.items,
        getOperandSchema: (schema) => schema.items,
    },
    array_does_not_include: {
        name: 'does not include',
        handler: (value, operand) => !Array.isArray(value) || value.indexOf(operand) === -1,
        applicableToSchema: (schema) => (schema === null || schema === void 0 ? void 0 : schema.type) === 'array' && schema.items,
        getOperandSchema: (schema) => schema.items,
    },
    less_than: {
        name: 'less than',
        handler: (value, operand) => {
            return parseFloat(value) === NaN || parseFloat(operand) === NaN
                ? false
                : parseFloat(value) < parseFloat(operand);
        },
        applicableToSchema: (schema) => (0, data_schema_1.schemaIsNumber)(schema),
        getOperandSchema: () => ({ type: 'number' }),
    },
    less_than_or_equal: {
        name: 'less than or equal',
        handler: (value, operand) => {
            return parseFloat(value) === NaN || parseFloat(operand) === NaN
                ? false
                : parseFloat(value) <= parseFloat(operand);
        },
        applicableToSchema: (schema) => (0, data_schema_1.schemaIsNumber)(schema),
        getOperandSchema: () => ({ type: 'number' }),
    },
    more_than: {
        name: 'more than',
        handler: (value, operand) => {
            return parseFloat(value) === NaN || parseFloat(operand) === NaN
                ? false
                : parseFloat(value) > parseFloat(operand);
        },
        applicableToSchema: (schema) => (0, data_schema_1.schemaIsNumber)(schema),
        getOperandSchema: () => ({ type: 'number' }),
    },
    more_than_or_equal: {
        name: 'more than or equal',
        handler: (value, operand) => {
            return parseFloat(value) === NaN || parseFloat(operand) === NaN
                ? false
                : parseFloat(value) >= parseFloat(operand);
        },
        applicableToSchema: (schema) => (0, data_schema_1.schemaIsNumber)(schema),
        getOperandSchema: () => ({ type: 'number' }),
    },
    is_not_empty: {
        name: 'is not empty',
        handler: (value) => {
            if (Array.isArray(value)) {
                return value.length > 0;
            }
            else if (typeof value === 'object') {
                return value !== null && Object.keys(value).length > 0;
            }
            else {
                return value !== undefined && value !== '';
            }
        },
        applicableToSchema: () => true,
        getOperandSchema: () => null,
    },
    is_empty: {
        name: 'is empty',
        handler: (value) => {
            if (Array.isArray(value)) {
                return value.length === 0;
            }
            else if (typeof value === 'object') {
                return value === null || Object.keys(value).length === 0;
            }
            else {
                return value === undefined || value === '';
            }
        },
        applicableToSchema: () => true,
        getOperandSchema: () => null,
    },
};
//# sourceMappingURL=operators.js.map