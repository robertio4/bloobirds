import {
  DataLocator,
  DataLocatorStepArrayItem,
  DataLocatorStepObjectProperty,
  DataLocatorStepType,
  locatorToSteps,
} from '../data-builder/locators'
import { DataFilterOperator, OPERATORS } from './operators'

export function doesMatchFilter(data: any, filter: DataFilter): boolean {
  if (filter && Array.isArray(filter)) {
    for (const condition of filter) {
      const operator = OPERATORS[condition.operator]
      if (!operator) {
        continue
      }
      // If there are multiple field values, it means locator is pointing to an array
      // - in this case test if any of them matches the filter.
      let fieldValues = getFilterFieldValuesByLocator(data, condition.field)
      // If no field values found - test one value that equals `undefined` - in case the filter is something like "is empty"
      if (!fieldValues?.length) {
        fieldValues = [undefined]
      }
      const conditionMatches = fieldValues.some((fieldValue) =>
        operator.handler(fieldValue, condition.value),
      )
      if (!conditionMatches) {
        return false
      }
    }
    return true
  } else {
    return true
  }
}

export class DataFilterCondition {
  constructor(
    public field: string,
    public operator: string,
    public value?: any,
  ) {}
}

export type DataFilter = DataFilterCondition[]

export function getOperatorsBySchema(schema: any): DataFilterOperator[] {
  if (!schema || typeof schema !== 'object') {
    return []
  }
  const results = []
  for (const [type, operator] of Object.entries(OPERATORS)) {
    if (operator.applicableToSchema(schema)) {
      results.push({
        type,
        name: operator.name,
        operandSchema: operator.getOperandSchema(schema),
      })
    }
  }
  return results
}

export function getFilterFieldValuesByLocator(
  data,
  locator: DataLocator,
): any[] {
  const locatorSteps = locatorToSteps(locator)
  const result: any[] = []
  let curValue = data

  for (let idx = 0; idx < locatorSteps.length; ++idx) {
    if (curValue === null || curValue === undefined) {
      return []
    }

    const locatorStep = locatorSteps[idx]
    switch (locatorStep.type) {
      case DataLocatorStepType.CURRENT_ARRAY_ITEM:
        if (Array.isArray(curValue)) {
          // if <array>.$current locator is used - iterate over all elements
          // of the array and see if any of them match
          for (const val of curValue) {
            result.push(
              ...getFilterFieldValuesByLocator(
                val,
                locatorSteps.slice(idx + 1),
              ),
            )
          }
          return result
        } else {
          return []
        }
      case DataLocatorStepType.ARRAY_ITEM:
        if (Array.isArray(curValue)) {
          curValue = curValue[(locatorStep as DataLocatorStepArrayItem).index]
          break
        } else {
          return []
        }
      case DataLocatorStepType.OBJECT_PROPERTY:
        if (Array.isArray(curValue)) {
          // If we are trying to get object property of an array,
          // return values from the given property of all the array items
          for (const val of curValue) {
            result.push(
              ...getFilterFieldValuesByLocator(val, locatorSteps.slice(idx)),
            )
          }
          return result
        } else {
          curValue =
            curValue[
              (locatorStep as DataLocatorStepObjectProperty).propertyName
            ]
          break
        }
    }
  }
  if (curValue !== null && curValue !== undefined) {
    result.push(curValue)
  }
  return result
}
