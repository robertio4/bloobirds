import { BadRequestError } from '../errors'
import { DataBuilderFormulaType } from './formulas'
import {
  DataLocatorStepArrayItem,
  DataLocatorStepCurrentArrayItem,
  DataLocatorStepObjectProperty,
  findValueLocators,
  getIconUriForLocator,
  getNameComponentsForLocator,
  getNameForLocator,
  getSchemaByLocator,
  getFormulaLocators,
  getValueAtLocator,
  locatorToSteps,
  locatorToString,
  makeSchemaForLocator,
  setSchemaAtLocator,
  setValueAtLocator,
  stepsToLocator,
  pickFieldsFromValue,
  extractFieldLocator,
  getLocatorsFromData,
  getLocatorsFromSchema,
  excludeFieldsFromValue,
} from './locators'

describe('Locators', () => {
  const PROPERTY_NAME = 'testProperty'
  const TEST_SIMPLE_SCHEMA = { type: 'string' }
  const TEST_COMPLEX_SCHEMA = {
    type: 'object',
    properties: {
      [PROPERTY_NAME]: {
        type: 'array',
        key: 'keyValue',
        items: {
          type: 'object',
          properties: {
            [PROPERTY_NAME]: {
              type: 'array',
              items: TEST_SIMPLE_SCHEMA,
            },
          },
        },
      },
    },
  }
  const OBJECT_PROPERTY_LOCATOR = new DataLocatorStepObjectProperty(
    PROPERTY_NAME,
  )
  const ARRAY_ITEM_LOCATOR = new DataLocatorStepArrayItem(2)
  const CURRENT_ITEM_LOCATOR = new DataLocatorStepCurrentArrayItem()

  describe('getSchemaByLocator', () => {
    it('should return schema by empty locator', () => {
      expect(getSchemaByLocator(TEST_COMPLEX_SCHEMA, [])).toEqual(
        TEST_COMPLEX_SCHEMA,
      )
    })

    it('should return schema for object property locator', () => {
      expect(
        getSchemaByLocator(TEST_COMPLEX_SCHEMA, [OBJECT_PROPERTY_LOCATOR]),
      ).toEqual(TEST_COMPLEX_SCHEMA.properties[PROPERTY_NAME])
    })

    it('should return schema for array item locator', () => {
      expect(
        getSchemaByLocator(TEST_COMPLEX_SCHEMA, [
          OBJECT_PROPERTY_LOCATOR,
          ARRAY_ITEM_LOCATOR,
        ]),
      ).toEqual(TEST_COMPLEX_SCHEMA.properties[PROPERTY_NAME].items)
    })

    it('should return schema for current array item locator', () => {
      expect(
        getSchemaByLocator(TEST_COMPLEX_SCHEMA, [
          OBJECT_PROPERTY_LOCATOR,
          ARRAY_ITEM_LOCATOR,
          OBJECT_PROPERTY_LOCATOR,
          CURRENT_ITEM_LOCATOR,
        ]),
      ).toEqual(
        TEST_COMPLEX_SCHEMA.properties[PROPERTY_NAME].items.properties[
          PROPERTY_NAME
        ].items,
      )
    })

    it('should return null if object property does not exist', () => {
      expect(
        getSchemaByLocator(TEST_COMPLEX_SCHEMA, '$.nonExistentProperty'),
      ).toBeNull()
    })

    it('should return null if used $current without an array', () => {
      expect(getSchemaByLocator(TEST_COMPLEX_SCHEMA, '$.$current')).toBeNull()
    })
  })

  describe('setSchemaAtLocator', () => {
    it('should set schema at root', () => {
      expect(
        setSchemaAtLocator({ type: 'string' }, '$', TEST_COMPLEX_SCHEMA),
      ).toEqual(TEST_COMPLEX_SCHEMA)
    })

    it('should set schema for object key and keep other keys', () => {
      expect(
        setSchemaAtLocator(
          { type: 'object', properties: { existingKey: TEST_SIMPLE_SCHEMA } },
          '$.key',
          TEST_COMPLEX_SCHEMA,
        ),
      ).toEqual({
        type: 'object',
        properties: {
          key: TEST_COMPLEX_SCHEMA,
          existingKey: TEST_SIMPLE_SCHEMA,
        },
      })
    })

    it('should set schema for array items but keey existing schema as well', () => {
      expect(
        setSchemaAtLocator(
          {
            type: 'array',
            items: {
              type: 'object',
              properties: { existingKey: TEST_SIMPLE_SCHEMA },
            },
          },
          '$.$current.key',
          TEST_COMPLEX_SCHEMA,
        ),
      ).toEqual({
        type: 'array',
        items: {
          type: 'object',
          properties: {
            key: TEST_COMPLEX_SCHEMA,
            existingKey: TEST_SIMPLE_SCHEMA,
          },
        },
      })
    })
  })

  describe('makeSchemaForLocator', () => {
    it('should make schema for empty locator', () => {
      expect(makeSchemaForLocator([], TEST_SIMPLE_SCHEMA)).toEqual(
        TEST_SIMPLE_SCHEMA,
      )
    })

    it('should make schema for object property locator', () => {
      expect(
        makeSchemaForLocator([OBJECT_PROPERTY_LOCATOR], TEST_SIMPLE_SCHEMA),
      ).toEqual({
        type: 'object',
        properties: {
          [PROPERTY_NAME]: TEST_SIMPLE_SCHEMA,
        },
      })
    })

    it('should make schema for array item locator', () => {
      expect(
        makeSchemaForLocator([ARRAY_ITEM_LOCATOR], TEST_SIMPLE_SCHEMA),
      ).toEqual({
        type: 'array',
        items: TEST_SIMPLE_SCHEMA,
      })
    })

    it('should make schema for current item locator', () => {
      expect(
        makeSchemaForLocator([CURRENT_ITEM_LOCATOR], TEST_SIMPLE_SCHEMA),
      ).toEqual({
        type: 'array',
        items: TEST_SIMPLE_SCHEMA,
      })
    })

    it('should make schema for a composite locator', () => {
      expect(
        makeSchemaForLocator(
          [
            OBJECT_PROPERTY_LOCATOR,
            CURRENT_ITEM_LOCATOR,
            OBJECT_PROPERTY_LOCATOR,
            ARRAY_ITEM_LOCATOR,
          ],
          TEST_SIMPLE_SCHEMA,
        ),
      ).toEqual({
        type: 'object',
        properties: {
          [PROPERTY_NAME]: {
            type: 'array',
            items: {
              type: 'object',
              properties: {
                [PROPERTY_NAME]: {
                  type: 'array',
                  items: TEST_SIMPLE_SCHEMA,
                },
              },
            },
          },
        },
      })
    })
  })

  describe('locatorToSteps', () => {
    it('should throw on incorrect value', () => {
      expect(() => locatorToSteps(null)).toThrow(BadRequestError)
      expect(() => locatorToSteps('')).toThrow(BadRequestError)
      expect(() => locatorToSteps({ key: 'value' } as any)).toThrow(
        BadRequestError,
      )
    })
    it('should throw error for two dots ..', () => {
      expect(() => locatorToSteps('$..')).toThrow(BadRequestError)
      expect(() => locatorToSteps('$..')).toThrow(
        'There should be a property name after a dot',
      )
    })

    it('should throw error for not closed [ bracket', () => {
      expect(() => locatorToSteps('$.prop[1')).toThrow(BadRequestError)
      expect(() => locatorToSteps('$.prop[1')).toThrow(
        'Could not find a closing bracket for the bracket at position 6. Locator: $.prop[1',
      )
    })

    it('should throw error for redundant ] bracket', () => {
      expect(() => locatorToSteps('$.prop[1]]')).toThrow(BadRequestError)
      expect(() => locatorToSteps('$.prop[1]]')).toThrow(
        'Unexpected symbol at position 9. Locator: $.prop[1]]',
      )
    })

    it('should throw error if [index] is not a number', () => {
      expect(() => locatorToSteps('$.prop[aa]')).toThrow(BadRequestError)
      expect(() => locatorToSteps('$.prop[aa]')).toThrow(
        'Invalid index [aa]. Index should be a positive numbe',
      )
    })

    it('should accept locators without $.', () => {
      expect(locatorToSteps('prop[0]')).toEqual([
        new DataLocatorStepObjectProperty('prop'),
        new DataLocatorStepArrayItem(0),
      ])
    })

    it('should extract locators from simple string locator', () => {
      expect(locatorToSteps('$.name')).toEqual([
        new DataLocatorStepObjectProperty('name'),
      ])
    })

    it('should extract locators from nested object string locator', () => {
      expect(locatorToSteps('$.name.firstName')).toEqual([
        new DataLocatorStepObjectProperty('name'),
        new DataLocatorStepObjectProperty('firstName'),
      ])
    })

    it('should extract locators if root is array', () => {
      expect(locatorToSteps('$[5]')).toEqual([new DataLocatorStepArrayItem(5)])
    })

    it('should extract locators from string locator with $current', () => {
      expect(locatorToSteps('$.$current.name')).toEqual([
        new DataLocatorStepCurrentArrayItem(),
        new DataLocatorStepObjectProperty('name'),
      ])
    })

    it('should extract locators from string locator with array item index: prop[N]', () => {
      expect(locatorToSteps('$.users[52].name')).toEqual([
        new DataLocatorStepObjectProperty('users'),
        new DataLocatorStepArrayItem(52),
        new DataLocatorStepObjectProperty('name'),
      ])
    })

    it('should extract locators from string locator with nested arrays: prop[N][N]', () => {
      expect(locatorToSteps('$.users[52][10].name')).toEqual([
        new DataLocatorStepObjectProperty('users'),
        new DataLocatorStepArrayItem(52),
        new DataLocatorStepArrayItem(10),
        new DataLocatorStepObjectProperty('name'),
      ])
    })

    it('should extract locators from complex string locator', () => {
      expect(locatorToSteps('$.field[0].subfield')).toEqual([
        new DataLocatorStepObjectProperty('field'),
        new DataLocatorStepArrayItem(0),
        new DataLocatorStepObjectProperty('subfield'),
      ])
    })

    it('should extract locators from nested arrays with nested anyOf locator', () => {
      expect(locatorToSteps('$.field[0][3].subfield')).toEqual([
        new DataLocatorStepObjectProperty('field'),
        new DataLocatorStepArrayItem(0),
        new DataLocatorStepArrayItem(3),
        new DataLocatorStepObjectProperty('subfield'),
      ])
    })

    it('should extract locator with specials symbols', () => {
      expect(
        locatorToSteps('$.dot\\.field[0].b\\racket\\[subfield[0].\\\\'),
      ).toEqual([
        new DataLocatorStepObjectProperty('dot.field'),
        new DataLocatorStepArrayItem(0),
        new DataLocatorStepObjectProperty('bracket[subfield'),
        new DataLocatorStepArrayItem(0),
        new DataLocatorStepObjectProperty('\\'),
      ])
    })
  })

  describe('setValueAtLocator', () => {
    const TEST_OBJECT = {
      name: 'John',
      lastName: 'Doe',
      friends: [
        {
          name: 'Jane',
          lastName: 'Doe',
        },
        {
          name: 'Jack',
          lastName: 'Doe',
        },
      ],
    }

    it('should set value to empty object', () => {
      const result = setValueAtLocator(null, '$.name', 'John')
      expect(result).toEqual({ name: 'John' })
    })

    it('should return the value if locator is empty', () => {
      expect(setValueAtLocator(TEST_OBJECT, '$', 'value')).toEqual('value')
    })

    it('should override a simple property', () => {
      expect(setValueAtLocator(TEST_OBJECT, '$.name', 'Sarah')).toEqual({
        ...TEST_OBJECT,
        name: 'Sarah',
      })
    })

    it('should delete property if undefined is provided', () => {
      expect(
        setValueAtLocator(
          {
            name: 'John',
            lastName: 'Doe',
          },
          '$.name',
          undefined,
        ),
      ).toEqual({
        lastName: 'Doe',
      })
    })

    it('should override a property inside an array', () => {
      expect(
        setValueAtLocator(TEST_OBJECT, '$.friends[1].lastName', 'Brown'),
      ).toEqual({
        ...TEST_OBJECT,
        friends: [
          TEST_OBJECT.friends[0],
          {
            ...TEST_OBJECT.friends[1],
            lastName: 'Brown',
          },
        ],
      })
    })

    it('should set value at index 0 when used with $current', () => {
      expect(
        setValueAtLocator(TEST_OBJECT, '$.friends.$current.name', 'Sarah'),
      ).toEqual({
        ...TEST_OBJECT,
        friends: [
          {
            ...TEST_OBJECT.friends[0],
            name: 'Sarah',
          },
          TEST_OBJECT.friends[1],
        ],
      })
    })

    it('should create a property if does not exist', () => {
      expect(setValueAtLocator(TEST_OBJECT, '$.email', 'john@doe.com')).toEqual(
        {
          ...TEST_OBJECT,
          email: 'john@doe.com',
        },
      )
    })

    it('should create nested arrays and properties if do not exist', () => {
      expect(
        setValueAtLocator(
          TEST_OBJECT,
          '$.enemies[2].emails[0].value',
          'john@doe.com',
        ),
      ).toEqual({
        ...TEST_OBJECT,
        enemies: [
          undefined,
          undefined,
          {
            emails: [
              {
                value: 'john@doe.com',
              },
            ],
          },
        ],
      })
    })
  })

  describe('stepsToLocator', () => {
    it('should convert undefined, null, and empty array values to a root locator', () => {
      expect(stepsToLocator(undefined)).toEqual('$')
      expect(stepsToLocator(null)).toEqual('$')
      expect(stepsToLocator([])).toEqual('$')
    })
    it('should convert steps to corresponding locator parts', () => {
      expect(
        stepsToLocator([
          new DataLocatorStepObjectProperty('friends'),
          new DataLocatorStepCurrentArrayItem(),
          new DataLocatorStepObjectProperty('names'),
          new DataLocatorStepArrayItem(2),
          new DataLocatorStepObjectProperty('firstName'),
        ]),
      ).toEqual('$.friends.$current.names[2].firstName')
    })
    it('should convert steps with special symbols', () => {
      expect(
        stepsToLocator([
          new DataLocatorStepObjectProperty('dot.field'),
          new DataLocatorStepObjectProperty('slash\\field'),
          new DataLocatorStepObjectProperty('bracket[field'),
          new DataLocatorStepArrayItem(2),
        ]),
      ).toEqual('$.dot\\.field.slash\\\\field.bracket\\[field[2]')
    })
  })

  describe('locatorToString', () => {
    it('should keep empty values empty', () => {
      expect(locatorToString(undefined)).toBeUndefined()
      expect(locatorToString(null)).toEqual(null)
    })
    it('should keep string values string', () => {
      expect(locatorToString('')).toEqual('')
      expect(locatorToString('$')).toEqual('$')
      expect(locatorToString('$.name')).toEqual('$.name')
    })
    it('should convert locator steps to string', () => {
      expect(
        locatorToString([
          new DataLocatorStepObjectProperty('posts'),
          new DataLocatorStepCurrentArrayItem(),
        ]),
      ).toEqual('$.posts.$current')
    })
  })

  describe('getIconUriForLocator', () => {
    it('should return the latest uri encountered along locator steps', () => {
      const schema = {
        type: 'object',
        iconUri: 'uri1',
        properties: {
          prop1: {
            type: 'object',
            iconUri: 'uri2',
            properties: {
              prop2: { type: 'string' },
            },
          },
        },
      }
      expect(getIconUriForLocator(schema, '$.prop1.prop2')).toEqual('uri2')
    })

    it('should return undefined if schema does not have an icon URI', () => {
      const schema = {
        type: 'object',
        properties: {
          prop1: {
            type: 'object',
            properties: {
              prop2: { type: 'string' },
            },
          },
        },
      }
      expect(getIconUriForLocator(schema, '$.prop1.prop2')).toBeUndefined()
    })

    it('should return null for non-existent locator', () => {
      const schema = {
        type: 'string',
      }
      expect(getIconUriForLocator(schema, '$.prop1.prop2')).toBeNull()
    })
  })

  describe('getNameForLocator', () => {
    it('should return title if present', () => {
      const schema = {
        type: 'object',
        properties: {
          prop1: {
            type: 'string',
            title: 'Prop Name',
          },
        },
      }
      expect(getNameForLocator(schema, '$.prop1')).toEqual('Prop Name')
    })

    it('should return key if title is not present', () => {
      const schema = {
        type: 'object',
        properties: {
          prop1: {
            type: 'string',
          },
        },
      }
      expect(getNameForLocator(schema, '$.prop1')).toEqual('Prop1')
    })

    describe('getNameComponentsForLocator', () => {
      it('should ignore schemas with title set to empty string', () => {
        const schema = {
          type: 'object',
          properties: {
            ignore: {
              type: 'object',
              title: '',
              properties: {
                prop1: {
                  title: 'Prop 1',
                },
              },
            },
          },
        }

        expect(getNameComponentsForLocator(schema, '$.ignore.prop1')).toEqual([
          'Prop 1',
        ])
      })
    })

    it('should return undefined if locator does not exist', () => {
      const schema = {
        type: 'object',
      }
      expect(getNameForLocator(schema, '$.prop1')).toBeNull()
    })
  })

  describe('getValueAtLocator', () => {
    const variables = {
      obj: {
        prop: 'objPropValue',
      },
      arr: [
        {
          arrProp: 'aprPropValue',
        },
        {
          arrProp: 'aprPropValue2',
        },
      ],
    }
    it('should return original variable with empty locator', () => {
      expect(getValueAtLocator(variables, '$')).toEqual(variables)
    })

    it('should return value from object property locator', () => {
      expect(getValueAtLocator(variables, '$.obj.prop')).toEqual(
        variables.obj.prop,
      )
    })

    it('should return value from array item locator', () => {
      expect(getValueAtLocator(variables, '$.arr[1].arrProp')).toEqual(
        variables.arr[1].arrProp,
      )
    })

    it('should return value from currentItem locator', () => {
      expect(getValueAtLocator(variables, '$.arr.$current.arrProp')).toEqual(
        variables.arr[0].arrProp,
      )
    })
  })

  describe('getFormulaLocators', () => {
    it('should return empty list for an empty value', () => {
      expect(getFormulaLocators(DataBuilderFormulaType.VAR, null)).toEqual([])
      expect(getFormulaLocators(DataBuilderFormulaType.VAR, undefined)).toEqual(
        [],
      )
    })

    it('should return empty list for a scalar value', () => {
      expect(getFormulaLocators(DataBuilderFormulaType.VAR, 'value')).toEqual(
        [],
      )
      expect(getFormulaLocators(DataBuilderFormulaType.VAR, 5)).toEqual([])
      expect(getFormulaLocators(DataBuilderFormulaType.VAR, false)).toEqual([])
    })

    it('should return empty list for an object without $ui', () => {
      expect(
        getFormulaLocators(DataBuilderFormulaType.VAR, { key: 'value' }),
      ).toEqual([])
    })

    it('should return root locator', () => {
      expect(
        getFormulaLocators(DataBuilderFormulaType.VAR, { $var: '$.abc' }),
      ).toEqual(['$'])
      expect(
        getFormulaLocators(DataBuilderFormulaType.ITERATE, {
          $iterate: { locator: '$.abc' },
        }),
      ).toEqual(['$'])
    })

    it('should return locators inside nested objects', () => {
      expect(
        getFormulaLocators(DataBuilderFormulaType.VAR, {
          obj: {
            key1: {
              $var: true,
            },
            key2: {
              $var: {
                uiConfig: 'value',
              },
            },
          },
          key: {
            $var: true,
          },
        }),
      ).toEqual(['$.obj.key1', '$.obj.key2', '$.key'])
    })

    it('should return locators inside nested lists', () => {
      expect(
        getFormulaLocators(DataBuilderFormulaType.VAR, {
          obj: {
            list: [
              {
                $var: true,
              },
              {
                listKey: {
                  $var: true,
                },
              },
            ],
          },
        }),
      ).toEqual(['$.obj.list[0]', '$.obj.list[1].listKey'])
    })

    it('should not return locator if $ui is not the only key', () => {
      expect(
        getFormulaLocators(DataBuilderFormulaType.VAR, {
          $var: true,
          anotherKey: true,
        }),
      ).toEqual([])
    })
  })

  describe('findValueLocator', () => {
    it('should work correctly with empty data', () => {
      expect(findValueLocators(null, 'value')).toEqual([])
      expect(findValueLocators(undefined, 'value')).toEqual([])
    })

    it('should find value if it equals data', () => {
      expect(findValueLocators('value', 'value')).toEqual(['$'])
      expect(findValueLocators(5, 5)).toEqual(['$'])
      expect(findValueLocators(false, false)).toEqual(['$'])
      expect(findValueLocators({ key: 'value' }, { key: 'value' })).toEqual([
        '$',
      ])
    })

    it('should find value in object', () => {
      expect(findValueLocators({ key: 'value' }, 'value')).toEqual(['$.key'])
      expect(
        findValueLocators({ key: { subkey: 'value' } }, { subkey: 'value' }),
      ).toEqual(['$.key'])
    })

    it('sholud find value in array', () => {
      expect(findValueLocators([1, 2, 3], 1)).toEqual(['$[0]'])
      expect(
        findValueLocators(
          [{ key: 'not value' }, { key: 'value' }, { key: 'value' }],
          { key: 'value' },
        ),
      ).toEqual(['$[1]', '$[2]'])
    })

    it('sholud find value in nested object', () => {
      expect(
        findValueLocators(
          [
            1,
            2,
            {
              key: 1,
            },
          ],
          1,
        ),
      ).toEqual(['$[0]', '$[2].key'])
    })
  })
})

describe('pickFieldsFromValue', () => {
  const value = {
    key: 'value',
    objKey: {
      subKey: 'subKeyValue',
    },
    listKey: [
      {
        listSubKey: 'listSubKeyValue',
      },
    ],
  }

  it('should pick empty list of fields', () => {
    expect(pickFieldsFromValue(value, [])).toBeUndefined()
  })

  it('should pick non-existent values correctly', () => {
    expect(pickFieldsFromValue(value, ['$.nonexistent'])).toBeUndefined()
  })

  it('should pick values correctly', () => {
    expect(pickFieldsFromValue(value, ['$.key'])).toEqual({ key: 'value' })
    expect(pickFieldsFromValue(value, ['$.objKey.subKey'])).toEqual({
      objKey: { subKey: 'subKeyValue' },
    })
    expect(pickFieldsFromValue(value, ['$.listKey[0].listSubKey'])).toEqual({
      listKey: [{ listSubKey: 'listSubKeyValue' }],
    })
  })
})

describe('extractFieldLocator', () => {
  it('should return original locator for locators without formula', () => {
    expect(extractFieldLocator('$')).toEqual('$')
    expect(extractFieldLocator('$.key')).toEqual('$.key')
    expect(extractFieldLocator('$.objKey.subKey')).toEqual('$.objKey.subKey')
    expect(extractFieldLocator('$.listKey[0].listSubKey')).toEqual(
      '$.listKey[0].listSubKey',
    )
  })

  it('should return field part of the locator if it encounters formula', () => {
    expect(extractFieldLocator('$.$map.value')).toEqual('$')
    expect(extractFieldLocator('field.$firstName.value')).toEqual('$.field')
    expect(extractFieldLocator('field.$firstName')).toEqual('$.field')
  })
})

describe('getLocatorsFromData', () => {
  it('should return no locators for empty data', () => {
    expect(getLocatorsFromData(null)).toEqual([])
    expect(getLocatorsFromData(undefined)).toEqual([])
  })

  it('should return parent locator if data is not an object or array', () => {
    expect(getLocatorsFromData('value', '$')).toEqual(['$'])
    expect(getLocatorsFromData(5, '$')).toEqual(['$'])
    expect(getLocatorsFromData(false, '$')).toEqual(['$'])
  })

  it('should return object keys if data is object', () => {
    expect(getLocatorsFromData({ key: 'value', key2: 'value2' }, '$')).toEqual([
      '$.key',
      '$.key2',
    ])
  })

  it('should return array items if data is array', () => {
    expect(getLocatorsFromData([{ key: 'value' }, 0], '$')).toEqual([
      '$[0].key',
      '$[1]',
    ])
  })
})

describe('getLocatorsFromSchema', () => {
  it('should return no locators if schema is empty', () => {
    expect(getLocatorsFromSchema(null)).toEqual([])
    expect(getLocatorsFromSchema(undefined)).toEqual([])
    expect(getLocatorsFromSchema({})).toEqual([])
  })

  it('should return parent locator for scalar schema', () => {
    expect(getLocatorsFromSchema({ type: 'string' }, '$')).toEqual(['$'])
    expect(getLocatorsFromSchema({ type: 'number' }, '$')).toEqual(['$'])
    expect(getLocatorsFromSchema({ type: 'boolean' }, '$')).toEqual(['$'])
  })

  it('should return object keys for object schema', () => {
    expect(
      getLocatorsFromSchema(
        {
          type: 'object',
          properties: {
            key: { type: 'string' },
            key2: { type: 'number' },
          },
        },
        '$',
      ),
    ).toEqual(['$.key', '$.key2'])
  })

  it('should return first array item for array schema', () => {
    expect(
      getLocatorsFromSchema(
        {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              key: { type: 'string' },
            },
          },
        },
        '$',
      ),
    ).toEqual(['$[0].key'])
  })
})

describe('excludeFieldsFromValue', () => {
  it('should exclude simple field', () => {
    expect(
      excludeFieldsFromValue({ key: 'value', key2: 'value2' }, ['key']),
    ).toEqual({
      key2: 'value2',
    })
  })

  it('should exclude object key', () => {
    expect(
      excludeFieldsFromValue(
        {
          key: 'value',
          objKey: {
            subKey: 'subKeyValue',
          },
        },
        ['objKey.subKey'],
      ),
    ).toEqual({
      key: 'value',
      objKey: {},
    })
  })

  it('should exclude whole array item', () => {
    expect(excludeFieldsFromValue([1, 2], ['$[0]'])).toEqual([2])
  })

  it('should exclude property from array item', () => {
    expect(
      excludeFieldsFromValue(
        {
          key: 'value',
          listKey: [{ listSubKey: 'listSubKeyValue' }],
        },
        ['listKey[0].listSubKey'],
      ),
    ).toEqual({
      key: 'value',
      listKey: [{}],
    })
  })
})
