import { FlowConfigurationError } from '../../errors'
import { schemaTypeFromValue } from '../../json-schema'
import { mergeSchemas } from '../../json-schema/schema-builder'
import { DataBuilderContext } from '../context'
import {
  getFormulaLocators,
  getValueAtLocator,
  setValueAtLocator,
} from '../locators'
import { DataBuilderFormulaBase } from './base'
import { DataBuilderFormulaCase } from './case'
import { DataBuilderFormulaConcat } from './concat'
import { DataBuilderFormulaCopy } from './copy'
import { DataBuilderFormulaExtractDate } from './extractDate'
import { DataBuilderFormulaExtractTime } from './extractTime'
import { DataBuilderFormulaFindAppRecordId } from './findAppRecordId'
import { DataBuilderFormulaFindExternalRecordId } from './findExternalRecordId'
import { DataBuilderFormulaFirstName } from './first-name'
import { DataBuilderFormulaIterate } from './iterate'
import { DataBuilderFormulaLastName } from './last-name'
import { DataBuilderFormulaLookup } from './lookup'
import { DataBuilderFormulaMap } from './map'
import { DataBuilderFormulaPlain } from './plain'
import { DataBuilderFormulaRecord } from './record'
import { DataBuilderFormulaVar } from './var'
import { DataBuilderFormulaTpl } from './tpl'

export enum DataBuilderFormulaType {
  VAR = 'var',
  COPY = 'copy',
  REF = 'ref',
  TPL = 'tpl',
  RECORD = 'record', // DataRecord
  LOOKUP = 'lookup',
  PLAIN = 'plain', // plain JSON object
  MAP = 'map',
  CONCAT = 'concat',
  FIRST_NAME = 'firstName',
  LAST_NAME = 'lastName',
  ITERATE = 'iterate',
  CASE = 'case',
  EXTRACT_DATE = 'extractDate',
  EXTRACT_TIME = 'extractTime',
  FIND_EXTERNAL_RECORD_ID = 'findExternalRecordId',
  FIND_APP_RECORD_ID = 'findAppRecordId',
}

const FORMULAS = {
  [DataBuilderFormulaType.VAR]: DataBuilderFormulaVar,
  [DataBuilderFormulaType.REF]: DataBuilderFormulaVar,
  [DataBuilderFormulaType.RECORD]: DataBuilderFormulaRecord,
  [DataBuilderFormulaType.TPL]: DataBuilderFormulaTpl,
  [DataBuilderFormulaType.LOOKUP]: DataBuilderFormulaLookup,
  [DataBuilderFormulaType.PLAIN]: DataBuilderFormulaPlain,
  [DataBuilderFormulaType.MAP]: DataBuilderFormulaMap,
  [DataBuilderFormulaType.CONCAT]: DataBuilderFormulaConcat,
  [DataBuilderFormulaType.FIRST_NAME]: DataBuilderFormulaFirstName,
  [DataBuilderFormulaType.LAST_NAME]: DataBuilderFormulaLastName,
  [DataBuilderFormulaType.ITERATE]: DataBuilderFormulaIterate,
  [DataBuilderFormulaType.CASE]: DataBuilderFormulaCase,
  [DataBuilderFormulaType.EXTRACT_DATE]: DataBuilderFormulaExtractDate,
  [DataBuilderFormulaType.EXTRACT_TIME]: DataBuilderFormulaExtractTime,
  [DataBuilderFormulaType.FIND_EXTERNAL_RECORD_ID]:
    DataBuilderFormulaFindExternalRecordId,
  [DataBuilderFormulaType.FIND_APP_RECORD_ID]:
    DataBuilderFormulaFindAppRecordId,
  [DataBuilderFormulaType.COPY]: DataBuilderFormulaCopy,
}

export function isFormula(value) {
  return !!getFormula(value)
}

export function getFormula(value): DataBuilderFormulaBase {
  if (typeof value === 'object' && value !== null) {
    if (Object.keys(value).length === 1) {
      const key = Object.keys(value)[0]
      if (key.startsWith('$')) {
        const formulaType = key.slice(1)
        const formulaValue = value[key]
        if (formulaType in FORMULAS) {
          return new FORMULAS[formulaType](formulaValue)
        }
      }
    }
  }
  return undefined
}

export function processValue(value: any, context: DataBuilderContext): any {
  if (isFormula(value)) {
    const formula = getFormula(value)

    return formula.getValue(context)
  } else {
    if (typeof value === 'object') {
      if (Array.isArray(value)) {
        const result = []
        for (const valueItem of value) {
          const processedVal = processValue(valueItem, context)
          if (processedVal !== undefined) {
            result.push(processedVal)
          }
        }
        return result.length > 0 ? result : undefined
      } else if (value === null) {
        return value
      } else {
        const result = {}
        for (const [key, val] of Object.entries(value)) {
          const processedVal = processValue(val, context)
          if (processedVal !== undefined) {
            result[key] = processedVal
          }
        }
        if (Object.keys(result).length > 0) {
          return result
        } else {
          return undefined
        }
      }
    } else {
      return value
    }
  }
}

export function processCopy(data: any): any {
  const copyLocators = getFormulaLocators(DataBuilderFormulaType.COPY, data)
  for (const locator of copyLocators) {
    const value = getValueAtLocator(data, locator)
    const formula = getFormula(value) as DataBuilderFormulaCopy
    const valueToCopy = getValueAtLocator(data, formula.locator)
    const valueHasCopy =
      getFormulaLocators(DataBuilderFormulaType.COPY, valueToCopy).length > 0
    if (valueHasCopy) {
      throw new FlowConfigurationError(
        `${locator} is copying ${formula.locator}, which contains a copy formula`,
      )
    }
    setValueAtLocator(data, locator, valueToCopy)
  }
}

export function isEmpty(value: any): boolean {
  return typeof value == 'undefined'
}

export function getSchemaFromValue(
  value: any,
  variablesSchema: any,
  ignoreFormulas = false,
) {
  if (isFormula(value) && !ignoreFormulas) {
    return getFormula(value).getSchema(variablesSchema)
  } else {
    const type = schemaTypeFromValue(value)
    switch (type) {
      case 'object':
        const properties = {}
        for (const [propKey, propValue] of Object.entries(value)) {
          properties[propKey] = getSchemaFromValue(
            propValue,
            variablesSchema,
            ignoreFormulas,
          )
        }
        return {
          type: 'object',
          properties,
        }
      case 'array':
        const schemas = []
        for (const item of value) {
          schemas.push(
            getSchemaFromValue(item, variablesSchema, ignoreFormulas),
          )
        }
        return {
          type: 'array',
          items: mergeSchemas(schemas),
        }
      default:
        return { type: type }
    }
  }
}
