import { BadRequestError } from '../../errors'
import { DataBuilderFormulaType, isEmpty } from '.'
import { DataBuilderContext } from '../context'
import {
  DataLocator,
  DataLocatorStepArrayItem,
  DataLocatorStepObjectProperty,
  DataLocatorStepType,
  locatorToSteps,
  locatorToString,
} from '../locators'
import { toHeaderCase } from 'js-convert-case'

export abstract class DataBuilderFormulaBase {
  constructor(public type: DataBuilderFormulaType, public args: any) {
    this.type = type
    this.args = args
  }

  abstract getValue(context: DataBuilderContext): any

  abstract getSchema(variablesSchema): any

  toObject(): any {
    return {
      [`$${this.type}`]: this.args,
    }
  }

  toString(_variablesSchema?: any): string {
    return toHeaderCase(this.type)
  }
}

export function getValueByLocator(
  context: DataBuilderContext,
  locator: DataLocator,
): DataBuilderContext {
  let curValue = context.variables
  const curLocator = []
  const locatorSteps = locatorToSteps(locator)
  for (let i = 0; i < locatorSteps.length; ++i) {
    const locatorStep = locatorSteps[i]
    if (locatorStep.type == DataLocatorStepType.OBJECT_PROPERTY) {
      curValue = executeLocatorStepObjectProperty(
        curValue,
        locatorStep as DataLocatorStepObjectProperty,
      )
    } else if (locatorStep.type == DataLocatorStepType.ARRAY_ITEM) {
      curValue = executeLocatorStepArrayItem(
        curValue,
        locatorStep as DataLocatorStepArrayItem,
      )
    } else if (locatorStep.type == DataLocatorStepType.CURRENT_ARRAY_ITEM) {
      curValue = executeLocatorStepCurrentArrayItem(
        context,
        locatorToString(curLocator),
      )
    } else {
      // ToDo: this is an internal engine exception because it allowed an invalid
      // formula to be saved.
      throw new BadRequestError(
        `Unexpected locator step type: ${locatorStep.type}`,
      )
    }
    if (isEmpty(curValue)) {
      // If we reached a non-value, stop here and just return the non-value back
      break
    }
    curLocator.push(locatorStep)
  }
  return isEmpty(curValue) ? undefined : curValue
}

function executeLocatorStepObjectProperty(
  value: DataBuilderContext,
  step: DataLocatorStepObjectProperty,
): any {
  if (typeof value == 'object' && value !== null) {
    // Resolve value once in case it's lazy-loaded
    value[step.propertyName] = value[step.propertyName]
    return value[step.propertyName]
  } else {
    return undefined
  }
}

function executeLocatorStepArrayItem(
  value: DataBuilderContext,
  step: DataLocatorStepArrayItem,
): any {
  if (Array.isArray(value) && value[step.index]) {
    // Resolve value once in case it's lazy-loaded
    value[step.index] = value[step.index]
    return value[step.index]
  } else {
    return undefined
  }
}

function executeLocatorStepCurrentArrayItem(
  context: DataBuilderContext,
  locator: string,
): any {
  return context.getCurrentArrayItem(locator)
}
