import { DataBuilderFormulaType, processValue } from '.'
import { valueToString } from '..'
import { DataBuilderContext } from '../context'
import { DataBuilderFormulaBase } from './base'

const DEFAULT_DELIMITER = ''

type AnyValue = any

type ConcatFormulaOptions = {
  delimiter?: AnyValue
  values?: AnyValue[]
}

export class DataBuilderFormulaConcat extends DataBuilderFormulaBase {
  private readonly delimiter: AnyValue = DEFAULT_DELIMITER
  private readonly values: AnyValue[] = []

  constructor(public options: ConcatFormulaOptions | null) {
    super(DataBuilderFormulaType.CONCAT, options)

    if (options === null) {
      return
    }

    this.values = Array.isArray(options) ? options : options?.values ?? []
    this.delimiter = options.delimiter ?? DEFAULT_DELIMITER
  }

  getValue(context: DataBuilderContext) {
    if (!this.values.length) {
      return null
    }

    const computedValues = this.values.map((value) =>
      processValue(value, context),
    )
    const computedDelimiter = processValue(this.delimiter, context)

    return computedValues
      .filter((v) => v !== null && v !== undefined && v.toString() !== '')
      .join(computedDelimiter)
  }

  getSchema() {
    return { type: 'string' }
  }

  toString(variablesSchema) {
    const valueStrings = this.values.map((value) =>
      valueToString(value, variablesSchema),
    )
    if (valueStrings.length) {
      return `Concatenate(${valueStrings.join(', ')})`
    } else {
      return `Concatenate()`
    }
  }
}
