import { buildData, buildDataSchema } from '.'

describe('DataBuilder', () => {
  describe('build', () => {
    const TEST_STRING = 'Some string'
    const TEST_STRING_2 = 'Another string'
    const TEST_PROPERTY_NAME = 'prop1'
    const TEST_LIST = [
      {
        prop1: 'item 1 prop 1',
        prop2: 'item 1 prop 2',
        list: [
          {
            nestedProp: 'nested list item 1 prop',
          },
          {
            nestedProp: 'nested list item 2 prop',
          },
        ],
      },
      {
        prop1: 'item 2 prop 1',
        prop2: 'item 2 prop 2',
      },
    ]
    const TEST_SOURCE_OBJECT = {
      [TEST_PROPERTY_NAME]: TEST_STRING,
    }

    it('Should compose simple value into itself', () => {
      const values = ['some string', null, undefined, 34.42, true]
      for (const value of values) {
        expect(buildData(value, {})).toBe(value)
      }
    })

    it('Should compose nested JSON into itself', () => {
      expect(buildData(TEST_LIST, {})).toEqual(TEST_LIST)
    })

    it('Should compose a basic ref formula', () => {
      expect(
        buildData(
          {
            $ref: `$.${TEST_PROPERTY_NAME}`,
          },
          TEST_SOURCE_OBJECT,
        ),
      ).toEqual(TEST_STRING)
    })

    it('Should compose ref formula in short format $ref', () => {
      expect(
        buildData(
          {
            field: 'value',
            formulaField: {
              $ref: '$.variable.field',
            },
          },
          {
            variable: {
              field: 'variable field value',
            },
          },
        ),
      ).toEqual({
        field: 'value',
        formulaField: 'variable field value',
      })
    })

    it('Should compose plain formula in short format $plain', () => {
      expect(
        buildData(
          {
            $plain: 'john@doe.com',
          },
          {},
        ),
      ).toEqual('john@doe.com')
    })

    it('Should compose plain formula in short format $plain with nested $ref (and leave that $ref as it is)', () => {
      expect(
        buildData(
          {
            $plain: {
              field: {
                $ref: '$.variable.field',
              },
            },
          },
          {},
        ),
      ).toEqual({
        field: {
          $ref: '$.variable.field',
        },
      })
    })

    it('Should compose a formula within an array', () => {
      expect(
        buildData(
          [
            TEST_STRING_2,
            {
              $ref: `$.${TEST_PROPERTY_NAME}`,
            },
          ],
          TEST_SOURCE_OBJECT,
        ),
      ).toEqual([TEST_STRING_2, TEST_STRING])
    })

    it('Should compose a formula within an object', () => {
      expect(
        buildData(
          {
            value1: TEST_STRING_2,
            value2: {
              $ref: `$.${TEST_PROPERTY_NAME}`,
            },
          },
          TEST_SOURCE_OBJECT,
        ),
      ).toEqual({ value1: TEST_STRING_2, value2: TEST_STRING })
    })

    it('Should return formula for $lookup formula', () => {
      const lookupFormula = {
        $lookup: {
          uri: 'uri',
          query: { field: 'value' },
        },
      }
      expect(
        buildData({
          field: lookupFormula,
        }),
      ).toEqual({
        field: lookupFormula,
      })
    })

    it('Should execute $map formula', () => {
      const variables = {
        obj: {
          field: 'value',
          field2: 'value2',
          field2copy: 'value2',
          field2mapped: 'mappedValue2',
        },
      }
      const mapFormula = {
        $map: {
          value: {
            $ref: '$.obj.field2copy',
          },
          mapping: [
            {
              from: {
                $ref: '$.obj.field',
              },
              to: 'mappedValue',
            },
            {
              from: {
                $ref: '$.obj.field2',
              },
              to: {
                $ref: '$.obj.field2mapped',
              },
            },
          ],
        },
      }
      expect(
        buildData(
          {
            field: mapFormula,
          },
          variables,
        ),
      ).toEqual({
        field: variables.obj.field2mapped,
      })
    })

    it('should handle null variables', () => {
      const formula = {
        $ref: '$.obj.field',
      }
      expect(buildData(formula, null)).toEqual(undefined)
    })

    it('should skip objects without fields', () => {
      expect(buildData({})).toEqual(undefined)

      expect(
        buildData({
          key: {
            $var: '$.nonExistentField',
          },
        }),
      ).toEqual(undefined)
    })

    it('should skip arrays without values', () => {
      expect(buildData([])).toEqual(undefined)

      expect(
        buildData({
          list: [
            {
              $var: '$.nonExistentField',
            },
          ],
        }),
      ).toEqual(undefined)
    })

    it('should preserve null values in the result', () => {
      expect(
        buildData({
          prop: {
            prop2: null,
          },
        }),
      ).toEqual({
        prop: {
          prop2: null,
        },
      })
    })
  })
})

describe('composeSchemas', () => {
  it('should extract schemas from simple values', () => {
    expect(buildDataSchema(true)).toEqual({ type: 'boolean' })
    expect(buildDataSchema('abc')).toEqual({ type: 'string' })
    expect(buildDataSchema(10)).toEqual({ type: 'number' })
    expect(buildDataSchema(10.2)).toEqual({ type: 'number' })
    expect(buildDataSchema(null)).toEqual({ type: 'null' })
  })

  it('should extract schemas from plain objects', () => {
    expect(
      buildDataSchema({
        str: 'string',
        num: 10,
        bool: true,
        obj: {
          strField: 'string',
          listField: [10],
        },
      }),
    ).toEqual({
      type: 'object',
      properties: {
        str: { type: 'string' },
        num: { type: 'number' },
        bool: { type: 'boolean' },
        obj: {
          type: 'object',
          properties: {
            strField: { type: 'string' },
            listField: { type: 'array', items: { type: 'number' } },
          },
        },
      },
    })
  })

  it('should merge schemas from lists', () => {
    expect(buildDataSchema([10, 'str', { field: 'str' }])).toEqual({
      type: 'array',
      items: {
        anyOf: [
          { type: ['number', 'string'] },
          {
            type: 'object',
            properties: {
              field: { type: 'string' },
            },
          },
        ],
      },
    })
  })

  it('should compose schema from variables', () => {
    const variablesSchema = {
      type: 'object',
      properties: {
        strVar: { type: 'string' },
        objVar: {
          type: 'object',
          properties: {
            strField: { type: 'string' },
            boolfield: { type: 'boolean' },
          },
        },
      },
    }
    expect(
      buildDataSchema({ $ref: '$.objVar.strField' }, variablesSchema),
    ).toEqual({ type: 'string' })
  })

  it('should compose schema from variables in nested objects and arrays', () => {
    const variablesSchema = {
      type: 'object',
      properties: {
        strVar: { type: 'string' },
        objVar: {
          type: 'object',
          properties: {
            strField: { type: 'string' },
            boolField: { type: 'boolean' },
          },
        },
      },
    }
    expect(
      buildDataSchema(
        {
          objField: { strField: { $ref: '$.objVar.strField' } },
          listField: [{ $ref: '$.objVar.boolField' }],
        },
        variablesSchema,
      ),
    ).toEqual({
      type: 'object',
      properties: {
        objField: {
          type: 'object',
          properties: {
            strField: { type: 'string' },
          },
        },
        listField: {
          type: 'array',
          items: {
            type: 'boolean',
          },
        },
      },
    })
  })

  it('should compose schema for plain formula ignoring nested formulas', () => {
    const variablesSchema = {
      type: 'object',
      properties: {
        strVar: { type: 'string' },
      },
    }
    expect(
      buildDataSchema(
        {
          $plain: {
            $ref: '$.strVar',
          },
        },
        variablesSchema,
      ),
    ).toEqual({ type: 'object', properties: { $ref: { type: 'string' } } })
  })
})
