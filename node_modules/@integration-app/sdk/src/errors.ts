export enum ErrorType {
  /*
   * Something is wrong with the input received by the API.
   */
  BAD_REQUEST = 'Bad Request',

  /*
   * An error with a Connection.
   */
  CONNECTION = 'Connection',

  /*
   * Incorrect / broken flow configuration.
   */
  FLOW_CONFIGURATION = 'Flow Configuration',

  /*
   * Error with the flow's runtime data that prevents it from being completed.
   */
  FLOW_RUN = 'Flow Run',

  /*
   * Error within an engine (catch-all).
   */
  INTERNAL = 'Internal', // Error within an engine (catch-all).
}

export enum BadRequestErrorKey {
  NOT_FOUND = 'not_found',
  NOT_AUTHENTICATED = 'not_authenticated',
  ACCESS_DENIED = 'access_denied',
  ALREADY_EXISTS = 'already_exists',
}

export enum ConnectionErrorKey {
  CONNECTION_IS_DEFUNCT = 'connection_is_defunct',
  ACCESS_TOKEN_EXPIRED = 'access_token_expired',
}

interface ErrorDataFields {
  type?: ErrorType
  key?: string
  message: string
  data?: any
  docsLink?: string
  stack?: any
  causedByError?: ErrorData
  logs?: any[]
}

type ErrorConstructorArg = string | ErrorDataFields | Error

export function isIntegrationAppError(error) {
  return error && error.isIntegrationAppError
}

export class ErrorData implements ErrorDataFields {
  constructor(arg: ErrorConstructorArg) {
    if (arg instanceof Error) {
      this.message = arg.message
      this.stack = arg.stack
      this.type = ErrorType.INTERNAL
    } else if (typeof arg === 'string') {
      this.message = arg
      this.type = ErrorType.INTERNAL
    } else if (typeof arg === 'object' && arg !== null) {
      Object.assign(this, arg)
    } else {
      throw new Error(
        'Invalid argument when creating BaseErrorData: ' + JSON.stringify(arg),
      )
    }
  }
}

export interface ErrorData extends ErrorDataFields {}

export class IntegrationAppError extends Error {
  public isIntegrationAppError: true
  public data: ErrorData

  constructor(arg: ErrorConstructorArg) {
    const errorData = new ErrorData(arg)

    super(errorData.message)

    this.isIntegrationAppError = true
    this.data = errorData

    if (!this.data.type) {
      this.data.type = ErrorType.INTERNAL
    }

    // Display user-friendly message with doc link if it is thrown on the client
    if (typeof window !== 'undefined') {
      this.message = buildUserFriendlyErrorMessage(
        'Integration.app SDK Error',
        this.data,
      )
    }
  }
}

export class InternalError extends IntegrationAppError {
  constructor(arg: ErrorConstructorArg) {
    super(arg)
    this.data.type = ErrorType.INTERNAL
  }
}

export class BadRequestError extends IntegrationAppError {
  constructor(arg: ErrorConstructorArg) {
    super(arg)
    this.data.type = ErrorType.BAD_REQUEST
  }
}

export class FlowConfigurationError extends BadRequestError {
  constructor(arg: ErrorConstructorArg) {
    super(arg)
    this.data.type = ErrorType.FLOW_CONFIGURATION
  }
}

export class FlowRunError extends IntegrationAppError {
  constructor(arg: ErrorConstructorArg) {
    super(arg)
    this.data.type = ErrorType.FLOW_RUN
  }
}

export class ConnectionError extends IntegrationAppError {
  constructor(arg: ErrorConstructorArg) {
    super(arg)
    this.data.type = ErrorType.CONNECTION
  }
}

export class NotFoundError extends BadRequestError {
  constructor(arg: ErrorConstructorArg) {
    super(arg)
    this.data.key = BadRequestErrorKey.NOT_FOUND
  }
}

export class NotAuthenticatedError extends BadRequestError {
  constructor(arg: ErrorConstructorArg) {
    super(arg)
    this.data.key = BadRequestErrorKey.NOT_AUTHENTICATED
  }
}

export class AccessDeniedError extends BadRequestError {
  constructor(arg: ErrorConstructorArg) {
    super(arg)
    this.data.key = BadRequestErrorKey.ACCESS_DENIED
  }
}

export function getErrorFromData(data: any) {
  if (
    typeof data === 'object' &&
    data !== null &&
    Object.values(ErrorType).includes(data.type)
  ) {
    return new IntegrationAppError(data)
  }
  return null
}

export function extractIntegrationAppErrorData(error: any) {
  const data: ErrorData = error.isIntegrationAppError
    ? (error as IntegrationAppError).data
    : new ErrorData({
        message: error.message,
        type: ErrorType.INTERNAL,
      })
  if (!data.message) {
    data.message = error.message
  }
  if (!data.stack) {
    data.stack = error.stack
  }
  return data
}

export function buildUserFriendlyErrorMessage(
  prefix: string,
  { type, message, docsLink }: ErrorData,
) {
  return `${prefix}. \n Type: ${type} \n Message: "${message}" \n Docs: ${docsLink}`
}
