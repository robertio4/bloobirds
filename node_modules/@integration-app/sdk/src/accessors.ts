import { IntegrationAppClient } from '.'
import { PaginationResponse } from './entity-repository'
import qs from 'query-string'

export interface BaseElementInstance {
  id: string
}

export interface ElementInstanceSelector {
  id?: string
  autoCreate?: boolean
}

export class ElementAccessor<Element, CreateRequest, UpdateRequest> {
  constructor(
    protected options: {
      client: IntegrationAppClient
      path: string
      idOrKey: string
    },
  ) {}

  async get(): Promise<Element> {
    return this.options.client.get(
      `${this.options.path}/${this.options.idOrKey}`,
    )
  }

  async create(data: CreateRequest): Promise<Element> {
    return this.options.client.put(this.options.path, data)
  }

  async put(data: CreateRequest): Promise<Element> {
    return this.options.client.put(
      `${this.options.path}/${this.options.idOrKey}`,
      data,
    )
  }

  async patch(data: UpdateRequest): Promise<Element> {
    return this.options.client.patch(
      `${this.options.path}/${this.options.idOrKey}`,
      data,
    )
  }

  async archive(): Promise<void> {
    await this.options.client.delete(
      `${this.options.path}/${this.options.idOrKey}`,
    )
  }
}

export class ElementListAccessor<Element, FindQuery, CreateRequest> {
  constructor(private client: IntegrationAppClient, private path: string) {}

  async find(query?: FindQuery): Promise<PaginationResponse<Element>> {
    return this.client.get(this.path, query)
  }

  async create(data: CreateRequest): Promise<Element> {
    return this.client.post(this.path, data)
  }
}

export class ElementInstanceListAccessor<
  ElementInstance extends BaseElementInstance,
  FindQuery,
> {
  constructor(private client: IntegrationAppClient, private path: string) {}

  async find(query?: FindQuery): Promise<PaginationResponse<ElementInstance>> {
    return this.client.get(this.path, query)
  }
}

export class ElementInstanceAccessor<
  ElementInstance extends BaseElementInstance,
  Selector extends {
    id?: string
  },
  CreateRequest,
  UpdateRequest,
> {
  private id: string

  constructor(
    protected options: {
      client: IntegrationAppClient
      instancePath: string
      selector: string | Selector
    },
  ) {}

  async get(): Promise<ElementInstance> {
    return this.options.client.get(this.getPath())
  }

  async getId(): Promise<string> {
    if (!this.id) {
      if (this.options.selector && typeof this.options.selector === 'string') {
        this.id = this.options.selector
      } else {
        const element = await this.get()
        if (!element) {
          throw new Error(
            `Element not found using selector ${JSON.stringify(
              this.options.selector,
            )}`,
          )
        }
        this.id = element.id
      }
    }
    return this.id
  }

  async create(data?: CreateRequest): Promise<ElementInstance> {
    if (this.id) {
      throw new Error('Cannot create: element already exists')
    }
    const element = await this.options.client.post(this.getPath(), data)
    this.id = element.id
    return element
  }

  async put(data: CreateRequest): Promise<ElementInstance> {
    return this.options.client.put(this.getPath(), data)
  }

  async patch(data: UpdateRequest): Promise<ElementInstance> {
    return this.options.client.patch(this.getPath(), data)
  }

  async archive(): Promise<void> {
    return this.options.client.delete(this.getPath())
  }

  /**
   * @deprecated - use `archive` instead
   */
  async delete(): Promise<void> {
    return this.options.client.delete(this.getPath())
  }

  private getPath(operation = '') {
    return (
      this.options.instancePath +
      (operation ? `/${operation}` : '') +
      '?' +
      qs.stringify(this.getSelector())
    )
  }

  private getSelector(): Selector {
    return typeof this.options.selector === 'string'
      ? ({
          // Selector is the element's ID
          id: this.options.selector,
        } as Selector)
      : this.options.selector
  }
}
