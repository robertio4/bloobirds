import {
  DataLocatorStepObjectProperty,
  DataLocatorStepType,
  getLocatorsFromSchema,
  getNameForLocator,
  getSchemaByLocator,
  getValueAtLocator,
  locatorToSteps,
  setSchemaAtLocator,
  stepsToLocator,
} from '../data-builder/locators'
import { DataRecord } from '../data-collections'
import structuredClone from '@ungap/structured-clone'

export type DataSchemaType =
  | 'object'
  | 'array'
  | 'string'
  | 'number'
  | 'integer'
  | 'boolean'
  | 'null'

export interface DataSchema {
  /**
   * Human-readable name of the schema.
   */
  title?: string
  /**
   * Schema type.
   *
   * It is `string` instead of DataSchemaType because Typescript
   * interpreter type auto-detection identifies type values as `string` type
   * and can't math it to DataSchemaType
   */
  type?: string
  /**
   * Format for strings.
   */
  format?: string
  /**
   * Properties for `object` schema
   */
  properties?: { [key: string]: DataSchema }
  /**
   * Schema for array items
   */
  items?: DataSchema
  /**
   * For `object` schemas - whether value can contain properties besides
   * ones listed in `properties`.
   */
  additionalProperties?: boolean
  /**
   * List of possible values for `string` schema.
   */
  enum?: string[]
  /**
   * List of Data Records that can be used as possible values.
   */
  referenceRecords?: DataRecord[]
  /**
   * Path of a Data Collection containing possible values.
   */
  referenceCollectionPath?: string
  /**
   * For UDM schemas - reference to another UDM
   */
  referenceUdm?: string
  /**
   * Default value that will be used if none is provided.
   */
  default?: any
  /**
   * If `true`, schema allows custom values besides ones in
   * `enum`, `referenceRecords`, or `refrenceCollectionPath`.
   */
  allowCustom?: boolean
  /**
   * @deprecated - use referenceCollectionPath instead
   */
  referenceCollectionUri?: string
}

export function schemaIsScalar(schema: DataSchema) {
  return (
    schema.type != 'array' && schema.type != 'object' && schema.type != 'null'
  )
}

export function schemaHasFixedValues(schema: DataSchema) {
  if (!schema) {
    return false
  }

  return (
    schema.enum ||
    schema.referenceCollectionUri ||
    schema.referenceCollectionPath ||
    schema.referenceRecords ||
    schema.referenceUdm ||
    schema.type === 'boolean'
  )
}

export function schemaAllowsCustomValue(schema: DataSchema) {
  return !schemaHasFixedValues(schema) || schema.allowCustom
}

export function schemaIsNumber(schema: DataSchema) {
  return schema && (schema.type === 'number' || schema.type === 'integer')
}

export function schemaWithTitle(schema: DataSchema, title: string) {
  return typeof schema === 'object'
    ? {
        ...schema,
        title,
      }
    : schema
}

/**
 * Creates an object schema with `fields` picked from the source `schema`.
 */
export function pickFieldsFromSchema(
  schema: DataSchema,
  fields: string[],
): any {
  const result = {
    type: 'object',
    properties: {},
  }
  if (schema?.type === 'object' && schema?.properties) {
    for (const field of fields) {
      setSchemaAtLocator(result, field, getSchemaByLocator(schema, field))
    }
  }
  return result
}

/**
 * Returns copy of `schema` without `fields`
 */
export function excludeFieldsFromSchema(
  schema: DataSchema,
  fields: string[],
): any {
  let result = JSON.parse(JSON.stringify(schema))
  for (const field of fields ?? []) {
    result = setSchemaAtLocator(result, field, undefined)
  }
  return result
}

export function addRequiredFieldsToSchema(schema, fields) {
  if (!schema) {
    return undefined
  }
  if (!Array.isArray(fields)) {
    return schema
  }
  const newSchema = JSON.parse(JSON.stringify(schema))
  for (const field of fields) {
    const steps = locatorToSteps(field)
    const lastStep = steps.pop()
    if (lastStep.type === DataLocatorStepType.OBJECT_PROPERTY) {
      const objectLocator = stepsToLocator(steps)
      const objectSchema = getSchemaByLocator(newSchema, objectLocator)
      if (objectSchema) {
        objectSchema.required = [
          ...(objectSchema.required || []),
          (lastStep as DataLocatorStepObjectProperty).propertyName,
        ]
        setSchemaAtLocator(newSchema, objectLocator, objectSchema)
      }
    }
  }
  return newSchema
}

export function addDefaultsToSchema(
  sourceSchema: DataSchema,
  defaultValue: any,
) {
  const schema = structuredClone(sourceSchema)
  const fields = getLocatorsFromSchema(schema)

  for (const field of fields) {
    const fieldDefaultValue = getValueAtLocator(defaultValue, field)
    if (fieldDefaultValue) {
      const fieldSchema = getSchemaByLocator(schema, field)
      fieldSchema.default = fieldSchema.default ?? fieldDefaultValue
      setSchemaAtLocator(schema, field, fieldSchema)
    }
  }

  return schema
}

/**
 * Fills schema fields with human-readable titles.
 */
export function populateSchemaTitles(schema: any): void {
  if (!schema || typeof schema !== 'object') {
    return schema
  }
  const fields = getLocatorsFromSchema(schema)
  for (const field of fields) {
    const fieldSchema = getSchemaByLocator(schema, field)
    if (!fieldSchema?.title) {
      fieldSchema.title = getNameForLocator(schema, field)
      setSchemaAtLocator(schema, field, fieldSchema)
    }
  }
  return schema
}
