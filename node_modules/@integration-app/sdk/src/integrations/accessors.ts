import { Connection } from '../connections'
import {
  ConnectionMode,
  FindIntegrationsQuery,
  FindIntegrationsResponse,
  Integration,
} from '.'
import { IntegrationAppClient } from '..'
import { openIframe, showIframeLoader } from '../iframe'
import { ElementAccessor } from '../accessors'
import { CreateIntegrationRequest, UpdateIntegrationRequest } from './api'
import { ConnectorSpec } from '../connector-api'
import urljoin from 'url-join'

export class IntegrationsAccessor {
  constructor(private client: IntegrationAppClient) {}

  async find(query: FindIntegrationsQuery): Promise<FindIntegrationsResponse> {
    return this.client.get('/integrations', query)
  }
}

export class IntegrationAccessor extends ElementAccessor<
  Integration,
  CreateIntegrationRequest,
  UpdateIntegrationRequest
> {
  public baseUri: string

  constructor(private client: IntegrationAppClient, private idOrKey: string) {
    super({
      client,
      path: 'integrations',
      idOrKey,
    })
  }

  async getConnectorSpec(): Promise<ConnectorSpec> {
    return this.client.get(`/integrations/${this.idOrKey}/connector-spec`)
  }

  async createConnection({ parameters }): Promise<Connection> {
    const spec = await this.getConnectorSpec()

    let iframeElement
    if (spec.connectionMode === ConnectionMode.IFRAME) {
      iframeElement = createIframeElement()
    }

    return new Promise((resolve, reject) => {
      const connectionUrl = urljoin(
        this.client.apiUri,
        `oauth/new/${this.idOrKey}`,
        `?token=${this.client.token}&connectionParameters=${JSON.stringify(
          parameters,
        )}`,
      )

      const urlObj = new URL(connectionUrl)

      const requestId = (Math.random() + 1).toString(36).substring(0, 12)

      const listenerFunc = async (event: any) => {
        const message = event.data || {}
        if (
          message.source == 'integration.app' &&
          message.requestId == requestId
        ) {
          cleanup()
          if (message.type == 'newConnectionCreated') {
            resolve(message.connection)
          } else if (message.type == 'newConnectionCancel') {
            resolve(null)
          } else if (message.type == 'newConnectionFailure') {
            reject(new Error(message.error))
          }
        }
      }

      let cancelCheckInterval: any

      function cleanup() {
        clearInterval(cancelCheckInterval)
        window.removeEventListener('message', listenerFunc)
      }

      try {
        window.addEventListener('message', listenerFunc)

        urlObj.searchParams.append('requestId', requestId)

        if (iframeElement) {
          urlObj.searchParams.append('iframe', '1')
          iframeElement.src = urlObj.toString()
        } else {
          const height = Math.round(screen.height * 0.6)
          const width = Math.round(screen.width * 0.7)
          const top = Math.round(screen.height * 0.2)
          const left = Math.round(screen.height * 0.15)
          const popup = window.open(
            urlObj.toString(),
            null,
            `popup,width=${width},height=${height},left=${left},top=${top}`,
          )
          setTimeout(() => {
            if (!popup) {
              cleanup()
              reject({
                message: 'Popup has been blocked',
              })
            }
          }, 1000)
          cancelCheckInterval = setInterval(() => {
            if (popup?.closed) {
              cleanup()
              resolve(null)
            }
          }, 1000)
        }
      } catch (e) {
        reject(e)
      }
    })
  }

  /**
   * Show connection UI to your user.
   * Returns a promise that resolves to a new Connection object or
   * null if the user cancels the connection flow.
   */
  async openNewConnection(): Promise<Connection> {
    showIframeLoader()
    const uri = this.client.getEmbedUri(
      `/integrations/${this.idOrKey}/connection/connect`,
    )
    return new Promise<Connection>((resolve) => {
      openIframe(uri, {
        onClose: () => resolve(null),
        onSuccess: (connection) => resolve(connection),
      })
    })
  }

  /**
   * @deprecated - use openNewConnection instead
   */
  async connect(): Promise<Connection> {
    return this.openNewConnection()
  }
}

function createIframeElement(): HTMLIFrameElement {
  const iframeElement = document.createElement('iframe')
  iframeElement.style.position = 'absolute'
  iframeElement.style.top = '-100'
  iframeElement.style.left = '-100'
  iframeElement.style.width = '1'
  iframeElement.style.height = '1'
  iframeElement.style.border = 'none'
  iframeElement.style.backgroundColor = 'transparent'
  document.body.appendChild(iframeElement)
  return iframeElement
}
