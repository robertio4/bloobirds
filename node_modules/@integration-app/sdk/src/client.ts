import Pusher, { Channel } from 'pusher-js'
import Axios, { AxiosRequestConfig } from 'axios'
import _ from 'lodash'
import {
  ConnectionAccessor,
  ConnectionsAccessor,
} from './connections/accessors'
import {
  FlowInstanceAccessor,
  FlowAccessor,
  FlowInstancesAccessor,
  FlowsAccessor,
} from './flows/accessors'
import { buildUserFriendlyErrorMessage, getErrorFromData } from './errors'
import { isJWT } from './jwt'
import { FlowRunAccessor, FlowRunsAccessor } from './flow-runs'
import {
  DataLinkTableInstanceAccessor,
  DataLinkTableAccessor,
  DataLinkTableInstancesAccessor,
  DataLinkTablesAccessor,
} from './data-links/accessors'
import {
  IntegrationsAccessor,
  IntegrationAccessor,
} from './integrations/accessors'
import {
  FieldMappingAccessor,
  FieldMappingInstanceAccessor,
  FieldMappingsAccessor,
  FieldMappingInstancesAccessor,
} from './field-mappings/accessors'
import {
  DataSourceInstancesAccessor,
  DataSourceInstanceAccessor,
} from './data-sources/accessors'
import { FlowInstanceSelector } from './flows/api'
import { FieldMappingInstanceSelector } from './field-mappings/api'
import { DataSourceInstanceSelector } from './data-sources/api'
import { DataLinkTableInstanceSelector } from './data-links/api'
import {
  AppEventSubscriptionAccessor,
  AppEventSubscriptionsAccessor,
  AppEventTypeAccessor,
  AppEventTypesAccessor,
} from './app-events/accessors'
import { AppEventSubscriptionSelector } from './app-events/api'
import {
  AppDataCollectionsAccessor,
  AppDataCollectionAccessor,
  AppDataCollectionInstancesAccessor,
  AppDataCollectionInstanceAccessor,
} from './app-data-collections/accessors'
import { AppDataCollectionInstanceSelector } from './app-data-collections/api'
import {
  AppDataSchemasAccessor,
  AppDataSchemaAccessor,
  AppDataSchemaInstancesAccessor,
} from './app-data-schemas/accessors'
import { SelfAccessor } from './auth/accessors'
import { DataLocationSelector } from './data-locations/api'
import { DataLocationAccessor } from './data-locations/accessors'

const DEFAULT_API_URI = 'https://engine-api.integration.app'
const DEFAULT_UI_URI = 'https://ui.integration.app'

export class IntegrationAppClient {
  public apiUri?: string
  public uiUri?: string
  public token: string
  private pusher: Pusher | undefined
  private pusherChannels: Record<string, Channel> = {}

  constructor(options: IntegrationAppClientOptions) {
    this.init(options)
  }

  public async get(uri: string, queryParams?: Record<string, any>) {
    if (queryParams) {
      uri += `?${new URLSearchParams(queryParams).toString()}`
    }
    return this.makeApiRequest('GET', { url: uri })
  }

  public async post(uri: string, data?: any) {
    return this.makeApiRequest('POST', { url: uri, data })
  }

  public async put(uri: string, data?: any) {
    return this.makeApiRequest('PUT', { url: uri, data })
  }

  public async patch(uri: string, data?: any) {
    return this.makeApiRequest('PATCH', { url: uri, data })
  }

  public async delete(uri: string) {
    return this.makeApiRequest('DELETE', { url: uri })
  }

  get self(): SelfAccessor {
    return new SelfAccessor(this)
  }

  get flows(): FlowsAccessor {
    return new FlowsAccessor(this)
  }

  /**
   * @group Accessors
   */
  flow(keyOrId: string): FlowAccessor {
    return new FlowAccessor(this, keyOrId)
  }

  get flowInstances(): FlowInstancesAccessor {
    return new FlowInstancesAccessor(this)
  }

  /**
   * @group Accessors
   */
  flowInstance(selector: string | FlowInstanceSelector): FlowInstanceAccessor {
    return new FlowInstanceAccessor(this, selector)
  }

  get dataSources(): DataSourceInstancesAccessor {
    return new DataSourceInstancesAccessor(this)
  }

  /**
   * @group Accessors
   */
  dataSource(
    selector: string | DataSourceInstanceSelector,
  ): DataSourceInstanceAccessor {
    return new DataSourceInstanceAccessor(this, selector)
  }

  get dataSourceInstances(): DataSourceInstancesAccessor {
    return new DataSourceInstancesAccessor(this)
  }

  /**
   * @group Accessors
   */
  dataSourceInstance(
    selector: string | DataSourceInstanceSelector,
  ): DataSourceInstanceAccessor {
    return new DataSourceInstanceAccessor(this, selector)
  }

  get fieldMappings(): FieldMappingsAccessor {
    return new FieldMappingsAccessor(this)
  }
  /**
   * @group Accessors
   */
  fieldMapping(idOrKey: string): FieldMappingAccessor {
    return new FieldMappingAccessor(this, idOrKey)
  }

  get fieldMappingInstances(): FieldMappingInstancesAccessor {
    return new FieldMappingInstancesAccessor(this)
  }

  /**
   * @group Accessors
   */
  fieldMappingInstance(
    selector: string | FieldMappingInstanceSelector,
  ): FieldMappingInstanceAccessor {
    return new FieldMappingInstanceAccessor(this, selector)
  }

  get dataLinkTables(): DataLinkTablesAccessor {
    return new DataLinkTablesAccessor(this)
  }

  /**
   * @group Accessors
   */
  dataLinkTable(idOrKey: string): DataLinkTableAccessor {
    return new DataLinkTableAccessor(this, idOrKey)
  }

  get dataLinkTableInstances(): DataLinkTableInstancesAccessor {
    return new DataLinkTableInstancesAccessor(this)
  }

  /**
   * @group Accessors
   */
  dataLinkTableInstance(
    selector: string | DataLinkTableInstanceSelector,
  ): DataLinkTableInstanceAccessor {
    return new DataLinkTableInstanceAccessor(this, selector)
  }

  get integrations(): IntegrationsAccessor {
    return new IntegrationsAccessor(this)
  }

  /**
   * @group Accessors
   */
  integration(identifier: string): IntegrationAccessor {
    return new IntegrationAccessor(this, identifier)
  }

  get connections(): ConnectionsAccessor {
    return new ConnectionsAccessor(this)
  }

  /**
   * @group Accessors
   */
  connection(id: string): ConnectionAccessor {
    return new ConnectionAccessor(this, id)
  }

  dataLocation(selector: DataLocationSelector): DataLocationAccessor {
    return new DataLocationAccessor(this, selector)
  }

  get appEventTypes(): AppEventTypesAccessor {
    return new AppEventTypesAccessor(this)
  }

  /**
   * @group Accessors
   */
  appEventType(idOrKey: string): AppEventTypeAccessor {
    return new AppEventTypeAccessor(this, idOrKey)
  }

  get appEventSubscriptions(): AppEventSubscriptionsAccessor {
    return new AppEventSubscriptionsAccessor(this)
  }

  /**
   * @group Accessors
   */
  appEventSubscription(
    selector: string | AppEventSubscriptionSelector,
  ): AppEventSubscriptionAccessor {
    return new AppEventSubscriptionAccessor(this, selector)
  }

  get flowRuns(): FlowRunsAccessor {
    return new FlowRunsAccessor(this)
  }

  /**
   * @group Accessors
   */
  flowRun(id: string): FlowRunAccessor {
    return new FlowRunAccessor(this, id)
  }

  get appDataCollections(): AppDataCollectionsAccessor {
    return new AppDataCollectionsAccessor(this)
  }

  /**
   * @group Accessors
   */
  appDataCollection(idOrKey: string): AppDataCollectionAccessor {
    return new AppDataCollectionAccessor(this, idOrKey)
  }

  get appDataCollectionInstances(): AppDataCollectionInstancesAccessor {
    return new AppDataCollectionInstancesAccessor(this)
  }

  /**
   * @group Accessors
   */
  appDataCollectionInstance(
    selector: string | AppDataCollectionInstanceSelector,
  ): AppDataCollectionInstanceAccessor {
    return new AppDataCollectionInstanceAccessor(this, selector)
  }

  get appDataSchemas(): AppDataSchemasAccessor {
    return new AppDataSchemasAccessor(this)
  }

  /**
   * @group Accessors
   */
  appDataSchema(idOrKey: string): AppDataSchemaAccessor {
    return new AppDataSchemaAccessor(this, idOrKey)
  }

  get appDataSchemaInstances(): AppDataSchemaInstancesAccessor {
    return new AppDataSchemaInstancesAccessor(this)
  }

  /**
   * @group Accessors
   */
  appDataSchemaInstance(
    selector: string | AppDataCollectionInstanceSelector,
  ): AppDataCollectionInstanceAccessor {
    return new AppDataCollectionInstanceAccessor(this, selector)
  }

  public init(options: IntegrationAppClientOptions) {
    const token = options.token ?? options.accessToken
    if (token !== undefined && !isJWT(token))
      throw new Error('Access token should be a valid JWT token')

    this.apiUri = options.apiUri || DEFAULT_API_URI
    this.uiUri = options.uiUri || DEFAULT_UI_URI
    this.token = token
  }

  public async subscribeToChannel(
    channelKey: string,
    options: SubscribeOptions,
  ): Promise<void> {
    if (!this.pusherChannels[channelKey]) {
      const pusher = await this.getPusherInstance()
      const newChannel = pusher.subscribe(channelKey)
      this.pusherChannels[channelKey] = newChannel
    }
    const channel = this.pusherChannels[channelKey]
    if (channel.subscribed) {
      options.onSubscribe && options.onSubscribe()
    } else {
      channel.bind(
        'pusher:subscription_succeeded',
        () => options.onSubscribe && options.onSubscribe(),
      )
    }
    if (options.onUpdate) {
      channel.bind('updated', options.onUpdate)
    }
  }

  public async unsubscribeFromChannel(channelKey: string): Promise<void> {
    if (this.pusherChannels[channelKey]) {
      const pusher = await this.getPusherInstance()
      pusher.unsubscribe(channelKey)
      delete this.pusherChannels[channelKey]
    }
  }

  public getEmbedUri(page: string, params?: any) {
    const embedUrl = new URL(`${this.uiUri}/embed/${page}`)

    if (this.token) {
      embedUrl.searchParams.set('token', this.token)
    }

    if (params) {
      for (const [key, value] of Object.entries(params)) {
        embedUrl.searchParams.set(key, value as string)
      }
    }

    return embedUrl.href
  }

  public async getPusherInstance(): Promise<Pusher> {
    if (!this.pusher) {
      const { key, cluster } = await this.get('pusher/config')
      this.pusher = new Pusher(key, {
        cluster: cluster,
        authEndpoint: this.apiUri + '/pusher/auth',
        auth: { headers: { Authorization: `Bearer ${this.token}` } },
      })
    }
    return this.pusher
  }

  public async connectionRequest(
    connectionId: string,
    uri: string,
    data?: any,
  ): Promise<any> {
    return this.post(`connections/${connectionId}/execute-request`, {
      key: uri,
      payload: data,
    })
  }

  private handleRequestError(err) {
    if (Axios.isAxiosError(err) && err.response?.data?.type) {
      console.error(
        buildUserFriendlyErrorMessage(
          'Integration.app API Request Error',
          err.response.data,
        ),
      )

      throw getErrorFromData(err.response.data)
    }
    throw err
  }

  private async makeApiRequest(
    method: HttpMethod,
    params: Partial<AxiosRequestConfig> = {},
  ) {
    params.method = method
    params.baseURL = this.apiUri
    params.headers = {
      ...(params.headers || {}),
      Authorization: `Bearer ${this.token}`,
    }
    let response
    try {
      response = await Axios.request(params)
    } catch (err) {
      this.handleRequestError(err)
    }
    return response.data
  }
}

export interface NewImportOptions {
  schema: any
  onData: (...args: any) => void
  onClose?: (...args: any) => void
}

export interface OpenFlowConfigurationOptions {
  onClose?: (...args: any) => void
}

interface ConnectionOptions {
  onSuccess?: (connection: any) => void
  onClose?: () => void
}

export interface NewConnectionOptions extends ConnectionOptions {
  integrationKey: string
  connectorKey: string
}

export interface RefreshConnectionOptions extends ConnectionOptions {
  connectionId: string
}

export interface IntegrationAppClientOptions {
  token?: string
  apiUri?: string
  uiUri?: string
  /**
   * @deprecated
   */
  accessToken?: string
}

export interface SubscribeOptions {
  onSubscribe?: () => void
  onUpdate?: (update?: any) => void
}

type HttpMethod = 'GET' | 'POST' | 'DELETE' | 'PUT' | 'PATCH'
