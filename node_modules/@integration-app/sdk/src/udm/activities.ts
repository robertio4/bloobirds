import { Static, Type } from '@sinclair/typebox'
import { UnifiedDataModel } from './base'

export const FIELDS_SCHEMA = Type.Partial(
  Type.Object({
    title: Type.String(),
    description: Type.String(),
    type: Type.String(),
    durationSeconds: Type.Number(),
    location: Type.String(),
    isRecurrent: Type.Boolean(),
    participants: Type.Array(
      Type.Object({
        userId: Type.String(),
        contactId: Type.String(),
      }),
    ),
    status: Type.String(),
    contactId: Type.String({
      referenceUdm: 'contacts',
    }),
    companyId: Type.String({
      referenceUdm: 'companies',
    }),
    dealId: Type.String({
      referenceUdm: 'deals',
    }),
    leadId: Type.String({
      referenceUdm: 'leads',
    }),
    ownerId: Type.String({
      referenceUdm: 'users',
    }),
    startTime: Type.String({ format: 'date-time' }),
    endTime: Type.String({ format: 'date-time' }),
    dueTime: Type.String({ format: 'date-time' }),
    createdTime: Type.String({ format: 'date-time' }),
    createdBy: Type.String({
      referenceUdm: 'users',
    }),
    updatedTime: Type.String({ format: 'date-time' }),
    updatedBy: Type.String({
      referenceUdm: 'users',
    }),
  }),
)

export type UnifiedActivityFields = Static<typeof FIELDS_SCHEMA>

const udm: UnifiedDataModel = {
  singularName: 'activity',
  pluralName: 'activities',
  fieldsSchema: FIELDS_SCHEMA,
  create: {
    excludedFields: ['createdTime', 'createdBy', 'updatedTime', 'updatedBy'],
  },
  update: {
    excludedFields: ['createdTime', 'createdBy', 'updatedTime', 'updatedBy'],
  },
  populateFields,
}

export default udm

function populateFields(fields: UnifiedActivityFields): UnifiedActivityFields {
  const result = JSON.parse(JSON.stringify(fields))
  /*
   * If Due Date is empty, set it into End Date (if set) or Start Date
   * If Start Date is empty, set it into Due Date or End Date
   * If End Date is empty, set it into Due Date or Start Date
   */
  if (!result.dueTime) {
    result.dueTime = result.endTime || result.startTime
  }
  if (!result.startTime) {
    result.startTime = result.dueTime || result.endTime
  }
  if (!result.endTime) {
    result.endTime = result.dueTime || result.startTime
  }

  return result
}
