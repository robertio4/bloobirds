/*
Originally created by Aspecto folks: https://github.com/aspecto-io/genson-js.

We added a few modifications:
 * Ignore null schemas when combining schemas.
 * Always ignore `required`.
*/
function createSchemaFor(value: any): any {
  switch (typeof value) {
    case 'number':
      if (Number.isInteger(value)) {
        return { type: 'integer' }
      }
      return { type: 'number' }
    case 'boolean':
      return { type: 'boolean' }
    case 'string':
      return { type: 'string' }
    case 'object':
      if (value === null) {
        return {}
      }
      if (Array.isArray(value)) {
        return createSchemaForArray(value)
      }
      return createSchemaForObject(value)
    default:
      return null
  }
}

function createSchemaForArray(arr: Array<any>): any {
  if (arr.length === 0) {
    return { type: 'array' }
  }
  const elementSchemas = arr.map((value) => createSchemaFor(value))
  const items = combineSchemas(elementSchemas)
  return { type: 'array', items }
}

function createSchemaForObject(obj: Record<string, any>): any {
  const keys = Object.keys(obj)
  if (keys.length === 0) {
    return {
      type: 'object',
    }
  }
  const properties = Object.entries(obj).reduce((props, [key, val]) => {
    props[key] = createSchemaFor(val)
    return props
  }, {})

  const schema: any = { type: 'object', properties }
  return schema
}

function combineSchemas(schemas: any[]): any {
  const schemasByType: Record<string, any[]> = {
    undefined: [],
    ['null']: [],
    ['boolean']: [],
    ['integer']: [],
    ['number']: [],
    ['string']: [],
    ['array']: [],
    ['object']: [],
  }

  const unwrappedSchemas = unwrapSchemas(schemas)
  for (const unwrappedSchema of unwrappedSchemas) {
    const type = unwrappedSchema.type
    schemasByType[type].push(unwrappedSchema)
  }

  if (schemasByType['number'].length > 0) {
    // if at least one value is number, other integers can be numbers too
    schemasByType['number'].push(
      ...schemasByType['integer'].map((r) => ({
        ...r,
        type: 'number',
      })),
    )
    delete schemasByType['integer']
  }

  const resultSchemasByType: Record<string, any> = {
    ['null']: combineSameTypeScalarSchemas(schemasByType['null']),
    ['boolean']: combineSameTypeScalarSchemas(schemasByType['boolean']),
    ['number']: combineSameTypeScalarSchemas(schemasByType['number']),
    ['integer']: combineSameTypeScalarSchemas(schemasByType['integer']),
    ['string']: combineSameTypeScalarSchemas(schemasByType['string']),
    ['array']: combineArraySchemas(schemasByType['array']),
    ['object']: combineObjectSchemas(schemasByType['object']),
  }

  const schemasFound = Object.values(resultSchemasByType).filter(Boolean)
  const multiType = schemasFound.length > 1
  if (multiType) {
    const wrapped = wrapAnyOfSchema({ anyOf: schemasFound })
    return wrapped
  }
  return schemasFound[0] as any
}

function combineSameTypeScalarSchemas(schemas: any[]): any {
  if (!schemas || schemas.length === 0) {
    return undefined
  }

  const schema = <any>{
    type: schemas[0].type,
  }

  addTitleFromSourceSchemas(schema, schemas)

  return schema
}

function combineArraySchemas(schemas: any[]): any {
  if (!schemas || schemas.length === 0) {
    return undefined
  }
  const itemSchemas: any[] = []
  for (const schema of schemas) {
    if (!schema.items) continue
    const unwrappedSchemas = unwrapSchema(schema.items)
    itemSchemas.push(...unwrappedSchemas)
  }

  const schema = <any>{
    type: 'array',
  }
  addTitleFromSourceSchemas(schema, schemas)

  if (itemSchemas.length > 0) {
    schema.items = combineSchemas(itemSchemas)
  }
  return schema
}

function combineObjectSchemas(schemas: any[]): any {
  if (!schemas || schemas.length === 0) {
    return undefined
  }
  const allPropSchemas = schemas.map((s) => s.properties).filter(Boolean)
  const schemasByProp: Record<string, any[]> = Object.create(null)
  // const schemasByProp: Record<string, any[]> = {};
  for (const propSchemas of allPropSchemas) {
    for (const [prop, schema] of Object.entries(propSchemas)) {
      if (!schemasByProp[prop]) {
        schemasByProp[prop] = []
      }
      const unwrappedSchemas = unwrapSchema(schema)
      schemasByProp[prop].push(...unwrappedSchemas)
    }
  }

  const properties: Record<string, any> = Object.entries(schemasByProp).reduce(
    (props, [prop, schemas]) => {
      if (schemas.length === 1) {
        props[prop] = schemas[0]
      } else {
        props[prop] = combineSchemas(schemas)
      }
      return props
    },
    {},
  )

  const combinedSchema: any = {
    type: 'object',
  }
  addTitleFromSourceSchemas(combinedSchema, schemas)

  if (Object.keys(properties).length > 0) {
    combinedSchema.properties = properties
  }

  return combinedSchema
}

export function unwrapSchema(schema: any): any[] {
  if (!schema) return []
  if (schema.anyOf) {
    return unwrapSchemas(schema.anyOf)
  }
  if (Array.isArray(schema.type)) {
    return schema.type.map((x) => ({ type: x }))
  }
  return [schema]
}

export function unwrapSchemas(schemas: any[]): any[] {
  if (!schemas || schemas.length === 0) return []
  const unwrappedSchemas = schemas.flatMap((schema) => unwrapSchema(schema))
  return unwrappedSchemas
}

export function wrapAnyOfSchema(schema: any): any {
  const simpleSchemas = []
  const complexSchemas = []
  for (const subSchema of schema.anyOf) {
    if (Array.isArray(subSchema.type)) {
      simpleSchemas.push(...subSchema.type)
    } else if (isSimpleSchema(subSchema)) {
      simpleSchemas.push((subSchema as any).type)
    } else {
      complexSchemas.push(subSchema)
    }
  }
  if (complexSchemas.length === 0) {
    return { type: simpleSchemas }
  }
  const anyOf = []
  if (simpleSchemas.length > 0) {
    anyOf.push({
      type: simpleSchemas.length > 1 ? simpleSchemas : simpleSchemas[0],
    })
  }
  anyOf.push(...complexSchemas)
  return { anyOf }
}

function isSimpleSchema(schema: any): boolean {
  const keys = Object.keys(schema)
  return keys.length === 1 && keys[0] === 'type'
}

// FACADE

export function createSchema(value: any): any {
  if (typeof value === 'undefined') value = null
  const clone = JSON.parse(JSON.stringify(value))
  return createSchemaFor(clone)
}

export function mergeSchemas(schemas: any[]): any {
  const mergedSchema = combineSchemas(schemas)
  return mergedSchema
}

export function extendSchema(schema: any, value: any): any {
  const valueSchema = createSchema(value)
  const mergedSchema = combineSchemas([schema, valueSchema])
  return mergedSchema
}

export function createCompoundSchema(values: any[]): any {
  const schemas = values.map((value) => createSchema(value))
  return mergeSchemas(schemas)
}

function addTitleFromSourceSchemas(schema: any, schemas: any[]) {
  const title = schemas.filter((s) => !!s.title)[0]?.title
  if (title) {
    schema.title = title
  }
}
