export enum JSONSchemaType {
  Null = 'null',
  Boolean = 'boolean',
  Integer = 'integer',
  Number = 'number',
  String = 'string',
  Object = 'object',
  Array = 'array',
}

export type JSONSchemaTypeStr =
  | 'null'
  | 'boolean'
  | 'integer'
  | 'number'
  | 'string'
  | 'object'
  | 'array'

export type JSONSchema = {
  type?: JSONSchemaTypeStr | JSONSchemaTypeStr[]
  items?: JSONSchema
  maxItems?: number // Maximum observed number of items in an array
  properties?: Record<string, JSONSchema>
  required?: string[]
  anyOf?: Array<JSONSchema>
  examples?: any[] // Examples of values (only for scalars)
  title?: string
  enum?: any[]
  format?: string
  $ref?: string
}

export type SchemaComparisonOptions = {
  ignoreRequired: boolean
}

/**
 * Returns fields that are present in the `first` schema, but absent in the `second` schema.
 * Does not distinguish between types, i.e. `schemaDiff({type: 'string'}, {type: 'number'}) === null`.
 *
 * @param first
 * @param second
 */
export function schemaDiff(first: JSONSchema, second: JSONSchema): JSONSchema {
  if (!first) {
    return null
  } else if (first.type == JSONSchemaType.Object && first.properties) {
    if (second?.type == JSONSchemaType.Object && second.properties) {
      const diff: JSONSchema = {
        type: JSONSchemaType.Object,
        properties: {},
      }
      Object.keys(first.properties).forEach((key) => {
        const keyDiff = schemaDiff(
          first.properties[key],
          second.properties[key],
        )
        if (keyDiff) {
          diff.properties[key] = keyDiff
        }
      })
      return Object.keys(diff.properties).length > 0 ? diff : null
    } else {
      // `first` is object ,but `second` is not object,
      // so the whole `first` is missing.
      return first
    }
  } else if (first.type == JSONSchemaType.Array && first.items) {
    if (second?.type == JSONSchemaType.Array && second.items) {
      const itemsDiff = schemaDiff(first.items, second.items)
      if (itemsDiff) {
        return {
          type: JSONSchemaType.Array,
          items: itemsDiff,
        }
      } else {
        return null
      }
    } else {
      return first
    }
  } else {
    // Neither object nor array.
    if (second) {
      // As long as second is not empty, there is no difference.
      return null
    } else {
      // Otherwise the whole `first` is a difference
      return first
    }
  }
}

export function isScalar(schema) {
  return (
    schema.type != 'array' && schema.type != 'object' && schema.type != 'null'
  )
}

export function schemaTypeFromValue(value: any) {
  switch (typeof value) {
    case 'object':
      if (Array.isArray(value)) {
        return 'array'
      } else if (value === null) {
        return 'null'
      } else {
        return 'object'
      }
    case 'boolean':
      return 'boolean'
    case 'bigint':
    case 'number':
      return 'number'
    default:
      return 'string'
  }
}

/**
 * Extract `default` values from the whole schema.
 */
export function getDefaultsFromSchema(schema) {
  if (schema?.type === 'object' && schema.properties) {
    const propDefaults = {}
    for (const [key, value] of Object.entries(schema.properties)) {
      const defaults = getDefaultsFromSchema(value)
      if (defaults !== null && defaults !== undefined) {
        propDefaults[key] = defaults
      }
    }
    if (Object.keys(propDefaults).length > 0) {
      return propDefaults
    } else {
      return undefined
    }
  } else {
    return schema?.default
  }
}

/**
 * Normalizes value to a provided schema by
 * converting scalars (strings, numbers, booleans) to each other whenever possible
 * and ignoring fields that are not in schema.
 */
export function valueToSchema(value: any, schema: any, field = '') {
  function throwError(message) {
    throw new Error(`${message}${field ? ` for field ${field}` : ''}`)
  }

  if (value === null || value === undefined) {
    return undefined
  }

  switch (schema?.type) {
    case 'string':
      return value?.toString()
    case 'integer':
    case 'number':
      const result = Number(value)
      if (isNaN(result)) {
        throwError(`Cannot convert "${value}" to number`)
      }
      if (schema.type === 'integer' && !Number.isInteger(result)) {
        throwError(`Expected integer but got ${value}`)
      }
      return result
    case 'boolean':
      if (typeof value === 'boolean') {
        return value
      } else if (typeof value === 'string') {
        if (value === 'true') {
          return true
        } else if (value === 'false') {
          return false
        } else {
          throwError(`Expected true or false but got "${value}"`)
        }
      } else if (value) {
        throwError(`Expected true or false but got "${value}"`)
      }
      return undefined
    case 'list':
      if (Array.isArray(value)) {
        return value.map((item) => valueToSchema(item, schema.items, field))
      } else {
        return undefined
      }
    case 'object':
      if (typeof value === 'object' && value) {
        const result = {}
        for (const [key, fieldValue] of Object.entries(value)) {
          const fieldSchema = schema?.properties?.[key]

          if (!fieldSchema && schema && !schema.additionalProperties) {
            // Property is not in schema - ignore it
            continue
          }

          result[key] = valueToSchema(
            fieldValue,
            fieldSchema,
            field ? `${field}.${key}` : key,
          )
        }
        return result
      } else {
        return undefined
      }
    default:
      return value
  }
}
