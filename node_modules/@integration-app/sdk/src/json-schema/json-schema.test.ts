import {
  getDefaultsFromSchema,
  JSONSchemaType,
  schemaDiff,
  valueToSchema,
} from '.'

describe('JSONSchema', () => {
  describe('schemaDiff', () => {
    it('should return null if schemas are matching', () => {
      expect(
        schemaDiff(
          { type: JSONSchemaType.String },
          { type: JSONSchemaType.String },
        ),
      ).toBeNull()
    })

    it('should return first schema if the second is empty', () => {
      expect(schemaDiff({ type: JSONSchemaType.String }, null)).toEqual({
        type: JSONSchemaType.String,
      })
    })

    it('should return null if the first is empty', () => {
      expect(schemaDiff(null, { type: JSONSchemaType.String })).toBeNull()
    })

    it('should calculate diff for an object', () => {
      expect(
        schemaDiff(
          {
            type: JSONSchemaType.Object,
            properties: {
              property1: { type: JSONSchemaType.String },
              property2: { type: JSONSchemaType.String },
            },
          },
          {
            type: JSONSchemaType.Object,
            properties: {
              property1: { type: JSONSchemaType.String },
            },
          },
        ),
      ).toEqual({
        type: JSONSchemaType.Object,
        properties: {
          property2: { type: JSONSchemaType.String },
        },
      })
    })

    it('should calculate diff for an array of objects', () => {
      expect(
        schemaDiff(
          {
            type: JSONSchemaType.Array,
            items: {
              type: JSONSchemaType.Object,
              properties: {
                property1: { type: JSONSchemaType.String },
                property2: { type: JSONSchemaType.String },
              },
            },
          },
          {
            type: JSONSchemaType.Array,
            items: {
              type: JSONSchemaType.Object,
              properties: {
                property1: { type: JSONSchemaType.String },
              },
            },
          },
        ),
      ).toEqual({
        type: JSONSchemaType.Array,
        items: {
          type: JSONSchemaType.Object,
          properties: {
            property2: { type: JSONSchemaType.String },
          },
        },
      })
    })

    it('should calculate diff for a complex schema', () => {
      const diff = schemaDiff(
        {
          type: JSONSchemaType.Object,
          properties: {
            property1: { type: JSONSchemaType.Number },
            property2: { type: JSONSchemaType.String },
            arrayProperty: {
              type: JSONSchemaType.Array,
              items: {
                type: JSONSchemaType.Object,
                properties: {
                  arrayProperty1: { type: JSONSchemaType.String },
                  arrayProperty2: { type: JSONSchemaType.String },
                },
              },
            },
          },
        },
        {
          type: JSONSchemaType.Object,
          properties: {
            property1: { type: JSONSchemaType.String },
            arrayProperty: {
              type: JSONSchemaType.Array,
              items: {
                type: JSONSchemaType.Object,
                properties: {
                  arrayProperty1: { type: JSONSchemaType.String },
                },
              },
            },
          },
        },
      )

      expect(diff).toEqual({
        type: JSONSchemaType.Object,
        properties: {
          property2: { type: JSONSchemaType.String },
          arrayProperty: {
            type: JSONSchemaType.Array,
            items: {
              type: JSONSchemaType.Object,
              properties: {
                arrayProperty2: { type: JSONSchemaType.String },
              },
            },
          },
        },
      })
    })
  })

  describe('getDefaultsFromSchema', () => {
    it('should return null for empty schema', () => {
      expect(getDefaultsFromSchema(null)).toBeUndefined()
    })

    it('should return null for schema without defaults', () => {
      expect(
        getDefaultsFromSchema({
          type: 'object',
          properties: {
            key: { type: 'string' },
          },
        }),
      ).toBeUndefined()
    })

    it('should return default for a scalar schema', () => {
      expect(
        getDefaultsFromSchema({
          type: 'string',
          default: 'value',
        }),
      ).toEqual('value')
    })

    it('should return default if it is false', () => {
      expect(
        getDefaultsFromSchema({
          type: 'boolean',
          default: false,
        }),
      ).toBe(false)
    })

    it('should return default for a complex object', () => {
      expect(
        getDefaultsFromSchema({
          type: 'object',
          properties: {
            key: {
              type: 'string',
              default: 'keyValue',
            },
            objKey: {
              type: 'object',
              properties: {
                subKey: {
                  type: 'string',
                  default: 'subKeyValue',
                },
              },
            },
          },
        }),
      ).toEqual({
        key: 'keyValue',
        objKey: {
          subKey: 'subKeyValue',
        },
      })
    })
  })
})

describe('valueToSchema', () => {
  it('should ignore object keys that are not in schema', () => {
    expect(
      valueToSchema(
        {
          key1: 'value1',
          key2: 'value2',
        },
        {
          type: 'object',
          properties: {
            key1: { type: 'string' },
          },
        },
      ),
    ).toEqual({
      key1: 'value1',
    })
  })

  it('should not ignore object keys if additionalProperties is set', () => {
    expect(
      valueToSchema(
        {
          key1: 'value1',
          key2: 'value2',
        },
        {
          type: 'object',
          properites: {
            key1: { type: 'string' },
          },
          additionalProperties: true,
        },
      ),
    ).toEqual({
      key1: 'value1',
      key2: 'value2',
    })
  })
})
