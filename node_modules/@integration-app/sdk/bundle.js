(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.iApp = factory());
}(this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics = function(d, b) {
	    extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	    return extendStatics(d, b);
	};

	function __extends(d, b) {
	    if (typeof b !== "function" && b !== null)
	        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    extendStatics(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign = function() {
	    __assign = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};

	function __rest(s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	}

	function __decorate(decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	}

	function __param(paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	}

	function __metadata(metadataKey, metadataValue) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
	}

	function __awaiter(thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	}

	function __generator(thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	}

	var __createBinding = Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	});

	function __exportStar(m, o) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
	}

	function __values(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	}

	function __read(o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	}

	/** @deprecated */
	function __spread() {
	    for (var ar = [], i = 0; i < arguments.length; i++)
	        ar = ar.concat(__read(arguments[i]));
	    return ar;
	}

	/** @deprecated */
	function __spreadArrays() {
	    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
	    for (var r = Array(s), k = 0, i = 0; i < il; i++)
	        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
	            r[k] = a[j];
	    return r;
	}

	function __spreadArray(to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	}

	function __await(v) {
	    return this instanceof __await ? (this.v = v, this) : new __await(v);
	}

	function __asyncGenerator(thisArg, _arguments, generator) {
	    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	    var g = generator.apply(thisArg, _arguments || []), i, q = [];
	    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
	    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
	    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
	    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
	    function fulfill(value) { resume("next", value); }
	    function reject(value) { resume("throw", value); }
	    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
	}

	function __asyncDelegator(o) {
	    var i, p;
	    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
	    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
	}

	function __asyncValues(o) {
	    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	    var m = o[Symbol.asyncIterator], i;
	    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
	    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
	    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
	}

	function __makeTemplateObject(cooked, raw) {
	    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
	    return cooked;
	}
	var __setModuleDefault = Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	};

	function __importStar(mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	}

	function __importDefault(mod) {
	    return (mod && mod.__esModule) ? mod : { default: mod };
	}

	function __classPrivateFieldGet(receiver, state, kind, f) {
	    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
	}

	function __classPrivateFieldSet(receiver, state, value, kind, f) {
	    if (kind === "m") throw new TypeError("Private method is not writable");
	    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
	}

	var tslib_es6 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		__extends: __extends,
		get __assign () { return __assign; },
		__rest: __rest,
		__decorate: __decorate,
		__param: __param,
		__metadata: __metadata,
		__awaiter: __awaiter,
		__generator: __generator,
		__createBinding: __createBinding,
		__exportStar: __exportStar,
		__values: __values,
		__read: __read,
		__spread: __spread,
		__spreadArrays: __spreadArrays,
		__spreadArray: __spreadArray,
		__await: __await,
		__asyncGenerator: __asyncGenerator,
		__asyncDelegator: __asyncDelegator,
		__asyncValues: __asyncValues,
		__makeTemplateObject: __makeTemplateObject,
		__importStar: __importStar,
		__importDefault: __importDefault,
		__classPrivateFieldGet: __classPrivateFieldGet,
		__classPrivateFieldSet: __classPrivateFieldSet
	});

	var pusher = createCommonjsModule(function (module, exports) {
	/*!
	 * Pusher JavaScript Library v7.0.3
	 * https://pusher.com/
	 *
	 * Copyright 2020, Pusher
	 * Released under the MIT licence.
	 */

	(function webpackUniversalModuleDefinition(root, factory) {
		module.exports = factory();
	})(window, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId]) {
	/******/ 			return installedModules[moduleId].exports;
	/******/ 		}
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			i: moduleId,
	/******/ 			l: false,
	/******/ 			exports: {}
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.l = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// define getter function for harmony exports
	/******/ 	__webpack_require__.d = function(exports, name, getter) {
	/******/ 		if(!__webpack_require__.o(exports, name)) {
	/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
	/******/ 		}
	/******/ 	};
	/******/
	/******/ 	// define __esModule on exports
	/******/ 	__webpack_require__.r = function(exports) {
	/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
	/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
	/******/ 		}
	/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
	/******/ 	};
	/******/
	/******/ 	// create a fake namespace object
	/******/ 	// mode & 1: value is a module id, require it
	/******/ 	// mode & 2: merge all properties of value into the ns
	/******/ 	// mode & 4: return value when already ns object
	/******/ 	// mode & 8|1: behave like require
	/******/ 	__webpack_require__.t = function(value, mode) {
	/******/ 		if(mode & 1) value = __webpack_require__(value);
	/******/ 		if(mode & 8) return value;
	/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
	/******/ 		var ns = Object.create(null);
	/******/ 		__webpack_require__.r(ns);
	/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
	/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
	/******/ 		return ns;
	/******/ 	};
	/******/
	/******/ 	// getDefaultExport function for compatibility with non-harmony modules
	/******/ 	__webpack_require__.n = function(module) {
	/******/ 		var getter = module && module.__esModule ?
	/******/ 			function getDefault() { return module['default']; } :
	/******/ 			function getModuleExports() { return module; };
	/******/ 		__webpack_require__.d(getter, 'a', getter);
	/******/ 		return getter;
	/******/ 	};
	/******/
	/******/ 	// Object.prototype.hasOwnProperty.call
	/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(__webpack_require__.s = 2);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ (function(module, exports, __webpack_require__) {

	// Copyright (C) 2016 Dmitry Chestnykh
	// MIT License. See LICENSE file for details.
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	 * Package base64 implements Base64 encoding and decoding.
	 */
	// Invalid character used in decoding to indicate
	// that the character to decode is out of range of
	// alphabet and cannot be decoded.
	var INVALID_BYTE = 256;
	/**
	 * Implements standard Base64 encoding.
	 *
	 * Operates in constant time.
	 */
	var Coder = /** @class */ (function () {
	    // TODO(dchest): methods to encode chunk-by-chunk.
	    function Coder(_paddingCharacter) {
	        if (_paddingCharacter === void 0) { _paddingCharacter = "="; }
	        this._paddingCharacter = _paddingCharacter;
	    }
	    Coder.prototype.encodedLength = function (length) {
	        if (!this._paddingCharacter) {
	            return (length * 8 + 5) / 6 | 0;
	        }
	        return (length + 2) / 3 * 4 | 0;
	    };
	    Coder.prototype.encode = function (data) {
	        var out = "";
	        var i = 0;
	        for (; i < data.length - 2; i += 3) {
	            var c = (data[i] << 16) | (data[i + 1] << 8) | (data[i + 2]);
	            out += this._encodeByte((c >>> 3 * 6) & 63);
	            out += this._encodeByte((c >>> 2 * 6) & 63);
	            out += this._encodeByte((c >>> 1 * 6) & 63);
	            out += this._encodeByte((c >>> 0 * 6) & 63);
	        }
	        var left = data.length - i;
	        if (left > 0) {
	            var c = (data[i] << 16) | (left === 2 ? data[i + 1] << 8 : 0);
	            out += this._encodeByte((c >>> 3 * 6) & 63);
	            out += this._encodeByte((c >>> 2 * 6) & 63);
	            if (left === 2) {
	                out += this._encodeByte((c >>> 1 * 6) & 63);
	            }
	            else {
	                out += this._paddingCharacter || "";
	            }
	            out += this._paddingCharacter || "";
	        }
	        return out;
	    };
	    Coder.prototype.maxDecodedLength = function (length) {
	        if (!this._paddingCharacter) {
	            return (length * 6 + 7) / 8 | 0;
	        }
	        return length / 4 * 3 | 0;
	    };
	    Coder.prototype.decodedLength = function (s) {
	        return this.maxDecodedLength(s.length - this._getPaddingLength(s));
	    };
	    Coder.prototype.decode = function (s) {
	        if (s.length === 0) {
	            return new Uint8Array(0);
	        }
	        var paddingLength = this._getPaddingLength(s);
	        var length = s.length - paddingLength;
	        var out = new Uint8Array(this.maxDecodedLength(length));
	        var op = 0;
	        var i = 0;
	        var haveBad = 0;
	        var v0 = 0, v1 = 0, v2 = 0, v3 = 0;
	        for (; i < length - 4; i += 4) {
	            v0 = this._decodeChar(s.charCodeAt(i + 0));
	            v1 = this._decodeChar(s.charCodeAt(i + 1));
	            v2 = this._decodeChar(s.charCodeAt(i + 2));
	            v3 = this._decodeChar(s.charCodeAt(i + 3));
	            out[op++] = (v0 << 2) | (v1 >>> 4);
	            out[op++] = (v1 << 4) | (v2 >>> 2);
	            out[op++] = (v2 << 6) | v3;
	            haveBad |= v0 & INVALID_BYTE;
	            haveBad |= v1 & INVALID_BYTE;
	            haveBad |= v2 & INVALID_BYTE;
	            haveBad |= v3 & INVALID_BYTE;
	        }
	        if (i < length - 1) {
	            v0 = this._decodeChar(s.charCodeAt(i));
	            v1 = this._decodeChar(s.charCodeAt(i + 1));
	            out[op++] = (v0 << 2) | (v1 >>> 4);
	            haveBad |= v0 & INVALID_BYTE;
	            haveBad |= v1 & INVALID_BYTE;
	        }
	        if (i < length - 2) {
	            v2 = this._decodeChar(s.charCodeAt(i + 2));
	            out[op++] = (v1 << 4) | (v2 >>> 2);
	            haveBad |= v2 & INVALID_BYTE;
	        }
	        if (i < length - 3) {
	            v3 = this._decodeChar(s.charCodeAt(i + 3));
	            out[op++] = (v2 << 6) | v3;
	            haveBad |= v3 & INVALID_BYTE;
	        }
	        if (haveBad !== 0) {
	            throw new Error("Base64Coder: incorrect characters for decoding");
	        }
	        return out;
	    };
	    // Standard encoding have the following encoded/decoded ranges,
	    // which we need to convert between.
	    //
	    // ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789  +   /
	    // Index:   0 - 25                    26 - 51              52 - 61   62  63
	    // ASCII:  65 - 90                    97 - 122             48 - 57   43  47
	    //
	    // Encode 6 bits in b into a new character.
	    Coder.prototype._encodeByte = function (b) {
	        // Encoding uses constant time operations as follows:
	        //
	        // 1. Define comparison of A with B using (A - B) >>> 8:
	        //          if A > B, then result is positive integer
	        //          if A <= B, then result is 0
	        //
	        // 2. Define selection of C or 0 using bitwise AND: X & C:
	        //          if X == 0, then result is 0
	        //          if X != 0, then result is C
	        //
	        // 3. Start with the smallest comparison (b >= 0), which is always
	        //    true, so set the result to the starting ASCII value (65).
	        //
	        // 4. Continue comparing b to higher ASCII values, and selecting
	        //    zero if comparison isn't true, otherwise selecting a value
	        //    to add to result, which:
	        //
	        //          a) undoes the previous addition
	        //          b) provides new value to add
	        //
	        var result = b;
	        // b >= 0
	        result += 65;
	        // b > 25
	        result += ((25 - b) >>> 8) & ((0 - 65) - 26 + 97);
	        // b > 51
	        result += ((51 - b) >>> 8) & ((26 - 97) - 52 + 48);
	        // b > 61
	        result += ((61 - b) >>> 8) & ((52 - 48) - 62 + 43);
	        // b > 62
	        result += ((62 - b) >>> 8) & ((62 - 43) - 63 + 47);
	        return String.fromCharCode(result);
	    };
	    // Decode a character code into a byte.
	    // Must return 256 if character is out of alphabet range.
	    Coder.prototype._decodeChar = function (c) {
	        // Decoding works similar to encoding: using the same comparison
	        // function, but now it works on ranges: result is always incremented
	        // by value, but this value becomes zero if the range is not
	        // satisfied.
	        //
	        // Decoding starts with invalid value, 256, which is then
	        // subtracted when the range is satisfied. If none of the ranges
	        // apply, the function returns 256, which is then checked by
	        // the caller to throw error.
	        var result = INVALID_BYTE; // start with invalid character
	        // c == 43 (c > 42 and c < 44)
	        result += (((42 - c) & (c - 44)) >>> 8) & (-INVALID_BYTE + c - 43 + 62);
	        // c == 47 (c > 46 and c < 48)
	        result += (((46 - c) & (c - 48)) >>> 8) & (-INVALID_BYTE + c - 47 + 63);
	        // c > 47 and c < 58
	        result += (((47 - c) & (c - 58)) >>> 8) & (-INVALID_BYTE + c - 48 + 52);
	        // c > 64 and c < 91
	        result += (((64 - c) & (c - 91)) >>> 8) & (-INVALID_BYTE + c - 65 + 0);
	        // c > 96 and c < 123
	        result += (((96 - c) & (c - 123)) >>> 8) & (-INVALID_BYTE + c - 97 + 26);
	        return result;
	    };
	    Coder.prototype._getPaddingLength = function (s) {
	        var paddingLength = 0;
	        if (this._paddingCharacter) {
	            for (var i = s.length - 1; i >= 0; i--) {
	                if (s[i] !== this._paddingCharacter) {
	                    break;
	                }
	                paddingLength++;
	            }
	            if (s.length < 4 || paddingLength > 2) {
	                throw new Error("Base64Coder: incorrect padding");
	            }
	        }
	        return paddingLength;
	    };
	    return Coder;
	}());
	exports.Coder = Coder;
	var stdCoder = new Coder();
	function encode(data) {
	    return stdCoder.encode(data);
	}
	exports.encode = encode;
	function decode(s) {
	    return stdCoder.decode(s);
	}
	exports.decode = decode;
	/**
	 * Implements URL-safe Base64 encoding.
	 * (Same as Base64, but '+' is replaced with '-', and '/' with '_').
	 *
	 * Operates in constant time.
	 */
	var URLSafeCoder = /** @class */ (function (_super) {
	    __extends(URLSafeCoder, _super);
	    function URLSafeCoder() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    // URL-safe encoding have the following encoded/decoded ranges:
	    //
	    // ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789  -   _
	    // Index:   0 - 25                    26 - 51              52 - 61   62  63
	    // ASCII:  65 - 90                    97 - 122             48 - 57   45  95
	    //
	    URLSafeCoder.prototype._encodeByte = function (b) {
	        var result = b;
	        // b >= 0
	        result += 65;
	        // b > 25
	        result += ((25 - b) >>> 8) & ((0 - 65) - 26 + 97);
	        // b > 51
	        result += ((51 - b) >>> 8) & ((26 - 97) - 52 + 48);
	        // b > 61
	        result += ((61 - b) >>> 8) & ((52 - 48) - 62 + 45);
	        // b > 62
	        result += ((62 - b) >>> 8) & ((62 - 45) - 63 + 95);
	        return String.fromCharCode(result);
	    };
	    URLSafeCoder.prototype._decodeChar = function (c) {
	        var result = INVALID_BYTE;
	        // c == 45 (c > 44 and c < 46)
	        result += (((44 - c) & (c - 46)) >>> 8) & (-INVALID_BYTE + c - 45 + 62);
	        // c == 95 (c > 94 and c < 96)
	        result += (((94 - c) & (c - 96)) >>> 8) & (-INVALID_BYTE + c - 95 + 63);
	        // c > 47 and c < 58
	        result += (((47 - c) & (c - 58)) >>> 8) & (-INVALID_BYTE + c - 48 + 52);
	        // c > 64 and c < 91
	        result += (((64 - c) & (c - 91)) >>> 8) & (-INVALID_BYTE + c - 65 + 0);
	        // c > 96 and c < 123
	        result += (((96 - c) & (c - 123)) >>> 8) & (-INVALID_BYTE + c - 97 + 26);
	        return result;
	    };
	    return URLSafeCoder;
	}(Coder));
	exports.URLSafeCoder = URLSafeCoder;
	var urlSafeCoder = new URLSafeCoder();
	function encodeURLSafe(data) {
	    return urlSafeCoder.encode(data);
	}
	exports.encodeURLSafe = encodeURLSafe;
	function decodeURLSafe(s) {
	    return urlSafeCoder.decode(s);
	}
	exports.decodeURLSafe = decodeURLSafe;
	exports.encodedLength = function (length) {
	    return stdCoder.encodedLength(length);
	};
	exports.maxDecodedLength = function (length) {
	    return stdCoder.maxDecodedLength(length);
	};
	exports.decodedLength = function (s) {
	    return stdCoder.decodedLength(s);
	};


	/***/ }),
	/* 1 */
	/***/ (function(module, exports, __webpack_require__) {

	// Copyright (C) 2016 Dmitry Chestnykh
	// MIT License. See LICENSE file for details.
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	 * Package utf8 implements UTF-8 encoding and decoding.
	 */
	var INVALID_UTF16 = "utf8: invalid string";
	var INVALID_UTF8 = "utf8: invalid source encoding";
	/**
	 * Encodes the given string into UTF-8 byte array.
	 * Throws if the source string has invalid UTF-16 encoding.
	 */
	function encode(s) {
	    // Calculate result length and allocate output array.
	    // encodedLength() also validates string and throws errors,
	    // so we don't need repeat validation here.
	    var arr = new Uint8Array(encodedLength(s));
	    var pos = 0;
	    for (var i = 0; i < s.length; i++) {
	        var c = s.charCodeAt(i);
	        if (c < 0x80) {
	            arr[pos++] = c;
	        }
	        else if (c < 0x800) {
	            arr[pos++] = 0xc0 | c >> 6;
	            arr[pos++] = 0x80 | c & 0x3f;
	        }
	        else if (c < 0xd800) {
	            arr[pos++] = 0xe0 | c >> 12;
	            arr[pos++] = 0x80 | (c >> 6) & 0x3f;
	            arr[pos++] = 0x80 | c & 0x3f;
	        }
	        else {
	            i++; // get one more character
	            c = (c & 0x3ff) << 10;
	            c |= s.charCodeAt(i) & 0x3ff;
	            c += 0x10000;
	            arr[pos++] = 0xf0 | c >> 18;
	            arr[pos++] = 0x80 | (c >> 12) & 0x3f;
	            arr[pos++] = 0x80 | (c >> 6) & 0x3f;
	            arr[pos++] = 0x80 | c & 0x3f;
	        }
	    }
	    return arr;
	}
	exports.encode = encode;
	/**
	 * Returns the number of bytes required to encode the given string into UTF-8.
	 * Throws if the source string has invalid UTF-16 encoding.
	 */
	function encodedLength(s) {
	    var result = 0;
	    for (var i = 0; i < s.length; i++) {
	        var c = s.charCodeAt(i);
	        if (c < 0x80) {
	            result += 1;
	        }
	        else if (c < 0x800) {
	            result += 2;
	        }
	        else if (c < 0xd800) {
	            result += 3;
	        }
	        else if (c <= 0xdfff) {
	            if (i >= s.length - 1) {
	                throw new Error(INVALID_UTF16);
	            }
	            i++; // "eat" next character
	            result += 4;
	        }
	        else {
	            throw new Error(INVALID_UTF16);
	        }
	    }
	    return result;
	}
	exports.encodedLength = encodedLength;
	/**
	 * Decodes the given byte array from UTF-8 into a string.
	 * Throws if encoding is invalid.
	 */
	function decode(arr) {
	    var chars = [];
	    for (var i = 0; i < arr.length; i++) {
	        var b = arr[i];
	        if (b & 0x80) {
	            var min = void 0;
	            if (b < 0xe0) {
	                // Need 1 more byte.
	                if (i >= arr.length) {
	                    throw new Error(INVALID_UTF8);
	                }
	                var n1 = arr[++i];
	                if ((n1 & 0xc0) !== 0x80) {
	                    throw new Error(INVALID_UTF8);
	                }
	                b = (b & 0x1f) << 6 | (n1 & 0x3f);
	                min = 0x80;
	            }
	            else if (b < 0xf0) {
	                // Need 2 more bytes.
	                if (i >= arr.length - 1) {
	                    throw new Error(INVALID_UTF8);
	                }
	                var n1 = arr[++i];
	                var n2 = arr[++i];
	                if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80) {
	                    throw new Error(INVALID_UTF8);
	                }
	                b = (b & 0x0f) << 12 | (n1 & 0x3f) << 6 | (n2 & 0x3f);
	                min = 0x800;
	            }
	            else if (b < 0xf8) {
	                // Need 3 more bytes.
	                if (i >= arr.length - 2) {
	                    throw new Error(INVALID_UTF8);
	                }
	                var n1 = arr[++i];
	                var n2 = arr[++i];
	                var n3 = arr[++i];
	                if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80 || (n3 & 0xc0) !== 0x80) {
	                    throw new Error(INVALID_UTF8);
	                }
	                b = (b & 0x0f) << 18 | (n1 & 0x3f) << 12 | (n2 & 0x3f) << 6 | (n3 & 0x3f);
	                min = 0x10000;
	            }
	            else {
	                throw new Error(INVALID_UTF8);
	            }
	            if (b < min || (b >= 0xd800 && b <= 0xdfff)) {
	                throw new Error(INVALID_UTF8);
	            }
	            if (b >= 0x10000) {
	                // Surrogate pair.
	                if (b > 0x10ffff) {
	                    throw new Error(INVALID_UTF8);
	                }
	                b -= 0x10000;
	                chars.push(String.fromCharCode(0xd800 | (b >> 10)));
	                b = 0xdc00 | (b & 0x3ff);
	            }
	        }
	        chars.push(String.fromCharCode(b));
	    }
	    return chars.join("");
	}
	exports.decode = decode;


	/***/ }),
	/* 2 */
	/***/ (function(module, exports, __webpack_require__) {

	// required so we don't have to do require('pusher').default etc.
	module.exports = __webpack_require__(3).default;


	/***/ }),
	/* 3 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
	__webpack_require__.r(__webpack_exports__);

	// CONCATENATED MODULE: ./src/runtimes/web/dom/script_receiver_factory.ts
	var ScriptReceiverFactory = (function () {
	    function ScriptReceiverFactory(prefix, name) {
	        this.lastId = 0;
	        this.prefix = prefix;
	        this.name = name;
	    }
	    ScriptReceiverFactory.prototype.create = function (callback) {
	        this.lastId++;
	        var number = this.lastId;
	        var id = this.prefix + number;
	        var name = this.name + '[' + number + ']';
	        var called = false;
	        var callbackWrapper = function () {
	            if (!called) {
	                callback.apply(null, arguments);
	                called = true;
	            }
	        };
	        this[number] = callbackWrapper;
	        return { number: number, id: id, name: name, callback: callbackWrapper };
	    };
	    ScriptReceiverFactory.prototype.remove = function (receiver) {
	        delete this[receiver.number];
	    };
	    return ScriptReceiverFactory;
	}());

	var ScriptReceivers = new ScriptReceiverFactory('_pusher_script_', 'Pusher.ScriptReceivers');

	// CONCATENATED MODULE: ./src/core/defaults.ts
	var Defaults = {
	    VERSION: "7.0.3",
	    PROTOCOL: 7,
	    wsPort: 80,
	    wssPort: 443,
	    wsPath: '',
	    httpHost: 'sockjs.pusher.com',
	    httpPort: 80,
	    httpsPort: 443,
	    httpPath: '/pusher',
	    stats_host: 'stats.pusher.com',
	    authEndpoint: '/pusher/auth',
	    authTransport: 'ajax',
	    activityTimeout: 120000,
	    pongTimeout: 30000,
	    unavailableTimeout: 10000,
	    cluster: 'mt1',
	    cdn_http: "http://js.pusher.com",
	    cdn_https: "https://js.pusher.com",
	    dependency_suffix: ""
	};
	/* harmony default export */ var defaults = (Defaults);

	// CONCATENATED MODULE: ./src/runtimes/web/dom/dependency_loader.ts


	var dependency_loader_DependencyLoader = (function () {
	    function DependencyLoader(options) {
	        this.options = options;
	        this.receivers = options.receivers || ScriptReceivers;
	        this.loading = {};
	    }
	    DependencyLoader.prototype.load = function (name, options, callback) {
	        var self = this;
	        if (self.loading[name] && self.loading[name].length > 0) {
	            self.loading[name].push(callback);
	        }
	        else {
	            self.loading[name] = [callback];
	            var request = runtime.createScriptRequest(self.getPath(name, options));
	            var receiver = self.receivers.create(function (error) {
	                self.receivers.remove(receiver);
	                if (self.loading[name]) {
	                    var callbacks = self.loading[name];
	                    delete self.loading[name];
	                    var successCallback = function (wasSuccessful) {
	                        if (!wasSuccessful) {
	                            request.cleanup();
	                        }
	                    };
	                    for (var i = 0; i < callbacks.length; i++) {
	                        callbacks[i](error, successCallback);
	                    }
	                }
	            });
	            request.send(receiver);
	        }
	    };
	    DependencyLoader.prototype.getRoot = function (options) {
	        var cdn;
	        var protocol = runtime.getDocument().location.protocol;
	        if ((options && options.useTLS) || protocol === 'https:') {
	            cdn = this.options.cdn_https;
	        }
	        else {
	            cdn = this.options.cdn_http;
	        }
	        return cdn.replace(/\/*$/, '') + '/' + this.options.version;
	    };
	    DependencyLoader.prototype.getPath = function (name, options) {
	        return this.getRoot(options) + '/' + name + this.options.suffix + '.js';
	    };
	    return DependencyLoader;
	}());
	/* harmony default export */ var dependency_loader = (dependency_loader_DependencyLoader);

	// CONCATENATED MODULE: ./src/runtimes/web/dom/dependencies.ts



	var DependenciesReceivers = new ScriptReceiverFactory('_pusher_dependencies', 'Pusher.DependenciesReceivers');
	var Dependencies = new dependency_loader({
	    cdn_http: defaults.cdn_http,
	    cdn_https: defaults.cdn_https,
	    version: defaults.VERSION,
	    suffix: defaults.dependency_suffix,
	    receivers: DependenciesReceivers
	});

	// CONCATENATED MODULE: ./src/core/utils/url_store.ts
	var urlStore = {
	    baseUrl: 'https://pusher.com',
	    urls: {
	        authenticationEndpoint: {
	            path: '/docs/authenticating_users'
	        },
	        javascriptQuickStart: {
	            path: '/docs/javascript_quick_start'
	        },
	        triggeringClientEvents: {
	            path: '/docs/client_api_guide/client_events#trigger-events'
	        },
	        encryptedChannelSupport: {
	            fullUrl: 'https://github.com/pusher/pusher-js/tree/cc491015371a4bde5743d1c87a0fbac0feb53195#encrypted-channel-support'
	        }
	    }
	};
	var buildLogSuffix = function (key) {
	    var urlPrefix = 'See:';
	    var urlObj = urlStore.urls[key];
	    if (!urlObj)
	        return '';
	    var url;
	    if (urlObj.fullUrl) {
	        url = urlObj.fullUrl;
	    }
	    else if (urlObj.path) {
	        url = urlStore.baseUrl + urlObj.path;
	    }
	    if (!url)
	        return '';
	    return urlPrefix + " " + url;
	};
	/* harmony default export */ var url_store = ({ buildLogSuffix: buildLogSuffix });

	// CONCATENATED MODULE: ./src/core/errors.ts
	var __extends = (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var BadEventName = (function (_super) {
	    __extends(BadEventName, _super);
	    function BadEventName(msg) {
	        var _newTarget = this.constructor;
	        var _this = _super.call(this, msg) || this;
	        Object.setPrototypeOf(_this, _newTarget.prototype);
	        return _this;
	    }
	    return BadEventName;
	}(Error));

	var RequestTimedOut = (function (_super) {
	    __extends(RequestTimedOut, _super);
	    function RequestTimedOut(msg) {
	        var _newTarget = this.constructor;
	        var _this = _super.call(this, msg) || this;
	        Object.setPrototypeOf(_this, _newTarget.prototype);
	        return _this;
	    }
	    return RequestTimedOut;
	}(Error));

	var TransportPriorityTooLow = (function (_super) {
	    __extends(TransportPriorityTooLow, _super);
	    function TransportPriorityTooLow(msg) {
	        var _newTarget = this.constructor;
	        var _this = _super.call(this, msg) || this;
	        Object.setPrototypeOf(_this, _newTarget.prototype);
	        return _this;
	    }
	    return TransportPriorityTooLow;
	}(Error));

	var TransportClosed = (function (_super) {
	    __extends(TransportClosed, _super);
	    function TransportClosed(msg) {
	        var _newTarget = this.constructor;
	        var _this = _super.call(this, msg) || this;
	        Object.setPrototypeOf(_this, _newTarget.prototype);
	        return _this;
	    }
	    return TransportClosed;
	}(Error));

	var UnsupportedFeature = (function (_super) {
	    __extends(UnsupportedFeature, _super);
	    function UnsupportedFeature(msg) {
	        var _newTarget = this.constructor;
	        var _this = _super.call(this, msg) || this;
	        Object.setPrototypeOf(_this, _newTarget.prototype);
	        return _this;
	    }
	    return UnsupportedFeature;
	}(Error));

	var UnsupportedTransport = (function (_super) {
	    __extends(UnsupportedTransport, _super);
	    function UnsupportedTransport(msg) {
	        var _newTarget = this.constructor;
	        var _this = _super.call(this, msg) || this;
	        Object.setPrototypeOf(_this, _newTarget.prototype);
	        return _this;
	    }
	    return UnsupportedTransport;
	}(Error));

	var UnsupportedStrategy = (function (_super) {
	    __extends(UnsupportedStrategy, _super);
	    function UnsupportedStrategy(msg) {
	        var _newTarget = this.constructor;
	        var _this = _super.call(this, msg) || this;
	        Object.setPrototypeOf(_this, _newTarget.prototype);
	        return _this;
	    }
	    return UnsupportedStrategy;
	}(Error));

	var HTTPAuthError = (function (_super) {
	    __extends(HTTPAuthError, _super);
	    function HTTPAuthError(status, msg) {
	        var _newTarget = this.constructor;
	        var _this = _super.call(this, msg) || this;
	        _this.status = status;
	        Object.setPrototypeOf(_this, _newTarget.prototype);
	        return _this;
	    }
	    return HTTPAuthError;
	}(Error));


	// CONCATENATED MODULE: ./src/runtimes/isomorphic/auth/xhr_auth.ts



	var ajax = function (context, socketId, callback) {
	    var self = this, xhr;
	    xhr = runtime.createXHR();
	    xhr.open('POST', self.options.authEndpoint, true);
	    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
	    for (var headerName in this.authOptions.headers) {
	        xhr.setRequestHeader(headerName, this.authOptions.headers[headerName]);
	    }
	    xhr.onreadystatechange = function () {
	        if (xhr.readyState === 4) {
	            if (xhr.status === 200) {
	                var data = void 0;
	                var parsed = false;
	                try {
	                    data = JSON.parse(xhr.responseText);
	                    parsed = true;
	                }
	                catch (e) {
	                    callback(new HTTPAuthError(200, 'JSON returned from auth endpoint was invalid, yet status code was 200. Data was: ' +
	                        xhr.responseText), { auth: '' });
	                }
	                if (parsed) {
	                    callback(null, data);
	                }
	            }
	            else {
	                var suffix = url_store.buildLogSuffix('authenticationEndpoint');
	                callback(new HTTPAuthError(xhr.status, 'Unable to retrieve auth string from auth endpoint - ' +
	                    ("received status: " + xhr.status + " from " + self.options.authEndpoint + ". ") +
	                    ("Clients must be authenticated to join private or presence channels. " + suffix)), { auth: '' });
	            }
	        }
	    };
	    xhr.send(this.composeQuery(socketId));
	    return xhr;
	};
	/* harmony default export */ var xhr_auth = (ajax);

	// CONCATENATED MODULE: ./src/core/base64.ts
	function encode(s) {
	    return btoa(utob(s));
	}
	var fromCharCode = String.fromCharCode;
	var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	var b64tab = {};
	for (var base64_i = 0, l = b64chars.length; base64_i < l; base64_i++) {
	    b64tab[b64chars.charAt(base64_i)] = base64_i;
	}
	var cb_utob = function (c) {
	    var cc = c.charCodeAt(0);
	    return cc < 0x80
	        ? c
	        : cc < 0x800
	            ? fromCharCode(0xc0 | (cc >>> 6)) + fromCharCode(0x80 | (cc & 0x3f))
	            : fromCharCode(0xe0 | ((cc >>> 12) & 0x0f)) +
	                fromCharCode(0x80 | ((cc >>> 6) & 0x3f)) +
	                fromCharCode(0x80 | (cc & 0x3f));
	};
	var utob = function (u) {
	    return u.replace(/[^\x00-\x7F]/g, cb_utob);
	};
	var cb_encode = function (ccc) {
	    var padlen = [0, 2, 1][ccc.length % 3];
	    var ord = (ccc.charCodeAt(0) << 16) |
	        ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8) |
	        (ccc.length > 2 ? ccc.charCodeAt(2) : 0);
	    var chars = [
	        b64chars.charAt(ord >>> 18),
	        b64chars.charAt((ord >>> 12) & 63),
	        padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
	        padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
	    ];
	    return chars.join('');
	};
	var btoa = window.btoa ||
	    function (b) {
	        return b.replace(/[\s\S]{1,3}/g, cb_encode);
	    };

	// CONCATENATED MODULE: ./src/core/utils/timers/abstract_timer.ts
	var Timer = (function () {
	    function Timer(set, clear, delay, callback) {
	        var _this = this;
	        this.clear = clear;
	        this.timer = set(function () {
	            if (_this.timer) {
	                _this.timer = callback(_this.timer);
	            }
	        }, delay);
	    }
	    Timer.prototype.isRunning = function () {
	        return this.timer !== null;
	    };
	    Timer.prototype.ensureAborted = function () {
	        if (this.timer) {
	            this.clear(this.timer);
	            this.timer = null;
	        }
	    };
	    return Timer;
	}());
	/* harmony default export */ var abstract_timer = (Timer);

	// CONCATENATED MODULE: ./src/core/utils/timers/index.ts
	var timers_extends = (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();

	function timers_clearTimeout(timer) {
	    window.clearTimeout(timer);
	}
	function timers_clearInterval(timer) {
	    window.clearInterval(timer);
	}
	var OneOffTimer = (function (_super) {
	    timers_extends(OneOffTimer, _super);
	    function OneOffTimer(delay, callback) {
	        return _super.call(this, setTimeout, timers_clearTimeout, delay, function (timer) {
	            callback();
	            return null;
	        }) || this;
	    }
	    return OneOffTimer;
	}(abstract_timer));

	var PeriodicTimer = (function (_super) {
	    timers_extends(PeriodicTimer, _super);
	    function PeriodicTimer(delay, callback) {
	        return _super.call(this, setInterval, timers_clearInterval, delay, function (timer) {
	            callback();
	            return timer;
	        }) || this;
	    }
	    return PeriodicTimer;
	}(abstract_timer));


	// CONCATENATED MODULE: ./src/core/util.ts

	var Util = {
	    now: function () {
	        if (Date.now) {
	            return Date.now();
	        }
	        else {
	            return new Date().valueOf();
	        }
	    },
	    defer: function (callback) {
	        return new OneOffTimer(0, callback);
	    },
	    method: function (name) {
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        var boundArguments = Array.prototype.slice.call(arguments, 1);
	        return function (object) {
	            return object[name].apply(object, boundArguments.concat(arguments));
	        };
	    }
	};
	/* harmony default export */ var util = (Util);

	// CONCATENATED MODULE: ./src/core/utils/collections.ts


	function extend(target) {
	    var sources = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        sources[_i - 1] = arguments[_i];
	    }
	    for (var i = 0; i < sources.length; i++) {
	        var extensions = sources[i];
	        for (var property in extensions) {
	            if (extensions[property] &&
	                extensions[property].constructor &&
	                extensions[property].constructor === Object) {
	                target[property] = extend(target[property] || {}, extensions[property]);
	            }
	            else {
	                target[property] = extensions[property];
	            }
	        }
	    }
	    return target;
	}
	function stringify() {
	    var m = ['Pusher'];
	    for (var i = 0; i < arguments.length; i++) {
	        if (typeof arguments[i] === 'string') {
	            m.push(arguments[i]);
	        }
	        else {
	            m.push(safeJSONStringify(arguments[i]));
	        }
	    }
	    return m.join(' : ');
	}
	function arrayIndexOf(array, item) {
	    var nativeIndexOf = Array.prototype.indexOf;
	    if (array === null) {
	        return -1;
	    }
	    if (nativeIndexOf && array.indexOf === nativeIndexOf) {
	        return array.indexOf(item);
	    }
	    for (var i = 0, l = array.length; i < l; i++) {
	        if (array[i] === item) {
	            return i;
	        }
	    }
	    return -1;
	}
	function objectApply(object, f) {
	    for (var key in object) {
	        if (Object.prototype.hasOwnProperty.call(object, key)) {
	            f(object[key], key, object);
	        }
	    }
	}
	function keys(object) {
	    var keys = [];
	    objectApply(object, function (_, key) {
	        keys.push(key);
	    });
	    return keys;
	}
	function values(object) {
	    var values = [];
	    objectApply(object, function (value) {
	        values.push(value);
	    });
	    return values;
	}
	function apply(array, f, context) {
	    for (var i = 0; i < array.length; i++) {
	        f.call(context || window, array[i], i, array);
	    }
	}
	function map(array, f) {
	    var result = [];
	    for (var i = 0; i < array.length; i++) {
	        result.push(f(array[i], i, array, result));
	    }
	    return result;
	}
	function mapObject(object, f) {
	    var result = {};
	    objectApply(object, function (value, key) {
	        result[key] = f(value);
	    });
	    return result;
	}
	function filter(array, test) {
	    test =
	        test ||
	            function (value) {
	                return !!value;
	            };
	    var result = [];
	    for (var i = 0; i < array.length; i++) {
	        if (test(array[i], i, array, result)) {
	            result.push(array[i]);
	        }
	    }
	    return result;
	}
	function filterObject(object, test) {
	    var result = {};
	    objectApply(object, function (value, key) {
	        if ((test && test(value, key, object, result)) || Boolean(value)) {
	            result[key] = value;
	        }
	    });
	    return result;
	}
	function flatten(object) {
	    var result = [];
	    objectApply(object, function (value, key) {
	        result.push([key, value]);
	    });
	    return result;
	}
	function any(array, test) {
	    for (var i = 0; i < array.length; i++) {
	        if (test(array[i], i, array)) {
	            return true;
	        }
	    }
	    return false;
	}
	function collections_all(array, test) {
	    for (var i = 0; i < array.length; i++) {
	        if (!test(array[i], i, array)) {
	            return false;
	        }
	    }
	    return true;
	}
	function encodeParamsObject(data) {
	    return mapObject(data, function (value) {
	        if (typeof value === 'object') {
	            value = safeJSONStringify(value);
	        }
	        return encodeURIComponent(encode(value.toString()));
	    });
	}
	function buildQueryString(data) {
	    var params = filterObject(data, function (value) {
	        return value !== undefined;
	    });
	    var query = map(flatten(encodeParamsObject(params)), util.method('join', '=')).join('&');
	    return query;
	}
	function decycleObject(object) {
	    var objects = [], paths = [];
	    return (function derez(value, path) {
	        var i, name, nu;
	        switch (typeof value) {
	            case 'object':
	                if (!value) {
	                    return null;
	                }
	                for (i = 0; i < objects.length; i += 1) {
	                    if (objects[i] === value) {
	                        return { $ref: paths[i] };
	                    }
	                }
	                objects.push(value);
	                paths.push(path);
	                if (Object.prototype.toString.apply(value) === '[object Array]') {
	                    nu = [];
	                    for (i = 0; i < value.length; i += 1) {
	                        nu[i] = derez(value[i], path + '[' + i + ']');
	                    }
	                }
	                else {
	                    nu = {};
	                    for (name in value) {
	                        if (Object.prototype.hasOwnProperty.call(value, name)) {
	                            nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');
	                        }
	                    }
	                }
	                return nu;
	            case 'number':
	            case 'string':
	            case 'boolean':
	                return value;
	        }
	    })(object, '$');
	}
	function safeJSONStringify(source) {
	    try {
	        return JSON.stringify(source);
	    }
	    catch (e) {
	        return JSON.stringify(decycleObject(source));
	    }
	}

	// CONCATENATED MODULE: ./src/core/logger.ts


	var logger_Logger = (function () {
	    function Logger() {
	        this.globalLog = function (message) {
	            if (window.console && window.console.log) {
	                window.console.log(message);
	            }
	        };
	    }
	    Logger.prototype.debug = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        this.log(this.globalLog, args);
	    };
	    Logger.prototype.warn = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        this.log(this.globalLogWarn, args);
	    };
	    Logger.prototype.error = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        this.log(this.globalLogError, args);
	    };
	    Logger.prototype.globalLogWarn = function (message) {
	        if (window.console && window.console.warn) {
	            window.console.warn(message);
	        }
	        else {
	            this.globalLog(message);
	        }
	    };
	    Logger.prototype.globalLogError = function (message) {
	        if (window.console && window.console.error) {
	            window.console.error(message);
	        }
	        else {
	            this.globalLogWarn(message);
	        }
	    };
	    Logger.prototype.log = function (defaultLoggingFunction) {
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        var message = stringify.apply(this, arguments);
	        if (core_pusher.log) {
	            core_pusher.log(message);
	        }
	        else if (core_pusher.logToConsole) {
	            var log = defaultLoggingFunction.bind(this);
	            log(message);
	        }
	    };
	    return Logger;
	}());
	/* harmony default export */ var logger = (new logger_Logger());

	// CONCATENATED MODULE: ./src/runtimes/web/auth/jsonp_auth.ts

	var jsonp = function (context, socketId, callback) {
	    if (this.authOptions.headers !== undefined) {
	        logger.warn('To send headers with the auth request, you must use AJAX, rather than JSONP.');
	    }
	    var callbackName = context.nextAuthCallbackID.toString();
	    context.nextAuthCallbackID++;
	    var document = context.getDocument();
	    var script = document.createElement('script');
	    context.auth_callbacks[callbackName] = function (data) {
	        callback(null, data);
	    };
	    var callback_name = "Pusher.auth_callbacks['" + callbackName + "']";
	    script.src =
	        this.options.authEndpoint +
	            '?callback=' +
	            encodeURIComponent(callback_name) +
	            '&' +
	            this.composeQuery(socketId);
	    var head = document.getElementsByTagName('head')[0] || document.documentElement;
	    head.insertBefore(script, head.firstChild);
	};
	/* harmony default export */ var jsonp_auth = (jsonp);

	// CONCATENATED MODULE: ./src/runtimes/web/dom/script_request.ts
	var ScriptRequest = (function () {
	    function ScriptRequest(src) {
	        this.src = src;
	    }
	    ScriptRequest.prototype.send = function (receiver) {
	        var self = this;
	        var errorString = 'Error loading ' + self.src;
	        self.script = document.createElement('script');
	        self.script.id = receiver.id;
	        self.script.src = self.src;
	        self.script.type = 'text/javascript';
	        self.script.charset = 'UTF-8';
	        if (self.script.addEventListener) {
	            self.script.onerror = function () {
	                receiver.callback(errorString);
	            };
	            self.script.onload = function () {
	                receiver.callback(null);
	            };
	        }
	        else {
	            self.script.onreadystatechange = function () {
	                if (self.script.readyState === 'loaded' ||
	                    self.script.readyState === 'complete') {
	                    receiver.callback(null);
	                }
	            };
	        }
	        if (self.script.async === undefined &&
	            document.attachEvent &&
	            /opera/i.test(navigator.userAgent)) {
	            self.errorScript = document.createElement('script');
	            self.errorScript.id = receiver.id + '_error';
	            self.errorScript.text = receiver.name + "('" + errorString + "');";
	            self.script.async = self.errorScript.async = false;
	        }
	        else {
	            self.script.async = true;
	        }
	        var head = document.getElementsByTagName('head')[0];
	        head.insertBefore(self.script, head.firstChild);
	        if (self.errorScript) {
	            head.insertBefore(self.errorScript, self.script.nextSibling);
	        }
	    };
	    ScriptRequest.prototype.cleanup = function () {
	        if (this.script) {
	            this.script.onload = this.script.onerror = null;
	            this.script.onreadystatechange = null;
	        }
	        if (this.script && this.script.parentNode) {
	            this.script.parentNode.removeChild(this.script);
	        }
	        if (this.errorScript && this.errorScript.parentNode) {
	            this.errorScript.parentNode.removeChild(this.errorScript);
	        }
	        this.script = null;
	        this.errorScript = null;
	    };
	    return ScriptRequest;
	}());
	/* harmony default export */ var script_request = (ScriptRequest);

	// CONCATENATED MODULE: ./src/runtimes/web/dom/jsonp_request.ts


	var jsonp_request_JSONPRequest = (function () {
	    function JSONPRequest(url, data) {
	        this.url = url;
	        this.data = data;
	    }
	    JSONPRequest.prototype.send = function (receiver) {
	        if (this.request) {
	            return;
	        }
	        var query = buildQueryString(this.data);
	        var url = this.url + '/' + receiver.number + '?' + query;
	        this.request = runtime.createScriptRequest(url);
	        this.request.send(receiver);
	    };
	    JSONPRequest.prototype.cleanup = function () {
	        if (this.request) {
	            this.request.cleanup();
	        }
	    };
	    return JSONPRequest;
	}());
	/* harmony default export */ var jsonp_request = (jsonp_request_JSONPRequest);

	// CONCATENATED MODULE: ./src/runtimes/web/timeline/jsonp_timeline.ts


	var getAgent = function (sender, useTLS) {
	    return function (data, callback) {
	        var scheme = 'http' + (useTLS ? 's' : '') + '://';
	        var url = scheme + (sender.host || sender.options.host) + sender.options.path;
	        var request = runtime.createJSONPRequest(url, data);
	        var receiver = runtime.ScriptReceivers.create(function (error, result) {
	            ScriptReceivers.remove(receiver);
	            request.cleanup();
	            if (result && result.host) {
	                sender.host = result.host;
	            }
	            if (callback) {
	                callback(error, result);
	            }
	        });
	        request.send(receiver);
	    };
	};
	var jsonp_timeline_jsonp = {
	    name: 'jsonp',
	    getAgent: getAgent
	};
	/* harmony default export */ var jsonp_timeline = (jsonp_timeline_jsonp);

	// CONCATENATED MODULE: ./src/core/transports/url_schemes.ts

	function getGenericURL(baseScheme, params, path) {
	    var scheme = baseScheme + (params.useTLS ? 's' : '');
	    var host = params.useTLS ? params.hostTLS : params.hostNonTLS;
	    return scheme + '://' + host + path;
	}
	function getGenericPath(key, queryString) {
	    var path = '/app/' + key;
	    var query = '?protocol=' +
	        defaults.PROTOCOL +
	        '&client=js' +
	        '&version=' +
	        defaults.VERSION +
	        (queryString ? '&' + queryString : '');
	    return path + query;
	}
	var ws = {
	    getInitial: function (key, params) {
	        var path = (params.httpPath || '') + getGenericPath(key, 'flash=false');
	        return getGenericURL('ws', params, path);
	    }
	};
	var http = {
	    getInitial: function (key, params) {
	        var path = (params.httpPath || '/pusher') + getGenericPath(key);
	        return getGenericURL('http', params, path);
	    }
	};
	var sockjs = {
	    getInitial: function (key, params) {
	        return getGenericURL('http', params, params.httpPath || '/pusher');
	    },
	    getPath: function (key, params) {
	        return getGenericPath(key);
	    }
	};

	// CONCATENATED MODULE: ./src/core/events/callback_registry.ts

	var callback_registry_CallbackRegistry = (function () {
	    function CallbackRegistry() {
	        this._callbacks = {};
	    }
	    CallbackRegistry.prototype.get = function (name) {
	        return this._callbacks[prefix(name)];
	    };
	    CallbackRegistry.prototype.add = function (name, callback, context) {
	        var prefixedEventName = prefix(name);
	        this._callbacks[prefixedEventName] =
	            this._callbacks[prefixedEventName] || [];
	        this._callbacks[prefixedEventName].push({
	            fn: callback,
	            context: context
	        });
	    };
	    CallbackRegistry.prototype.remove = function (name, callback, context) {
	        if (!name && !callback && !context) {
	            this._callbacks = {};
	            return;
	        }
	        var names = name ? [prefix(name)] : keys(this._callbacks);
	        if (callback || context) {
	            this.removeCallback(names, callback, context);
	        }
	        else {
	            this.removeAllCallbacks(names);
	        }
	    };
	    CallbackRegistry.prototype.removeCallback = function (names, callback, context) {
	        apply(names, function (name) {
	            this._callbacks[name] = filter(this._callbacks[name] || [], function (binding) {
	                return ((callback && callback !== binding.fn) ||
	                    (context && context !== binding.context));
	            });
	            if (this._callbacks[name].length === 0) {
	                delete this._callbacks[name];
	            }
	        }, this);
	    };
	    CallbackRegistry.prototype.removeAllCallbacks = function (names) {
	        apply(names, function (name) {
	            delete this._callbacks[name];
	        }, this);
	    };
	    return CallbackRegistry;
	}());
	/* harmony default export */ var callback_registry = (callback_registry_CallbackRegistry);
	function prefix(name) {
	    return '_' + name;
	}

	// CONCATENATED MODULE: ./src/core/events/dispatcher.ts


	var dispatcher_Dispatcher = (function () {
	    function Dispatcher(failThrough) {
	        this.callbacks = new callback_registry();
	        this.global_callbacks = [];
	        this.failThrough = failThrough;
	    }
	    Dispatcher.prototype.bind = function (eventName, callback, context) {
	        this.callbacks.add(eventName, callback, context);
	        return this;
	    };
	    Dispatcher.prototype.bind_global = function (callback) {
	        this.global_callbacks.push(callback);
	        return this;
	    };
	    Dispatcher.prototype.unbind = function (eventName, callback, context) {
	        this.callbacks.remove(eventName, callback, context);
	        return this;
	    };
	    Dispatcher.prototype.unbind_global = function (callback) {
	        if (!callback) {
	            this.global_callbacks = [];
	            return this;
	        }
	        this.global_callbacks = filter(this.global_callbacks || [], function (c) { return c !== callback; });
	        return this;
	    };
	    Dispatcher.prototype.unbind_all = function () {
	        this.unbind();
	        this.unbind_global();
	        return this;
	    };
	    Dispatcher.prototype.emit = function (eventName, data, metadata) {
	        for (var i = 0; i < this.global_callbacks.length; i++) {
	            this.global_callbacks[i](eventName, data);
	        }
	        var callbacks = this.callbacks.get(eventName);
	        var args = [];
	        if (metadata) {
	            args.push(data, metadata);
	        }
	        else if (data) {
	            args.push(data);
	        }
	        if (callbacks && callbacks.length > 0) {
	            for (var i = 0; i < callbacks.length; i++) {
	                callbacks[i].fn.apply(callbacks[i].context || window, args);
	            }
	        }
	        else if (this.failThrough) {
	            this.failThrough(eventName, data);
	        }
	        return this;
	    };
	    return Dispatcher;
	}());
	/* harmony default export */ var dispatcher = (dispatcher_Dispatcher);

	// CONCATENATED MODULE: ./src/core/transports/transport_connection.ts
	var transport_connection_extends = (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();





	var transport_connection_TransportConnection = (function (_super) {
	    transport_connection_extends(TransportConnection, _super);
	    function TransportConnection(hooks, name, priority, key, options) {
	        var _this = _super.call(this) || this;
	        _this.initialize = runtime.transportConnectionInitializer;
	        _this.hooks = hooks;
	        _this.name = name;
	        _this.priority = priority;
	        _this.key = key;
	        _this.options = options;
	        _this.state = 'new';
	        _this.timeline = options.timeline;
	        _this.activityTimeout = options.activityTimeout;
	        _this.id = _this.timeline.generateUniqueID();
	        return _this;
	    }
	    TransportConnection.prototype.handlesActivityChecks = function () {
	        return Boolean(this.hooks.handlesActivityChecks);
	    };
	    TransportConnection.prototype.supportsPing = function () {
	        return Boolean(this.hooks.supportsPing);
	    };
	    TransportConnection.prototype.connect = function () {
	        var _this = this;
	        if (this.socket || this.state !== 'initialized') {
	            return false;
	        }
	        var url = this.hooks.urls.getInitial(this.key, this.options);
	        try {
	            this.socket = this.hooks.getSocket(url, this.options);
	        }
	        catch (e) {
	            util.defer(function () {
	                _this.onError(e);
	                _this.changeState('closed');
	            });
	            return false;
	        }
	        this.bindListeners();
	        logger.debug('Connecting', { transport: this.name, url: url });
	        this.changeState('connecting');
	        return true;
	    };
	    TransportConnection.prototype.close = function () {
	        if (this.socket) {
	            this.socket.close();
	            return true;
	        }
	        else {
	            return false;
	        }
	    };
	    TransportConnection.prototype.send = function (data) {
	        var _this = this;
	        if (this.state === 'open') {
	            util.defer(function () {
	                if (_this.socket) {
	                    _this.socket.send(data);
	                }
	            });
	            return true;
	        }
	        else {
	            return false;
	        }
	    };
	    TransportConnection.prototype.ping = function () {
	        if (this.state === 'open' && this.supportsPing()) {
	            this.socket.ping();
	        }
	    };
	    TransportConnection.prototype.onOpen = function () {
	        if (this.hooks.beforeOpen) {
	            this.hooks.beforeOpen(this.socket, this.hooks.urls.getPath(this.key, this.options));
	        }
	        this.changeState('open');
	        this.socket.onopen = undefined;
	    };
	    TransportConnection.prototype.onError = function (error) {
	        this.emit('error', { type: 'WebSocketError', error: error });
	        this.timeline.error(this.buildTimelineMessage({ error: error.toString() }));
	    };
	    TransportConnection.prototype.onClose = function (closeEvent) {
	        if (closeEvent) {
	            this.changeState('closed', {
	                code: closeEvent.code,
	                reason: closeEvent.reason,
	                wasClean: closeEvent.wasClean
	            });
	        }
	        else {
	            this.changeState('closed');
	        }
	        this.unbindListeners();
	        this.socket = undefined;
	    };
	    TransportConnection.prototype.onMessage = function (message) {
	        this.emit('message', message);
	    };
	    TransportConnection.prototype.onActivity = function () {
	        this.emit('activity');
	    };
	    TransportConnection.prototype.bindListeners = function () {
	        var _this = this;
	        this.socket.onopen = function () {
	            _this.onOpen();
	        };
	        this.socket.onerror = function (error) {
	            _this.onError(error);
	        };
	        this.socket.onclose = function (closeEvent) {
	            _this.onClose(closeEvent);
	        };
	        this.socket.onmessage = function (message) {
	            _this.onMessage(message);
	        };
	        if (this.supportsPing()) {
	            this.socket.onactivity = function () {
	                _this.onActivity();
	            };
	        }
	    };
	    TransportConnection.prototype.unbindListeners = function () {
	        if (this.socket) {
	            this.socket.onopen = undefined;
	            this.socket.onerror = undefined;
	            this.socket.onclose = undefined;
	            this.socket.onmessage = undefined;
	            if (this.supportsPing()) {
	                this.socket.onactivity = undefined;
	            }
	        }
	    };
	    TransportConnection.prototype.changeState = function (state, params) {
	        this.state = state;
	        this.timeline.info(this.buildTimelineMessage({
	            state: state,
	            params: params
	        }));
	        this.emit(state, params);
	    };
	    TransportConnection.prototype.buildTimelineMessage = function (message) {
	        return extend({ cid: this.id }, message);
	    };
	    return TransportConnection;
	}(dispatcher));
	/* harmony default export */ var transport_connection = (transport_connection_TransportConnection);

	// CONCATENATED MODULE: ./src/core/transports/transport.ts

	var transport_Transport = (function () {
	    function Transport(hooks) {
	        this.hooks = hooks;
	    }
	    Transport.prototype.isSupported = function (environment) {
	        return this.hooks.isSupported(environment);
	    };
	    Transport.prototype.createConnection = function (name, priority, key, options) {
	        return new transport_connection(this.hooks, name, priority, key, options);
	    };
	    return Transport;
	}());
	/* harmony default export */ var transports_transport = (transport_Transport);

	// CONCATENATED MODULE: ./src/runtimes/isomorphic/transports/transports.ts




	var WSTransport = new transports_transport({
	    urls: ws,
	    handlesActivityChecks: false,
	    supportsPing: false,
	    isInitialized: function () {
	        return Boolean(runtime.getWebSocketAPI());
	    },
	    isSupported: function () {
	        return Boolean(runtime.getWebSocketAPI());
	    },
	    getSocket: function (url) {
	        return runtime.createWebSocket(url);
	    }
	});
	var httpConfiguration = {
	    urls: http,
	    handlesActivityChecks: false,
	    supportsPing: true,
	    isInitialized: function () {
	        return true;
	    }
	};
	var streamingConfiguration = extend({
	    getSocket: function (url) {
	        return runtime.HTTPFactory.createStreamingSocket(url);
	    }
	}, httpConfiguration);
	var pollingConfiguration = extend({
	    getSocket: function (url) {
	        return runtime.HTTPFactory.createPollingSocket(url);
	    }
	}, httpConfiguration);
	var xhrConfiguration = {
	    isSupported: function () {
	        return runtime.isXHRSupported();
	    }
	};
	var XHRStreamingTransport = new transports_transport((extend({}, streamingConfiguration, xhrConfiguration)));
	var XHRPollingTransport = new transports_transport(extend({}, pollingConfiguration, xhrConfiguration));
	var Transports = {
	    ws: WSTransport,
	    xhr_streaming: XHRStreamingTransport,
	    xhr_polling: XHRPollingTransport
	};
	/* harmony default export */ var transports = (Transports);

	// CONCATENATED MODULE: ./src/runtimes/web/transports/transports.ts






	var SockJSTransport = new transports_transport({
	    file: 'sockjs',
	    urls: sockjs,
	    handlesActivityChecks: true,
	    supportsPing: false,
	    isSupported: function () {
	        return true;
	    },
	    isInitialized: function () {
	        return window.SockJS !== undefined;
	    },
	    getSocket: function (url, options) {
	        return new window.SockJS(url, null, {
	            js_path: Dependencies.getPath('sockjs', {
	                useTLS: options.useTLS
	            }),
	            ignore_null_origin: options.ignoreNullOrigin
	        });
	    },
	    beforeOpen: function (socket, path) {
	        socket.send(JSON.stringify({
	            path: path
	        }));
	    }
	});
	var xdrConfiguration = {
	    isSupported: function (environment) {
	        var yes = runtime.isXDRSupported(environment.useTLS);
	        return yes;
	    }
	};
	var XDRStreamingTransport = new transports_transport((extend({}, streamingConfiguration, xdrConfiguration)));
	var XDRPollingTransport = new transports_transport(extend({}, pollingConfiguration, xdrConfiguration));
	transports.xdr_streaming = XDRStreamingTransport;
	transports.xdr_polling = XDRPollingTransport;
	transports.sockjs = SockJSTransport;
	/* harmony default export */ var transports_transports = (transports);

	// CONCATENATED MODULE: ./src/runtimes/web/net_info.ts
	var net_info_extends = (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();

	var NetInfo = (function (_super) {
	    net_info_extends(NetInfo, _super);
	    function NetInfo() {
	        var _this = _super.call(this) || this;
	        var self = _this;
	        if (window.addEventListener !== undefined) {
	            window.addEventListener('online', function () {
	                self.emit('online');
	            }, false);
	            window.addEventListener('offline', function () {
	                self.emit('offline');
	            }, false);
	        }
	        return _this;
	    }
	    NetInfo.prototype.isOnline = function () {
	        if (window.navigator.onLine === undefined) {
	            return true;
	        }
	        else {
	            return window.navigator.onLine;
	        }
	    };
	    return NetInfo;
	}(dispatcher));

	var net_info_Network = new NetInfo();

	// CONCATENATED MODULE: ./src/core/transports/assistant_to_the_transport_manager.ts


	var assistant_to_the_transport_manager_AssistantToTheTransportManager = (function () {
	    function AssistantToTheTransportManager(manager, transport, options) {
	        this.manager = manager;
	        this.transport = transport;
	        this.minPingDelay = options.minPingDelay;
	        this.maxPingDelay = options.maxPingDelay;
	        this.pingDelay = undefined;
	    }
	    AssistantToTheTransportManager.prototype.createConnection = function (name, priority, key, options) {
	        var _this = this;
	        options = extend({}, options, {
	            activityTimeout: this.pingDelay
	        });
	        var connection = this.transport.createConnection(name, priority, key, options);
	        var openTimestamp = null;
	        var onOpen = function () {
	            connection.unbind('open', onOpen);
	            connection.bind('closed', onClosed);
	            openTimestamp = util.now();
	        };
	        var onClosed = function (closeEvent) {
	            connection.unbind('closed', onClosed);
	            if (closeEvent.code === 1002 || closeEvent.code === 1003) {
	                _this.manager.reportDeath();
	            }
	            else if (!closeEvent.wasClean && openTimestamp) {
	                var lifespan = util.now() - openTimestamp;
	                if (lifespan < 2 * _this.maxPingDelay) {
	                    _this.manager.reportDeath();
	                    _this.pingDelay = Math.max(lifespan / 2, _this.minPingDelay);
	                }
	            }
	        };
	        connection.bind('open', onOpen);
	        return connection;
	    };
	    AssistantToTheTransportManager.prototype.isSupported = function (environment) {
	        return this.manager.isAlive() && this.transport.isSupported(environment);
	    };
	    return AssistantToTheTransportManager;
	}());
	/* harmony default export */ var assistant_to_the_transport_manager = (assistant_to_the_transport_manager_AssistantToTheTransportManager);

	// CONCATENATED MODULE: ./src/core/connection/protocol/protocol.ts
	var Protocol = {
	    decodeMessage: function (messageEvent) {
	        try {
	            var messageData = JSON.parse(messageEvent.data);
	            var pusherEventData = messageData.data;
	            if (typeof pusherEventData === 'string') {
	                try {
	                    pusherEventData = JSON.parse(messageData.data);
	                }
	                catch (e) { }
	            }
	            var pusherEvent = {
	                event: messageData.event,
	                channel: messageData.channel,
	                data: pusherEventData
	            };
	            if (messageData.user_id) {
	                pusherEvent.user_id = messageData.user_id;
	            }
	            return pusherEvent;
	        }
	        catch (e) {
	            throw { type: 'MessageParseError', error: e, data: messageEvent.data };
	        }
	    },
	    encodeMessage: function (event) {
	        return JSON.stringify(event);
	    },
	    processHandshake: function (messageEvent) {
	        var message = Protocol.decodeMessage(messageEvent);
	        if (message.event === 'pusher:connection_established') {
	            if (!message.data.activity_timeout) {
	                throw 'No activity timeout specified in handshake';
	            }
	            return {
	                action: 'connected',
	                id: message.data.socket_id,
	                activityTimeout: message.data.activity_timeout * 1000
	            };
	        }
	        else if (message.event === 'pusher:error') {
	            return {
	                action: this.getCloseAction(message.data),
	                error: this.getCloseError(message.data)
	            };
	        }
	        else {
	            throw 'Invalid handshake';
	        }
	    },
	    getCloseAction: function (closeEvent) {
	        if (closeEvent.code < 4000) {
	            if (closeEvent.code >= 1002 && closeEvent.code <= 1004) {
	                return 'backoff';
	            }
	            else {
	                return null;
	            }
	        }
	        else if (closeEvent.code === 4000) {
	            return 'tls_only';
	        }
	        else if (closeEvent.code < 4100) {
	            return 'refused';
	        }
	        else if (closeEvent.code < 4200) {
	            return 'backoff';
	        }
	        else if (closeEvent.code < 4300) {
	            return 'retry';
	        }
	        else {
	            return 'refused';
	        }
	    },
	    getCloseError: function (closeEvent) {
	        if (closeEvent.code !== 1000 && closeEvent.code !== 1001) {
	            return {
	                type: 'PusherError',
	                data: {
	                    code: closeEvent.code,
	                    message: closeEvent.reason || closeEvent.message
	                }
	            };
	        }
	        else {
	            return null;
	        }
	    }
	};
	/* harmony default export */ var protocol_protocol = (Protocol);

	// CONCATENATED MODULE: ./src/core/connection/connection.ts
	var connection_extends = (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();




	var connection_Connection = (function (_super) {
	    connection_extends(Connection, _super);
	    function Connection(id, transport) {
	        var _this = _super.call(this) || this;
	        _this.id = id;
	        _this.transport = transport;
	        _this.activityTimeout = transport.activityTimeout;
	        _this.bindListeners();
	        return _this;
	    }
	    Connection.prototype.handlesActivityChecks = function () {
	        return this.transport.handlesActivityChecks();
	    };
	    Connection.prototype.send = function (data) {
	        return this.transport.send(data);
	    };
	    Connection.prototype.send_event = function (name, data, channel) {
	        var event = { event: name, data: data };
	        if (channel) {
	            event.channel = channel;
	        }
	        logger.debug('Event sent', event);
	        return this.send(protocol_protocol.encodeMessage(event));
	    };
	    Connection.prototype.ping = function () {
	        if (this.transport.supportsPing()) {
	            this.transport.ping();
	        }
	        else {
	            this.send_event('pusher:ping', {});
	        }
	    };
	    Connection.prototype.close = function () {
	        this.transport.close();
	    };
	    Connection.prototype.bindListeners = function () {
	        var _this = this;
	        var listeners = {
	            message: function (messageEvent) {
	                var pusherEvent;
	                try {
	                    pusherEvent = protocol_protocol.decodeMessage(messageEvent);
	                }
	                catch (e) {
	                    _this.emit('error', {
	                        type: 'MessageParseError',
	                        error: e,
	                        data: messageEvent.data
	                    });
	                }
	                if (pusherEvent !== undefined) {
	                    logger.debug('Event recd', pusherEvent);
	                    switch (pusherEvent.event) {
	                        case 'pusher:error':
	                            _this.emit('error', {
	                                type: 'PusherError',
	                                data: pusherEvent.data
	                            });
	                            break;
	                        case 'pusher:ping':
	                            _this.emit('ping');
	                            break;
	                        case 'pusher:pong':
	                            _this.emit('pong');
	                            break;
	                    }
	                    _this.emit('message', pusherEvent);
	                }
	            },
	            activity: function () {
	                _this.emit('activity');
	            },
	            error: function (error) {
	                _this.emit('error', error);
	            },
	            closed: function (closeEvent) {
	                unbindListeners();
	                if (closeEvent && closeEvent.code) {
	                    _this.handleCloseEvent(closeEvent);
	                }
	                _this.transport = null;
	                _this.emit('closed');
	            }
	        };
	        var unbindListeners = function () {
	            objectApply(listeners, function (listener, event) {
	                _this.transport.unbind(event, listener);
	            });
	        };
	        objectApply(listeners, function (listener, event) {
	            _this.transport.bind(event, listener);
	        });
	    };
	    Connection.prototype.handleCloseEvent = function (closeEvent) {
	        var action = protocol_protocol.getCloseAction(closeEvent);
	        var error = protocol_protocol.getCloseError(closeEvent);
	        if (error) {
	            this.emit('error', error);
	        }
	        if (action) {
	            this.emit(action, { action: action, error: error });
	        }
	    };
	    return Connection;
	}(dispatcher));
	/* harmony default export */ var connection_connection = (connection_Connection);

	// CONCATENATED MODULE: ./src/core/connection/handshake/index.ts



	var handshake_Handshake = (function () {
	    function Handshake(transport, callback) {
	        this.transport = transport;
	        this.callback = callback;
	        this.bindListeners();
	    }
	    Handshake.prototype.close = function () {
	        this.unbindListeners();
	        this.transport.close();
	    };
	    Handshake.prototype.bindListeners = function () {
	        var _this = this;
	        this.onMessage = function (m) {
	            _this.unbindListeners();
	            var result;
	            try {
	                result = protocol_protocol.processHandshake(m);
	            }
	            catch (e) {
	                _this.finish('error', { error: e });
	                _this.transport.close();
	                return;
	            }
	            if (result.action === 'connected') {
	                _this.finish('connected', {
	                    connection: new connection_connection(result.id, _this.transport),
	                    activityTimeout: result.activityTimeout
	                });
	            }
	            else {
	                _this.finish(result.action, { error: result.error });
	                _this.transport.close();
	            }
	        };
	        this.onClosed = function (closeEvent) {
	            _this.unbindListeners();
	            var action = protocol_protocol.getCloseAction(closeEvent) || 'backoff';
	            var error = protocol_protocol.getCloseError(closeEvent);
	            _this.finish(action, { error: error });
	        };
	        this.transport.bind('message', this.onMessage);
	        this.transport.bind('closed', this.onClosed);
	    };
	    Handshake.prototype.unbindListeners = function () {
	        this.transport.unbind('message', this.onMessage);
	        this.transport.unbind('closed', this.onClosed);
	    };
	    Handshake.prototype.finish = function (action, params) {
	        this.callback(extend({ transport: this.transport, action: action }, params));
	    };
	    return Handshake;
	}());
	/* harmony default export */ var connection_handshake = (handshake_Handshake);

	// CONCATENATED MODULE: ./src/core/auth/pusher_authorizer.ts

	var pusher_authorizer_PusherAuthorizer = (function () {
	    function PusherAuthorizer(channel, options) {
	        this.channel = channel;
	        var authTransport = options.authTransport;
	        if (typeof runtime.getAuthorizers()[authTransport] === 'undefined') {
	            throw "'" + authTransport + "' is not a recognized auth transport";
	        }
	        this.type = authTransport;
	        this.options = options;
	        this.authOptions = options.auth || {};
	    }
	    PusherAuthorizer.prototype.composeQuery = function (socketId) {
	        var query = 'socket_id=' +
	            encodeURIComponent(socketId) +
	            '&channel_name=' +
	            encodeURIComponent(this.channel.name);
	        for (var i in this.authOptions.params) {
	            query +=
	                '&' +
	                    encodeURIComponent(i) +
	                    '=' +
	                    encodeURIComponent(this.authOptions.params[i]);
	        }
	        return query;
	    };
	    PusherAuthorizer.prototype.authorize = function (socketId, callback) {
	        PusherAuthorizer.authorizers =
	            PusherAuthorizer.authorizers || runtime.getAuthorizers();
	        PusherAuthorizer.authorizers[this.type].call(this, runtime, socketId, callback);
	    };
	    return PusherAuthorizer;
	}());
	/* harmony default export */ var pusher_authorizer = (pusher_authorizer_PusherAuthorizer);

	// CONCATENATED MODULE: ./src/core/timeline/timeline_sender.ts

	var timeline_sender_TimelineSender = (function () {
	    function TimelineSender(timeline, options) {
	        this.timeline = timeline;
	        this.options = options || {};
	    }
	    TimelineSender.prototype.send = function (useTLS, callback) {
	        if (this.timeline.isEmpty()) {
	            return;
	        }
	        this.timeline.send(runtime.TimelineTransport.getAgent(this, useTLS), callback);
	    };
	    return TimelineSender;
	}());
	/* harmony default export */ var timeline_sender = (timeline_sender_TimelineSender);

	// CONCATENATED MODULE: ./src/core/channels/channel.ts
	var channel_extends = (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();





	var channel_Channel = (function (_super) {
	    channel_extends(Channel, _super);
	    function Channel(name, pusher) {
	        var _this = _super.call(this, function (event, data) {
	            logger.debug('No callbacks on ' + name + ' for ' + event);
	        }) || this;
	        _this.name = name;
	        _this.pusher = pusher;
	        _this.subscribed = false;
	        _this.subscriptionPending = false;
	        _this.subscriptionCancelled = false;
	        return _this;
	    }
	    Channel.prototype.authorize = function (socketId, callback) {
	        return callback(null, { auth: '' });
	    };
	    Channel.prototype.trigger = function (event, data) {
	        if (event.indexOf('client-') !== 0) {
	            throw new BadEventName("Event '" + event + "' does not start with 'client-'");
	        }
	        if (!this.subscribed) {
	            var suffix = url_store.buildLogSuffix('triggeringClientEvents');
	            logger.warn("Client event triggered before channel 'subscription_succeeded' event . " + suffix);
	        }
	        return this.pusher.send_event(event, data, this.name);
	    };
	    Channel.prototype.disconnect = function () {
	        this.subscribed = false;
	        this.subscriptionPending = false;
	    };
	    Channel.prototype.handleEvent = function (event) {
	        var eventName = event.event;
	        var data = event.data;
	        if (eventName === 'pusher_internal:subscription_succeeded') {
	            this.handleSubscriptionSucceededEvent(event);
	        }
	        else if (eventName.indexOf('pusher_internal:') !== 0) {
	            var metadata = {};
	            this.emit(eventName, data, metadata);
	        }
	    };
	    Channel.prototype.handleSubscriptionSucceededEvent = function (event) {
	        this.subscriptionPending = false;
	        this.subscribed = true;
	        if (this.subscriptionCancelled) {
	            this.pusher.unsubscribe(this.name);
	        }
	        else {
	            this.emit('pusher:subscription_succeeded', event.data);
	        }
	    };
	    Channel.prototype.subscribe = function () {
	        var _this = this;
	        if (this.subscribed) {
	            return;
	        }
	        this.subscriptionPending = true;
	        this.subscriptionCancelled = false;
	        this.authorize(this.pusher.connection.socket_id, function (error, data) {
	            if (error) {
	                _this.subscriptionPending = false;
	                logger.error(error.toString());
	                _this.emit('pusher:subscription_error', Object.assign({}, {
	                    type: 'AuthError',
	                    error: error.message
	                }, error instanceof HTTPAuthError ? { status: error.status } : {}));
	            }
	            else {
	                _this.pusher.send_event('pusher:subscribe', {
	                    auth: data.auth,
	                    channel_data: data.channel_data,
	                    channel: _this.name
	                });
	            }
	        });
	    };
	    Channel.prototype.unsubscribe = function () {
	        this.subscribed = false;
	        this.pusher.send_event('pusher:unsubscribe', {
	            channel: this.name
	        });
	    };
	    Channel.prototype.cancelSubscription = function () {
	        this.subscriptionCancelled = true;
	    };
	    Channel.prototype.reinstateSubscription = function () {
	        this.subscriptionCancelled = false;
	    };
	    return Channel;
	}(dispatcher));
	/* harmony default export */ var channels_channel = (channel_Channel);

	// CONCATENATED MODULE: ./src/core/channels/private_channel.ts
	var private_channel_extends = (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();


	var private_channel_PrivateChannel = (function (_super) {
	    private_channel_extends(PrivateChannel, _super);
	    function PrivateChannel() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    PrivateChannel.prototype.authorize = function (socketId, callback) {
	        var authorizer = factory.createAuthorizer(this, this.pusher.config);
	        return authorizer.authorize(socketId, callback);
	    };
	    return PrivateChannel;
	}(channels_channel));
	/* harmony default export */ var private_channel = (private_channel_PrivateChannel);

	// CONCATENATED MODULE: ./src/core/channels/members.ts

	var members_Members = (function () {
	    function Members() {
	        this.reset();
	    }
	    Members.prototype.get = function (id) {
	        if (Object.prototype.hasOwnProperty.call(this.members, id)) {
	            return {
	                id: id,
	                info: this.members[id]
	            };
	        }
	        else {
	            return null;
	        }
	    };
	    Members.prototype.each = function (callback) {
	        var _this = this;
	        objectApply(this.members, function (member, id) {
	            callback(_this.get(id));
	        });
	    };
	    Members.prototype.setMyID = function (id) {
	        this.myID = id;
	    };
	    Members.prototype.onSubscription = function (subscriptionData) {
	        this.members = subscriptionData.presence.hash;
	        this.count = subscriptionData.presence.count;
	        this.me = this.get(this.myID);
	    };
	    Members.prototype.addMember = function (memberData) {
	        if (this.get(memberData.user_id) === null) {
	            this.count++;
	        }
	        this.members[memberData.user_id] = memberData.user_info;
	        return this.get(memberData.user_id);
	    };
	    Members.prototype.removeMember = function (memberData) {
	        var member = this.get(memberData.user_id);
	        if (member) {
	            delete this.members[memberData.user_id];
	            this.count--;
	        }
	        return member;
	    };
	    Members.prototype.reset = function () {
	        this.members = {};
	        this.count = 0;
	        this.myID = null;
	        this.me = null;
	    };
	    return Members;
	}());
	/* harmony default export */ var members = (members_Members);

	// CONCATENATED MODULE: ./src/core/channels/presence_channel.ts
	var presence_channel_extends = (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();




	var presence_channel_PresenceChannel = (function (_super) {
	    presence_channel_extends(PresenceChannel, _super);
	    function PresenceChannel(name, pusher) {
	        var _this = _super.call(this, name, pusher) || this;
	        _this.members = new members();
	        return _this;
	    }
	    PresenceChannel.prototype.authorize = function (socketId, callback) {
	        var _this = this;
	        _super.prototype.authorize.call(this, socketId, function (error, authData) {
	            if (!error) {
	                authData = authData;
	                if (authData.channel_data === undefined) {
	                    var suffix = url_store.buildLogSuffix('authenticationEndpoint');
	                    logger.error("Invalid auth response for channel '" + _this.name + "'," +
	                        ("expected 'channel_data' field. " + suffix));
	                    callback('Invalid auth response');
	                    return;
	                }
	                var channelData = JSON.parse(authData.channel_data);
	                _this.members.setMyID(channelData.user_id);
	            }
	            callback(error, authData);
	        });
	    };
	    PresenceChannel.prototype.handleEvent = function (event) {
	        var eventName = event.event;
	        if (eventName.indexOf('pusher_internal:') === 0) {
	            this.handleInternalEvent(event);
	        }
	        else {
	            var data = event.data;
	            var metadata = {};
	            if (event.user_id) {
	                metadata.user_id = event.user_id;
	            }
	            this.emit(eventName, data, metadata);
	        }
	    };
	    PresenceChannel.prototype.handleInternalEvent = function (event) {
	        var eventName = event.event;
	        var data = event.data;
	        switch (eventName) {
	            case 'pusher_internal:subscription_succeeded':
	                this.handleSubscriptionSucceededEvent(event);
	                break;
	            case 'pusher_internal:member_added':
	                var addedMember = this.members.addMember(data);
	                this.emit('pusher:member_added', addedMember);
	                break;
	            case 'pusher_internal:member_removed':
	                var removedMember = this.members.removeMember(data);
	                if (removedMember) {
	                    this.emit('pusher:member_removed', removedMember);
	                }
	                break;
	        }
	    };
	    PresenceChannel.prototype.handleSubscriptionSucceededEvent = function (event) {
	        this.subscriptionPending = false;
	        this.subscribed = true;
	        if (this.subscriptionCancelled) {
	            this.pusher.unsubscribe(this.name);
	        }
	        else {
	            this.members.onSubscription(event.data);
	            this.emit('pusher:subscription_succeeded', this.members);
	        }
	    };
	    PresenceChannel.prototype.disconnect = function () {
	        this.members.reset();
	        _super.prototype.disconnect.call(this);
	    };
	    return PresenceChannel;
	}(private_channel));
	/* harmony default export */ var presence_channel = (presence_channel_PresenceChannel);

	// EXTERNAL MODULE: ./node_modules/@stablelib/utf8/lib/utf8.js
	var utf8 = __webpack_require__(1);

	// EXTERNAL MODULE: ./node_modules/@stablelib/base64/lib/base64.js
	var base64 = __webpack_require__(0);

	// CONCATENATED MODULE: ./src/core/channels/encrypted_channel.ts
	var encrypted_channel_extends = (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();





	var encrypted_channel_EncryptedChannel = (function (_super) {
	    encrypted_channel_extends(EncryptedChannel, _super);
	    function EncryptedChannel(name, pusher, nacl) {
	        var _this = _super.call(this, name, pusher) || this;
	        _this.key = null;
	        _this.nacl = nacl;
	        return _this;
	    }
	    EncryptedChannel.prototype.authorize = function (socketId, callback) {
	        var _this = this;
	        _super.prototype.authorize.call(this, socketId, function (error, authData) {
	            if (error) {
	                callback(error, authData);
	                return;
	            }
	            var sharedSecret = authData['shared_secret'];
	            if (!sharedSecret) {
	                callback(new Error("No shared_secret key in auth payload for encrypted channel: " + _this.name), null);
	                return;
	            }
	            _this.key = Object(base64["decode"])(sharedSecret);
	            delete authData['shared_secret'];
	            callback(null, authData);
	        });
	    };
	    EncryptedChannel.prototype.trigger = function (event, data) {
	        throw new UnsupportedFeature('Client events are not currently supported for encrypted channels');
	    };
	    EncryptedChannel.prototype.handleEvent = function (event) {
	        var eventName = event.event;
	        var data = event.data;
	        if (eventName.indexOf('pusher_internal:') === 0 ||
	            eventName.indexOf('pusher:') === 0) {
	            _super.prototype.handleEvent.call(this, event);
	            return;
	        }
	        this.handleEncryptedEvent(eventName, data);
	    };
	    EncryptedChannel.prototype.handleEncryptedEvent = function (event, data) {
	        var _this = this;
	        if (!this.key) {
	            logger.debug('Received encrypted event before key has been retrieved from the authEndpoint');
	            return;
	        }
	        if (!data.ciphertext || !data.nonce) {
	            logger.error('Unexpected format for encrypted event, expected object with `ciphertext` and `nonce` fields, got: ' +
	                data);
	            return;
	        }
	        var cipherText = Object(base64["decode"])(data.ciphertext);
	        if (cipherText.length < this.nacl.secretbox.overheadLength) {
	            logger.error("Expected encrypted event ciphertext length to be " + this.nacl.secretbox.overheadLength + ", got: " + cipherText.length);
	            return;
	        }
	        var nonce = Object(base64["decode"])(data.nonce);
	        if (nonce.length < this.nacl.secretbox.nonceLength) {
	            logger.error("Expected encrypted event nonce length to be " + this.nacl.secretbox.nonceLength + ", got: " + nonce.length);
	            return;
	        }
	        var bytes = this.nacl.secretbox.open(cipherText, nonce, this.key);
	        if (bytes === null) {
	            logger.debug('Failed to decrypt an event, probably because it was encrypted with a different key. Fetching a new key from the authEndpoint...');
	            this.authorize(this.pusher.connection.socket_id, function (error, authData) {
	                if (error) {
	                    logger.error("Failed to make a request to the authEndpoint: " + authData + ". Unable to fetch new key, so dropping encrypted event");
	                    return;
	                }
	                bytes = _this.nacl.secretbox.open(cipherText, nonce, _this.key);
	                if (bytes === null) {
	                    logger.error("Failed to decrypt event with new key. Dropping encrypted event");
	                    return;
	                }
	                _this.emit(event, _this.getDataToEmit(bytes));
	                return;
	            });
	            return;
	        }
	        this.emit(event, this.getDataToEmit(bytes));
	    };
	    EncryptedChannel.prototype.getDataToEmit = function (bytes) {
	        var raw = Object(utf8["decode"])(bytes);
	        try {
	            return JSON.parse(raw);
	        }
	        catch (_a) {
	            return raw;
	        }
	    };
	    return EncryptedChannel;
	}(private_channel));
	/* harmony default export */ var encrypted_channel = (encrypted_channel_EncryptedChannel);

	// CONCATENATED MODULE: ./src/core/connection/connection_manager.ts
	var connection_manager_extends = (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();





	var connection_manager_ConnectionManager = (function (_super) {
	    connection_manager_extends(ConnectionManager, _super);
	    function ConnectionManager(key, options) {
	        var _this = _super.call(this) || this;
	        _this.state = 'initialized';
	        _this.connection = null;
	        _this.key = key;
	        _this.options = options;
	        _this.timeline = _this.options.timeline;
	        _this.usingTLS = _this.options.useTLS;
	        _this.errorCallbacks = _this.buildErrorCallbacks();
	        _this.connectionCallbacks = _this.buildConnectionCallbacks(_this.errorCallbacks);
	        _this.handshakeCallbacks = _this.buildHandshakeCallbacks(_this.errorCallbacks);
	        var Network = runtime.getNetwork();
	        Network.bind('online', function () {
	            _this.timeline.info({ netinfo: 'online' });
	            if (_this.state === 'connecting' || _this.state === 'unavailable') {
	                _this.retryIn(0);
	            }
	        });
	        Network.bind('offline', function () {
	            _this.timeline.info({ netinfo: 'offline' });
	            if (_this.connection) {
	                _this.sendActivityCheck();
	            }
	        });
	        _this.updateStrategy();
	        return _this;
	    }
	    ConnectionManager.prototype.connect = function () {
	        if (this.connection || this.runner) {
	            return;
	        }
	        if (!this.strategy.isSupported()) {
	            this.updateState('failed');
	            return;
	        }
	        this.updateState('connecting');
	        this.startConnecting();
	        this.setUnavailableTimer();
	    };
	    ConnectionManager.prototype.send = function (data) {
	        if (this.connection) {
	            return this.connection.send(data);
	        }
	        else {
	            return false;
	        }
	    };
	    ConnectionManager.prototype.send_event = function (name, data, channel) {
	        if (this.connection) {
	            return this.connection.send_event(name, data, channel);
	        }
	        else {
	            return false;
	        }
	    };
	    ConnectionManager.prototype.disconnect = function () {
	        this.disconnectInternally();
	        this.updateState('disconnected');
	    };
	    ConnectionManager.prototype.isUsingTLS = function () {
	        return this.usingTLS;
	    };
	    ConnectionManager.prototype.startConnecting = function () {
	        var _this = this;
	        var callback = function (error, handshake) {
	            if (error) {
	                _this.runner = _this.strategy.connect(0, callback);
	            }
	            else {
	                if (handshake.action === 'error') {
	                    _this.emit('error', {
	                        type: 'HandshakeError',
	                        error: handshake.error
	                    });
	                    _this.timeline.error({ handshakeError: handshake.error });
	                }
	                else {
	                    _this.abortConnecting();
	                    _this.handshakeCallbacks[handshake.action](handshake);
	                }
	            }
	        };
	        this.runner = this.strategy.connect(0, callback);
	    };
	    ConnectionManager.prototype.abortConnecting = function () {
	        if (this.runner) {
	            this.runner.abort();
	            this.runner = null;
	        }
	    };
	    ConnectionManager.prototype.disconnectInternally = function () {
	        this.abortConnecting();
	        this.clearRetryTimer();
	        this.clearUnavailableTimer();
	        if (this.connection) {
	            var connection = this.abandonConnection();
	            connection.close();
	        }
	    };
	    ConnectionManager.prototype.updateStrategy = function () {
	        this.strategy = this.options.getStrategy({
	            key: this.key,
	            timeline: this.timeline,
	            useTLS: this.usingTLS
	        });
	    };
	    ConnectionManager.prototype.retryIn = function (delay) {
	        var _this = this;
	        this.timeline.info({ action: 'retry', delay: delay });
	        if (delay > 0) {
	            this.emit('connecting_in', Math.round(delay / 1000));
	        }
	        this.retryTimer = new OneOffTimer(delay || 0, function () {
	            _this.disconnectInternally();
	            _this.connect();
	        });
	    };
	    ConnectionManager.prototype.clearRetryTimer = function () {
	        if (this.retryTimer) {
	            this.retryTimer.ensureAborted();
	            this.retryTimer = null;
	        }
	    };
	    ConnectionManager.prototype.setUnavailableTimer = function () {
	        var _this = this;
	        this.unavailableTimer = new OneOffTimer(this.options.unavailableTimeout, function () {
	            _this.updateState('unavailable');
	        });
	    };
	    ConnectionManager.prototype.clearUnavailableTimer = function () {
	        if (this.unavailableTimer) {
	            this.unavailableTimer.ensureAborted();
	        }
	    };
	    ConnectionManager.prototype.sendActivityCheck = function () {
	        var _this = this;
	        this.stopActivityCheck();
	        this.connection.ping();
	        this.activityTimer = new OneOffTimer(this.options.pongTimeout, function () {
	            _this.timeline.error({ pong_timed_out: _this.options.pongTimeout });
	            _this.retryIn(0);
	        });
	    };
	    ConnectionManager.prototype.resetActivityCheck = function () {
	        var _this = this;
	        this.stopActivityCheck();
	        if (this.connection && !this.connection.handlesActivityChecks()) {
	            this.activityTimer = new OneOffTimer(this.activityTimeout, function () {
	                _this.sendActivityCheck();
	            });
	        }
	    };
	    ConnectionManager.prototype.stopActivityCheck = function () {
	        if (this.activityTimer) {
	            this.activityTimer.ensureAborted();
	        }
	    };
	    ConnectionManager.prototype.buildConnectionCallbacks = function (errorCallbacks) {
	        var _this = this;
	        return extend({}, errorCallbacks, {
	            message: function (message) {
	                _this.resetActivityCheck();
	                _this.emit('message', message);
	            },
	            ping: function () {
	                _this.send_event('pusher:pong', {});
	            },
	            activity: function () {
	                _this.resetActivityCheck();
	            },
	            error: function (error) {
	                _this.emit('error', error);
	            },
	            closed: function () {
	                _this.abandonConnection();
	                if (_this.shouldRetry()) {
	                    _this.retryIn(1000);
	                }
	            }
	        });
	    };
	    ConnectionManager.prototype.buildHandshakeCallbacks = function (errorCallbacks) {
	        var _this = this;
	        return extend({}, errorCallbacks, {
	            connected: function (handshake) {
	                _this.activityTimeout = Math.min(_this.options.activityTimeout, handshake.activityTimeout, handshake.connection.activityTimeout || Infinity);
	                _this.clearUnavailableTimer();
	                _this.setConnection(handshake.connection);
	                _this.socket_id = _this.connection.id;
	                _this.updateState('connected', { socket_id: _this.socket_id });
	            }
	        });
	    };
	    ConnectionManager.prototype.buildErrorCallbacks = function () {
	        var _this = this;
	        var withErrorEmitted = function (callback) {
	            return function (result) {
	                if (result.error) {
	                    _this.emit('error', { type: 'WebSocketError', error: result.error });
	                }
	                callback(result);
	            };
	        };
	        return {
	            tls_only: withErrorEmitted(function () {
	                _this.usingTLS = true;
	                _this.updateStrategy();
	                _this.retryIn(0);
	            }),
	            refused: withErrorEmitted(function () {
	                _this.disconnect();
	            }),
	            backoff: withErrorEmitted(function () {
	                _this.retryIn(1000);
	            }),
	            retry: withErrorEmitted(function () {
	                _this.retryIn(0);
	            })
	        };
	    };
	    ConnectionManager.prototype.setConnection = function (connection) {
	        this.connection = connection;
	        for (var event in this.connectionCallbacks) {
	            this.connection.bind(event, this.connectionCallbacks[event]);
	        }
	        this.resetActivityCheck();
	    };
	    ConnectionManager.prototype.abandonConnection = function () {
	        if (!this.connection) {
	            return;
	        }
	        this.stopActivityCheck();
	        for (var event in this.connectionCallbacks) {
	            this.connection.unbind(event, this.connectionCallbacks[event]);
	        }
	        var connection = this.connection;
	        this.connection = null;
	        return connection;
	    };
	    ConnectionManager.prototype.updateState = function (newState, data) {
	        var previousState = this.state;
	        this.state = newState;
	        if (previousState !== newState) {
	            var newStateDescription = newState;
	            if (newStateDescription === 'connected') {
	                newStateDescription += ' with new socket ID ' + data.socket_id;
	            }
	            logger.debug('State changed', previousState + ' -> ' + newStateDescription);
	            this.timeline.info({ state: newState, params: data });
	            this.emit('state_change', { previous: previousState, current: newState });
	            this.emit(newState, data);
	        }
	    };
	    ConnectionManager.prototype.shouldRetry = function () {
	        return this.state === 'connecting' || this.state === 'connected';
	    };
	    return ConnectionManager;
	}(dispatcher));
	/* harmony default export */ var connection_manager = (connection_manager_ConnectionManager);

	// CONCATENATED MODULE: ./src/core/channels/channels.ts




	var channels_Channels = (function () {
	    function Channels() {
	        this.channels = {};
	    }
	    Channels.prototype.add = function (name, pusher) {
	        if (!this.channels[name]) {
	            this.channels[name] = createChannel(name, pusher);
	        }
	        return this.channels[name];
	    };
	    Channels.prototype.all = function () {
	        return values(this.channels);
	    };
	    Channels.prototype.find = function (name) {
	        return this.channels[name];
	    };
	    Channels.prototype.remove = function (name) {
	        var channel = this.channels[name];
	        delete this.channels[name];
	        return channel;
	    };
	    Channels.prototype.disconnect = function () {
	        objectApply(this.channels, function (channel) {
	            channel.disconnect();
	        });
	    };
	    return Channels;
	}());
	/* harmony default export */ var channels = (channels_Channels);
	function createChannel(name, pusher) {
	    if (name.indexOf('private-encrypted-') === 0) {
	        if (pusher.config.nacl) {
	            return factory.createEncryptedChannel(name, pusher, pusher.config.nacl);
	        }
	        var errMsg = 'Tried to subscribe to a private-encrypted- channel but no nacl implementation available';
	        var suffix = url_store.buildLogSuffix('encryptedChannelSupport');
	        throw new UnsupportedFeature(errMsg + ". " + suffix);
	    }
	    else if (name.indexOf('private-') === 0) {
	        return factory.createPrivateChannel(name, pusher);
	    }
	    else if (name.indexOf('presence-') === 0) {
	        return factory.createPresenceChannel(name, pusher);
	    }
	    else {
	        return factory.createChannel(name, pusher);
	    }
	}

	// CONCATENATED MODULE: ./src/core/utils/factory.ts










	var Factory = {
	    createChannels: function () {
	        return new channels();
	    },
	    createConnectionManager: function (key, options) {
	        return new connection_manager(key, options);
	    },
	    createChannel: function (name, pusher) {
	        return new channels_channel(name, pusher);
	    },
	    createPrivateChannel: function (name, pusher) {
	        return new private_channel(name, pusher);
	    },
	    createPresenceChannel: function (name, pusher) {
	        return new presence_channel(name, pusher);
	    },
	    createEncryptedChannel: function (name, pusher, nacl) {
	        return new encrypted_channel(name, pusher, nacl);
	    },
	    createTimelineSender: function (timeline, options) {
	        return new timeline_sender(timeline, options);
	    },
	    createAuthorizer: function (channel, options) {
	        if (options.authorizer) {
	            return options.authorizer(channel, options);
	        }
	        return new pusher_authorizer(channel, options);
	    },
	    createHandshake: function (transport, callback) {
	        return new connection_handshake(transport, callback);
	    },
	    createAssistantToTheTransportManager: function (manager, transport, options) {
	        return new assistant_to_the_transport_manager(manager, transport, options);
	    }
	};
	/* harmony default export */ var factory = (Factory);

	// CONCATENATED MODULE: ./src/core/transports/transport_manager.ts

	var transport_manager_TransportManager = (function () {
	    function TransportManager(options) {
	        this.options = options || {};
	        this.livesLeft = this.options.lives || Infinity;
	    }
	    TransportManager.prototype.getAssistant = function (transport) {
	        return factory.createAssistantToTheTransportManager(this, transport, {
	            minPingDelay: this.options.minPingDelay,
	            maxPingDelay: this.options.maxPingDelay
	        });
	    };
	    TransportManager.prototype.isAlive = function () {
	        return this.livesLeft > 0;
	    };
	    TransportManager.prototype.reportDeath = function () {
	        this.livesLeft -= 1;
	    };
	    return TransportManager;
	}());
	/* harmony default export */ var transport_manager = (transport_manager_TransportManager);

	// CONCATENATED MODULE: ./src/core/strategies/sequential_strategy.ts



	var sequential_strategy_SequentialStrategy = (function () {
	    function SequentialStrategy(strategies, options) {
	        this.strategies = strategies;
	        this.loop = Boolean(options.loop);
	        this.failFast = Boolean(options.failFast);
	        this.timeout = options.timeout;
	        this.timeoutLimit = options.timeoutLimit;
	    }
	    SequentialStrategy.prototype.isSupported = function () {
	        return any(this.strategies, util.method('isSupported'));
	    };
	    SequentialStrategy.prototype.connect = function (minPriority, callback) {
	        var _this = this;
	        var strategies = this.strategies;
	        var current = 0;
	        var timeout = this.timeout;
	        var runner = null;
	        var tryNextStrategy = function (error, handshake) {
	            if (handshake) {
	                callback(null, handshake);
	            }
	            else {
	                current = current + 1;
	                if (_this.loop) {
	                    current = current % strategies.length;
	                }
	                if (current < strategies.length) {
	                    if (timeout) {
	                        timeout = timeout * 2;
	                        if (_this.timeoutLimit) {
	                            timeout = Math.min(timeout, _this.timeoutLimit);
	                        }
	                    }
	                    runner = _this.tryStrategy(strategies[current], minPriority, { timeout: timeout, failFast: _this.failFast }, tryNextStrategy);
	                }
	                else {
	                    callback(true);
	                }
	            }
	        };
	        runner = this.tryStrategy(strategies[current], minPriority, { timeout: timeout, failFast: this.failFast }, tryNextStrategy);
	        return {
	            abort: function () {
	                runner.abort();
	            },
	            forceMinPriority: function (p) {
	                minPriority = p;
	                if (runner) {
	                    runner.forceMinPriority(p);
	                }
	            }
	        };
	    };
	    SequentialStrategy.prototype.tryStrategy = function (strategy, minPriority, options, callback) {
	        var timer = null;
	        var runner = null;
	        if (options.timeout > 0) {
	            timer = new OneOffTimer(options.timeout, function () {
	                runner.abort();
	                callback(true);
	            });
	        }
	        runner = strategy.connect(minPriority, function (error, handshake) {
	            if (error && timer && timer.isRunning() && !options.failFast) {
	                return;
	            }
	            if (timer) {
	                timer.ensureAborted();
	            }
	            callback(error, handshake);
	        });
	        return {
	            abort: function () {
	                if (timer) {
	                    timer.ensureAborted();
	                }
	                runner.abort();
	            },
	            forceMinPriority: function (p) {
	                runner.forceMinPriority(p);
	            }
	        };
	    };
	    return SequentialStrategy;
	}());
	/* harmony default export */ var sequential_strategy = (sequential_strategy_SequentialStrategy);

	// CONCATENATED MODULE: ./src/core/strategies/best_connected_ever_strategy.ts


	var best_connected_ever_strategy_BestConnectedEverStrategy = (function () {
	    function BestConnectedEverStrategy(strategies) {
	        this.strategies = strategies;
	    }
	    BestConnectedEverStrategy.prototype.isSupported = function () {
	        return any(this.strategies, util.method('isSupported'));
	    };
	    BestConnectedEverStrategy.prototype.connect = function (minPriority, callback) {
	        return connect(this.strategies, minPriority, function (i, runners) {
	            return function (error, handshake) {
	                runners[i].error = error;
	                if (error) {
	                    if (allRunnersFailed(runners)) {
	                        callback(true);
	                    }
	                    return;
	                }
	                apply(runners, function (runner) {
	                    runner.forceMinPriority(handshake.transport.priority);
	                });
	                callback(null, handshake);
	            };
	        });
	    };
	    return BestConnectedEverStrategy;
	}());
	/* harmony default export */ var best_connected_ever_strategy = (best_connected_ever_strategy_BestConnectedEverStrategy);
	function connect(strategies, minPriority, callbackBuilder) {
	    var runners = map(strategies, function (strategy, i, _, rs) {
	        return strategy.connect(minPriority, callbackBuilder(i, rs));
	    });
	    return {
	        abort: function () {
	            apply(runners, abortRunner);
	        },
	        forceMinPriority: function (p) {
	            apply(runners, function (runner) {
	                runner.forceMinPriority(p);
	            });
	        }
	    };
	}
	function allRunnersFailed(runners) {
	    return collections_all(runners, function (runner) {
	        return Boolean(runner.error);
	    });
	}
	function abortRunner(runner) {
	    if (!runner.error && !runner.aborted) {
	        runner.abort();
	        runner.aborted = true;
	    }
	}

	// CONCATENATED MODULE: ./src/core/strategies/cached_strategy.ts




	var cached_strategy_CachedStrategy = (function () {
	    function CachedStrategy(strategy, transports, options) {
	        this.strategy = strategy;
	        this.transports = transports;
	        this.ttl = options.ttl || 1800 * 1000;
	        this.usingTLS = options.useTLS;
	        this.timeline = options.timeline;
	    }
	    CachedStrategy.prototype.isSupported = function () {
	        return this.strategy.isSupported();
	    };
	    CachedStrategy.prototype.connect = function (minPriority, callback) {
	        var usingTLS = this.usingTLS;
	        var info = fetchTransportCache(usingTLS);
	        var strategies = [this.strategy];
	        if (info && info.timestamp + this.ttl >= util.now()) {
	            var transport = this.transports[info.transport];
	            if (transport) {
	                this.timeline.info({
	                    cached: true,
	                    transport: info.transport,
	                    latency: info.latency
	                });
	                strategies.push(new sequential_strategy([transport], {
	                    timeout: info.latency * 2 + 1000,
	                    failFast: true
	                }));
	            }
	        }
	        var startTimestamp = util.now();
	        var runner = strategies
	            .pop()
	            .connect(minPriority, function cb(error, handshake) {
	            if (error) {
	                flushTransportCache(usingTLS);
	                if (strategies.length > 0) {
	                    startTimestamp = util.now();
	                    runner = strategies.pop().connect(minPriority, cb);
	                }
	                else {
	                    callback(error);
	                }
	            }
	            else {
	                storeTransportCache(usingTLS, handshake.transport.name, util.now() - startTimestamp);
	                callback(null, handshake);
	            }
	        });
	        return {
	            abort: function () {
	                runner.abort();
	            },
	            forceMinPriority: function (p) {
	                minPriority = p;
	                if (runner) {
	                    runner.forceMinPriority(p);
	                }
	            }
	        };
	    };
	    return CachedStrategy;
	}());
	/* harmony default export */ var cached_strategy = (cached_strategy_CachedStrategy);
	function getTransportCacheKey(usingTLS) {
	    return 'pusherTransport' + (usingTLS ? 'TLS' : 'NonTLS');
	}
	function fetchTransportCache(usingTLS) {
	    var storage = runtime.getLocalStorage();
	    if (storage) {
	        try {
	            var serializedCache = storage[getTransportCacheKey(usingTLS)];
	            if (serializedCache) {
	                return JSON.parse(serializedCache);
	            }
	        }
	        catch (e) {
	            flushTransportCache(usingTLS);
	        }
	    }
	    return null;
	}
	function storeTransportCache(usingTLS, transport, latency) {
	    var storage = runtime.getLocalStorage();
	    if (storage) {
	        try {
	            storage[getTransportCacheKey(usingTLS)] = safeJSONStringify({
	                timestamp: util.now(),
	                transport: transport,
	                latency: latency
	            });
	        }
	        catch (e) {
	        }
	    }
	}
	function flushTransportCache(usingTLS) {
	    var storage = runtime.getLocalStorage();
	    if (storage) {
	        try {
	            delete storage[getTransportCacheKey(usingTLS)];
	        }
	        catch (e) {
	        }
	    }
	}

	// CONCATENATED MODULE: ./src/core/strategies/delayed_strategy.ts

	var delayed_strategy_DelayedStrategy = (function () {
	    function DelayedStrategy(strategy, _a) {
	        var number = _a.delay;
	        this.strategy = strategy;
	        this.options = { delay: number };
	    }
	    DelayedStrategy.prototype.isSupported = function () {
	        return this.strategy.isSupported();
	    };
	    DelayedStrategy.prototype.connect = function (minPriority, callback) {
	        var strategy = this.strategy;
	        var runner;
	        var timer = new OneOffTimer(this.options.delay, function () {
	            runner = strategy.connect(minPriority, callback);
	        });
	        return {
	            abort: function () {
	                timer.ensureAborted();
	                if (runner) {
	                    runner.abort();
	                }
	            },
	            forceMinPriority: function (p) {
	                minPriority = p;
	                if (runner) {
	                    runner.forceMinPriority(p);
	                }
	            }
	        };
	    };
	    return DelayedStrategy;
	}());
	/* harmony default export */ var delayed_strategy = (delayed_strategy_DelayedStrategy);

	// CONCATENATED MODULE: ./src/core/strategies/if_strategy.ts
	var IfStrategy = (function () {
	    function IfStrategy(test, trueBranch, falseBranch) {
	        this.test = test;
	        this.trueBranch = trueBranch;
	        this.falseBranch = falseBranch;
	    }
	    IfStrategy.prototype.isSupported = function () {
	        var branch = this.test() ? this.trueBranch : this.falseBranch;
	        return branch.isSupported();
	    };
	    IfStrategy.prototype.connect = function (minPriority, callback) {
	        var branch = this.test() ? this.trueBranch : this.falseBranch;
	        return branch.connect(minPriority, callback);
	    };
	    return IfStrategy;
	}());
	/* harmony default export */ var if_strategy = (IfStrategy);

	// CONCATENATED MODULE: ./src/core/strategies/first_connected_strategy.ts
	var FirstConnectedStrategy = (function () {
	    function FirstConnectedStrategy(strategy) {
	        this.strategy = strategy;
	    }
	    FirstConnectedStrategy.prototype.isSupported = function () {
	        return this.strategy.isSupported();
	    };
	    FirstConnectedStrategy.prototype.connect = function (minPriority, callback) {
	        var runner = this.strategy.connect(minPriority, function (error, handshake) {
	            if (handshake) {
	                runner.abort();
	            }
	            callback(error, handshake);
	        });
	        return runner;
	    };
	    return FirstConnectedStrategy;
	}());
	/* harmony default export */ var first_connected_strategy = (FirstConnectedStrategy);

	// CONCATENATED MODULE: ./src/runtimes/web/default_strategy.ts







	function testSupportsStrategy(strategy) {
	    return function () {
	        return strategy.isSupported();
	    };
	}
	var getDefaultStrategy = function (config, baseOptions, defineTransport) {
	    var definedTransports = {};
	    function defineTransportStrategy(name, type, priority, options, manager) {
	        var transport = defineTransport(config, name, type, priority, options, manager);
	        definedTransports[name] = transport;
	        return transport;
	    }
	    var ws_options = Object.assign({}, baseOptions, {
	        hostNonTLS: config.wsHost + ':' + config.wsPort,
	        hostTLS: config.wsHost + ':' + config.wssPort,
	        httpPath: config.wsPath
	    });
	    var wss_options = Object.assign({}, ws_options, {
	        useTLS: true
	    });
	    var sockjs_options = Object.assign({}, baseOptions, {
	        hostNonTLS: config.httpHost + ':' + config.httpPort,
	        hostTLS: config.httpHost + ':' + config.httpsPort,
	        httpPath: config.httpPath
	    });
	    var timeouts = {
	        loop: true,
	        timeout: 15000,
	        timeoutLimit: 60000
	    };
	    var ws_manager = new transport_manager({
	        lives: 2,
	        minPingDelay: 10000,
	        maxPingDelay: config.activityTimeout
	    });
	    var streaming_manager = new transport_manager({
	        lives: 2,
	        minPingDelay: 10000,
	        maxPingDelay: config.activityTimeout
	    });
	    var ws_transport = defineTransportStrategy('ws', 'ws', 3, ws_options, ws_manager);
	    var wss_transport = defineTransportStrategy('wss', 'ws', 3, wss_options, ws_manager);
	    var sockjs_transport = defineTransportStrategy('sockjs', 'sockjs', 1, sockjs_options);
	    var xhr_streaming_transport = defineTransportStrategy('xhr_streaming', 'xhr_streaming', 1, sockjs_options, streaming_manager);
	    var xdr_streaming_transport = defineTransportStrategy('xdr_streaming', 'xdr_streaming', 1, sockjs_options, streaming_manager);
	    var xhr_polling_transport = defineTransportStrategy('xhr_polling', 'xhr_polling', 1, sockjs_options);
	    var xdr_polling_transport = defineTransportStrategy('xdr_polling', 'xdr_polling', 1, sockjs_options);
	    var ws_loop = new sequential_strategy([ws_transport], timeouts);
	    var wss_loop = new sequential_strategy([wss_transport], timeouts);
	    var sockjs_loop = new sequential_strategy([sockjs_transport], timeouts);
	    var streaming_loop = new sequential_strategy([
	        new if_strategy(testSupportsStrategy(xhr_streaming_transport), xhr_streaming_transport, xdr_streaming_transport)
	    ], timeouts);
	    var polling_loop = new sequential_strategy([
	        new if_strategy(testSupportsStrategy(xhr_polling_transport), xhr_polling_transport, xdr_polling_transport)
	    ], timeouts);
	    var http_loop = new sequential_strategy([
	        new if_strategy(testSupportsStrategy(streaming_loop), new best_connected_ever_strategy([
	            streaming_loop,
	            new delayed_strategy(polling_loop, { delay: 4000 })
	        ]), polling_loop)
	    ], timeouts);
	    var http_fallback_loop = new if_strategy(testSupportsStrategy(http_loop), http_loop, sockjs_loop);
	    var wsStrategy;
	    if (baseOptions.useTLS) {
	        wsStrategy = new best_connected_ever_strategy([
	            ws_loop,
	            new delayed_strategy(http_fallback_loop, { delay: 2000 })
	        ]);
	    }
	    else {
	        wsStrategy = new best_connected_ever_strategy([
	            ws_loop,
	            new delayed_strategy(wss_loop, { delay: 2000 }),
	            new delayed_strategy(http_fallback_loop, { delay: 5000 })
	        ]);
	    }
	    return new cached_strategy(new first_connected_strategy(new if_strategy(testSupportsStrategy(ws_transport), wsStrategy, http_fallback_loop)), definedTransports, {
	        ttl: 1800000,
	        timeline: baseOptions.timeline,
	        useTLS: baseOptions.useTLS
	    });
	};
	/* harmony default export */ var default_strategy = (getDefaultStrategy);

	// CONCATENATED MODULE: ./src/runtimes/web/transports/transport_connection_initializer.ts

	/* harmony default export */ var transport_connection_initializer = (function () {
	    var self = this;
	    self.timeline.info(self.buildTimelineMessage({
	        transport: self.name + (self.options.useTLS ? 's' : '')
	    }));
	    if (self.hooks.isInitialized()) {
	        self.changeState('initialized');
	    }
	    else if (self.hooks.file) {
	        self.changeState('initializing');
	        Dependencies.load(self.hooks.file, { useTLS: self.options.useTLS }, function (error, callback) {
	            if (self.hooks.isInitialized()) {
	                self.changeState('initialized');
	                callback(true);
	            }
	            else {
	                if (error) {
	                    self.onError(error);
	                }
	                self.onClose();
	                callback(false);
	            }
	        });
	    }
	    else {
	        self.onClose();
	    }
	});

	// CONCATENATED MODULE: ./src/runtimes/web/http/http_xdomain_request.ts

	var http_xdomain_request_hooks = {
	    getRequest: function (socket) {
	        var xdr = new window.XDomainRequest();
	        xdr.ontimeout = function () {
	            socket.emit('error', new RequestTimedOut());
	            socket.close();
	        };
	        xdr.onerror = function (e) {
	            socket.emit('error', e);
	            socket.close();
	        };
	        xdr.onprogress = function () {
	            if (xdr.responseText && xdr.responseText.length > 0) {
	                socket.onChunk(200, xdr.responseText);
	            }
	        };
	        xdr.onload = function () {
	            if (xdr.responseText && xdr.responseText.length > 0) {
	                socket.onChunk(200, xdr.responseText);
	            }
	            socket.emit('finished', 200);
	            socket.close();
	        };
	        return xdr;
	    },
	    abortRequest: function (xdr) {
	        xdr.ontimeout = xdr.onerror = xdr.onprogress = xdr.onload = null;
	        xdr.abort();
	    }
	};
	/* harmony default export */ var http_xdomain_request = (http_xdomain_request_hooks);

	// CONCATENATED MODULE: ./src/core/http/http_request.ts
	var http_request_extends = (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();


	var MAX_BUFFER_LENGTH = 256 * 1024;
	var http_request_HTTPRequest = (function (_super) {
	    http_request_extends(HTTPRequest, _super);
	    function HTTPRequest(hooks, method, url) {
	        var _this = _super.call(this) || this;
	        _this.hooks = hooks;
	        _this.method = method;
	        _this.url = url;
	        return _this;
	    }
	    HTTPRequest.prototype.start = function (payload) {
	        var _this = this;
	        this.position = 0;
	        this.xhr = this.hooks.getRequest(this);
	        this.unloader = function () {
	            _this.close();
	        };
	        runtime.addUnloadListener(this.unloader);
	        this.xhr.open(this.method, this.url, true);
	        if (this.xhr.setRequestHeader) {
	            this.xhr.setRequestHeader('Content-Type', 'application/json');
	        }
	        this.xhr.send(payload);
	    };
	    HTTPRequest.prototype.close = function () {
	        if (this.unloader) {
	            runtime.removeUnloadListener(this.unloader);
	            this.unloader = null;
	        }
	        if (this.xhr) {
	            this.hooks.abortRequest(this.xhr);
	            this.xhr = null;
	        }
	    };
	    HTTPRequest.prototype.onChunk = function (status, data) {
	        while (true) {
	            var chunk = this.advanceBuffer(data);
	            if (chunk) {
	                this.emit('chunk', { status: status, data: chunk });
	            }
	            else {
	                break;
	            }
	        }
	        if (this.isBufferTooLong(data)) {
	            this.emit('buffer_too_long');
	        }
	    };
	    HTTPRequest.prototype.advanceBuffer = function (buffer) {
	        var unreadData = buffer.slice(this.position);
	        var endOfLinePosition = unreadData.indexOf('\n');
	        if (endOfLinePosition !== -1) {
	            this.position += endOfLinePosition + 1;
	            return unreadData.slice(0, endOfLinePosition);
	        }
	        else {
	            return null;
	        }
	    };
	    HTTPRequest.prototype.isBufferTooLong = function (buffer) {
	        return this.position === buffer.length && buffer.length > MAX_BUFFER_LENGTH;
	    };
	    return HTTPRequest;
	}(dispatcher));
	/* harmony default export */ var http_request = (http_request_HTTPRequest);

	// CONCATENATED MODULE: ./src/core/http/state.ts
	var State;
	(function (State) {
	    State[State["CONNECTING"] = 0] = "CONNECTING";
	    State[State["OPEN"] = 1] = "OPEN";
	    State[State["CLOSED"] = 3] = "CLOSED";
	})(State || (State = {}));
	/* harmony default export */ var state = (State);

	// CONCATENATED MODULE: ./src/core/http/http_socket.ts



	var autoIncrement = 1;
	var http_socket_HTTPSocket = (function () {
	    function HTTPSocket(hooks, url) {
	        this.hooks = hooks;
	        this.session = randomNumber(1000) + '/' + randomString(8);
	        this.location = getLocation(url);
	        this.readyState = state.CONNECTING;
	        this.openStream();
	    }
	    HTTPSocket.prototype.send = function (payload) {
	        return this.sendRaw(JSON.stringify([payload]));
	    };
	    HTTPSocket.prototype.ping = function () {
	        this.hooks.sendHeartbeat(this);
	    };
	    HTTPSocket.prototype.close = function (code, reason) {
	        this.onClose(code, reason, true);
	    };
	    HTTPSocket.prototype.sendRaw = function (payload) {
	        if (this.readyState === state.OPEN) {
	            try {
	                runtime.createSocketRequest('POST', getUniqueURL(getSendURL(this.location, this.session))).start(payload);
	                return true;
	            }
	            catch (e) {
	                return false;
	            }
	        }
	        else {
	            return false;
	        }
	    };
	    HTTPSocket.prototype.reconnect = function () {
	        this.closeStream();
	        this.openStream();
	    };
	    HTTPSocket.prototype.onClose = function (code, reason, wasClean) {
	        this.closeStream();
	        this.readyState = state.CLOSED;
	        if (this.onclose) {
	            this.onclose({
	                code: code,
	                reason: reason,
	                wasClean: wasClean
	            });
	        }
	    };
	    HTTPSocket.prototype.onChunk = function (chunk) {
	        if (chunk.status !== 200) {
	            return;
	        }
	        if (this.readyState === state.OPEN) {
	            this.onActivity();
	        }
	        var payload;
	        var type = chunk.data.slice(0, 1);
	        switch (type) {
	            case 'o':
	                payload = JSON.parse(chunk.data.slice(1) || '{}');
	                this.onOpen(payload);
	                break;
	            case 'a':
	                payload = JSON.parse(chunk.data.slice(1) || '[]');
	                for (var i = 0; i < payload.length; i++) {
	                    this.onEvent(payload[i]);
	                }
	                break;
	            case 'm':
	                payload = JSON.parse(chunk.data.slice(1) || 'null');
	                this.onEvent(payload);
	                break;
	            case 'h':
	                this.hooks.onHeartbeat(this);
	                break;
	            case 'c':
	                payload = JSON.parse(chunk.data.slice(1) || '[]');
	                this.onClose(payload[0], payload[1], true);
	                break;
	        }
	    };
	    HTTPSocket.prototype.onOpen = function (options) {
	        if (this.readyState === state.CONNECTING) {
	            if (options && options.hostname) {
	                this.location.base = replaceHost(this.location.base, options.hostname);
	            }
	            this.readyState = state.OPEN;
	            if (this.onopen) {
	                this.onopen();
	            }
	        }
	        else {
	            this.onClose(1006, 'Server lost session', true);
	        }
	    };
	    HTTPSocket.prototype.onEvent = function (event) {
	        if (this.readyState === state.OPEN && this.onmessage) {
	            this.onmessage({ data: event });
	        }
	    };
	    HTTPSocket.prototype.onActivity = function () {
	        if (this.onactivity) {
	            this.onactivity();
	        }
	    };
	    HTTPSocket.prototype.onError = function (error) {
	        if (this.onerror) {
	            this.onerror(error);
	        }
	    };
	    HTTPSocket.prototype.openStream = function () {
	        var _this = this;
	        this.stream = runtime.createSocketRequest('POST', getUniqueURL(this.hooks.getReceiveURL(this.location, this.session)));
	        this.stream.bind('chunk', function (chunk) {
	            _this.onChunk(chunk);
	        });
	        this.stream.bind('finished', function (status) {
	            _this.hooks.onFinished(_this, status);
	        });
	        this.stream.bind('buffer_too_long', function () {
	            _this.reconnect();
	        });
	        try {
	            this.stream.start();
	        }
	        catch (error) {
	            util.defer(function () {
	                _this.onError(error);
	                _this.onClose(1006, 'Could not start streaming', false);
	            });
	        }
	    };
	    HTTPSocket.prototype.closeStream = function () {
	        if (this.stream) {
	            this.stream.unbind_all();
	            this.stream.close();
	            this.stream = null;
	        }
	    };
	    return HTTPSocket;
	}());
	function getLocation(url) {
	    var parts = /([^\?]*)\/*(\??.*)/.exec(url);
	    return {
	        base: parts[1],
	        queryString: parts[2]
	    };
	}
	function getSendURL(url, session) {
	    return url.base + '/' + session + '/xhr_send';
	}
	function getUniqueURL(url) {
	    var separator = url.indexOf('?') === -1 ? '?' : '&';
	    return url + separator + 't=' + +new Date() + '&n=' + autoIncrement++;
	}
	function replaceHost(url, hostname) {
	    var urlParts = /(https?:\/\/)([^\/:]+)((\/|:)?.*)/.exec(url);
	    return urlParts[1] + hostname + urlParts[3];
	}
	function randomNumber(max) {
	    return Math.floor(Math.random() * max);
	}
	function randomString(length) {
	    var result = [];
	    for (var i = 0; i < length; i++) {
	        result.push(randomNumber(32).toString(32));
	    }
	    return result.join('');
	}
	/* harmony default export */ var http_socket = (http_socket_HTTPSocket);

	// CONCATENATED MODULE: ./src/core/http/http_streaming_socket.ts
	var http_streaming_socket_hooks = {
	    getReceiveURL: function (url, session) {
	        return url.base + '/' + session + '/xhr_streaming' + url.queryString;
	    },
	    onHeartbeat: function (socket) {
	        socket.sendRaw('[]');
	    },
	    sendHeartbeat: function (socket) {
	        socket.sendRaw('[]');
	    },
	    onFinished: function (socket, status) {
	        socket.onClose(1006, 'Connection interrupted (' + status + ')', false);
	    }
	};
	/* harmony default export */ var http_streaming_socket = (http_streaming_socket_hooks);

	// CONCATENATED MODULE: ./src/core/http/http_polling_socket.ts
	var http_polling_socket_hooks = {
	    getReceiveURL: function (url, session) {
	        return url.base + '/' + session + '/xhr' + url.queryString;
	    },
	    onHeartbeat: function () {
	    },
	    sendHeartbeat: function (socket) {
	        socket.sendRaw('[]');
	    },
	    onFinished: function (socket, status) {
	        if (status === 200) {
	            socket.reconnect();
	        }
	        else {
	            socket.onClose(1006, 'Connection interrupted (' + status + ')', false);
	        }
	    }
	};
	/* harmony default export */ var http_polling_socket = (http_polling_socket_hooks);

	// CONCATENATED MODULE: ./src/runtimes/isomorphic/http/http_xhr_request.ts

	var http_xhr_request_hooks = {
	    getRequest: function (socket) {
	        var Constructor = runtime.getXHRAPI();
	        var xhr = new Constructor();
	        xhr.onreadystatechange = xhr.onprogress = function () {
	            switch (xhr.readyState) {
	                case 3:
	                    if (xhr.responseText && xhr.responseText.length > 0) {
	                        socket.onChunk(xhr.status, xhr.responseText);
	                    }
	                    break;
	                case 4:
	                    if (xhr.responseText && xhr.responseText.length > 0) {
	                        socket.onChunk(xhr.status, xhr.responseText);
	                    }
	                    socket.emit('finished', xhr.status);
	                    socket.close();
	                    break;
	            }
	        };
	        return xhr;
	    },
	    abortRequest: function (xhr) {
	        xhr.onreadystatechange = null;
	        xhr.abort();
	    }
	};
	/* harmony default export */ var http_xhr_request = (http_xhr_request_hooks);

	// CONCATENATED MODULE: ./src/runtimes/isomorphic/http/http.ts





	var HTTP = {
	    createStreamingSocket: function (url) {
	        return this.createSocket(http_streaming_socket, url);
	    },
	    createPollingSocket: function (url) {
	        return this.createSocket(http_polling_socket, url);
	    },
	    createSocket: function (hooks, url) {
	        return new http_socket(hooks, url);
	    },
	    createXHR: function (method, url) {
	        return this.createRequest(http_xhr_request, method, url);
	    },
	    createRequest: function (hooks, method, url) {
	        return new http_request(hooks, method, url);
	    }
	};
	/* harmony default export */ var http_http = (HTTP);

	// CONCATENATED MODULE: ./src/runtimes/web/http/http.ts


	http_http.createXDR = function (method, url) {
	    return this.createRequest(http_xdomain_request, method, url);
	};
	/* harmony default export */ var web_http_http = (http_http);

	// CONCATENATED MODULE: ./src/runtimes/web/runtime.ts












	var Runtime = {
	    nextAuthCallbackID: 1,
	    auth_callbacks: {},
	    ScriptReceivers: ScriptReceivers,
	    DependenciesReceivers: DependenciesReceivers,
	    getDefaultStrategy: default_strategy,
	    Transports: transports_transports,
	    transportConnectionInitializer: transport_connection_initializer,
	    HTTPFactory: web_http_http,
	    TimelineTransport: jsonp_timeline,
	    getXHRAPI: function () {
	        return window.XMLHttpRequest;
	    },
	    getWebSocketAPI: function () {
	        return window.WebSocket || window.MozWebSocket;
	    },
	    setup: function (PusherClass) {
	        var _this = this;
	        window.Pusher = PusherClass;
	        var initializeOnDocumentBody = function () {
	            _this.onDocumentBody(PusherClass.ready);
	        };
	        if (!window.JSON) {
	            Dependencies.load('json2', {}, initializeOnDocumentBody);
	        }
	        else {
	            initializeOnDocumentBody();
	        }
	    },
	    getDocument: function () {
	        return document;
	    },
	    getProtocol: function () {
	        return this.getDocument().location.protocol;
	    },
	    getAuthorizers: function () {
	        return { ajax: xhr_auth, jsonp: jsonp_auth };
	    },
	    onDocumentBody: function (callback) {
	        var _this = this;
	        if (document.body) {
	            callback();
	        }
	        else {
	            setTimeout(function () {
	                _this.onDocumentBody(callback);
	            }, 0);
	        }
	    },
	    createJSONPRequest: function (url, data) {
	        return new jsonp_request(url, data);
	    },
	    createScriptRequest: function (src) {
	        return new script_request(src);
	    },
	    getLocalStorage: function () {
	        try {
	            return window.localStorage;
	        }
	        catch (e) {
	            return undefined;
	        }
	    },
	    createXHR: function () {
	        if (this.getXHRAPI()) {
	            return this.createXMLHttpRequest();
	        }
	        else {
	            return this.createMicrosoftXHR();
	        }
	    },
	    createXMLHttpRequest: function () {
	        var Constructor = this.getXHRAPI();
	        return new Constructor();
	    },
	    createMicrosoftXHR: function () {
	        return new ActiveXObject('Microsoft.XMLHTTP');
	    },
	    getNetwork: function () {
	        return net_info_Network;
	    },
	    createWebSocket: function (url) {
	        var Constructor = this.getWebSocketAPI();
	        return new Constructor(url);
	    },
	    createSocketRequest: function (method, url) {
	        if (this.isXHRSupported()) {
	            return this.HTTPFactory.createXHR(method, url);
	        }
	        else if (this.isXDRSupported(url.indexOf('https:') === 0)) {
	            return this.HTTPFactory.createXDR(method, url);
	        }
	        else {
	            throw 'Cross-origin HTTP requests are not supported';
	        }
	    },
	    isXHRSupported: function () {
	        var Constructor = this.getXHRAPI();
	        return (Boolean(Constructor) && new Constructor().withCredentials !== undefined);
	    },
	    isXDRSupported: function (useTLS) {
	        var protocol = useTLS ? 'https:' : 'http:';
	        var documentProtocol = this.getProtocol();
	        return (Boolean(window['XDomainRequest']) && documentProtocol === protocol);
	    },
	    addUnloadListener: function (listener) {
	        if (window.addEventListener !== undefined) {
	            window.addEventListener('unload', listener, false);
	        }
	        else if (window.attachEvent !== undefined) {
	            window.attachEvent('onunload', listener);
	        }
	    },
	    removeUnloadListener: function (listener) {
	        if (window.addEventListener !== undefined) {
	            window.removeEventListener('unload', listener, false);
	        }
	        else if (window.detachEvent !== undefined) {
	            window.detachEvent('onunload', listener);
	        }
	    }
	};
	/* harmony default export */ var runtime = (Runtime);

	// CONCATENATED MODULE: ./src/core/timeline/level.ts
	var TimelineLevel;
	(function (TimelineLevel) {
	    TimelineLevel[TimelineLevel["ERROR"] = 3] = "ERROR";
	    TimelineLevel[TimelineLevel["INFO"] = 6] = "INFO";
	    TimelineLevel[TimelineLevel["DEBUG"] = 7] = "DEBUG";
	})(TimelineLevel || (TimelineLevel = {}));
	/* harmony default export */ var timeline_level = (TimelineLevel);

	// CONCATENATED MODULE: ./src/core/timeline/timeline.ts



	var timeline_Timeline = (function () {
	    function Timeline(key, session, options) {
	        this.key = key;
	        this.session = session;
	        this.events = [];
	        this.options = options || {};
	        this.sent = 0;
	        this.uniqueID = 0;
	    }
	    Timeline.prototype.log = function (level, event) {
	        if (level <= this.options.level) {
	            this.events.push(extend({}, event, { timestamp: util.now() }));
	            if (this.options.limit && this.events.length > this.options.limit) {
	                this.events.shift();
	            }
	        }
	    };
	    Timeline.prototype.error = function (event) {
	        this.log(timeline_level.ERROR, event);
	    };
	    Timeline.prototype.info = function (event) {
	        this.log(timeline_level.INFO, event);
	    };
	    Timeline.prototype.debug = function (event) {
	        this.log(timeline_level.DEBUG, event);
	    };
	    Timeline.prototype.isEmpty = function () {
	        return this.events.length === 0;
	    };
	    Timeline.prototype.send = function (sendfn, callback) {
	        var _this = this;
	        var data = extend({
	            session: this.session,
	            bundle: this.sent + 1,
	            key: this.key,
	            lib: 'js',
	            version: this.options.version,
	            cluster: this.options.cluster,
	            features: this.options.features,
	            timeline: this.events
	        }, this.options.params);
	        this.events = [];
	        sendfn(data, function (error, result) {
	            if (!error) {
	                _this.sent++;
	            }
	            if (callback) {
	                callback(error, result);
	            }
	        });
	        return true;
	    };
	    Timeline.prototype.generateUniqueID = function () {
	        this.uniqueID++;
	        return this.uniqueID;
	    };
	    return Timeline;
	}());
	/* harmony default export */ var timeline_timeline = (timeline_Timeline);

	// CONCATENATED MODULE: ./src/core/strategies/transport_strategy.ts




	var transport_strategy_TransportStrategy = (function () {
	    function TransportStrategy(name, priority, transport, options) {
	        this.name = name;
	        this.priority = priority;
	        this.transport = transport;
	        this.options = options || {};
	    }
	    TransportStrategy.prototype.isSupported = function () {
	        return this.transport.isSupported({
	            useTLS: this.options.useTLS
	        });
	    };
	    TransportStrategy.prototype.connect = function (minPriority, callback) {
	        var _this = this;
	        if (!this.isSupported()) {
	            return failAttempt(new UnsupportedStrategy(), callback);
	        }
	        else if (this.priority < minPriority) {
	            return failAttempt(new TransportPriorityTooLow(), callback);
	        }
	        var connected = false;
	        var transport = this.transport.createConnection(this.name, this.priority, this.options.key, this.options);
	        var handshake = null;
	        var onInitialized = function () {
	            transport.unbind('initialized', onInitialized);
	            transport.connect();
	        };
	        var onOpen = function () {
	            handshake = factory.createHandshake(transport, function (result) {
	                connected = true;
	                unbindListeners();
	                callback(null, result);
	            });
	        };
	        var onError = function (error) {
	            unbindListeners();
	            callback(error);
	        };
	        var onClosed = function () {
	            unbindListeners();
	            var serializedTransport;
	            serializedTransport = safeJSONStringify(transport);
	            callback(new TransportClosed(serializedTransport));
	        };
	        var unbindListeners = function () {
	            transport.unbind('initialized', onInitialized);
	            transport.unbind('open', onOpen);
	            transport.unbind('error', onError);
	            transport.unbind('closed', onClosed);
	        };
	        transport.bind('initialized', onInitialized);
	        transport.bind('open', onOpen);
	        transport.bind('error', onError);
	        transport.bind('closed', onClosed);
	        transport.initialize();
	        return {
	            abort: function () {
	                if (connected) {
	                    return;
	                }
	                unbindListeners();
	                if (handshake) {
	                    handshake.close();
	                }
	                else {
	                    transport.close();
	                }
	            },
	            forceMinPriority: function (p) {
	                if (connected) {
	                    return;
	                }
	                if (_this.priority < p) {
	                    if (handshake) {
	                        handshake.close();
	                    }
	                    else {
	                        transport.close();
	                    }
	                }
	            }
	        };
	    };
	    return TransportStrategy;
	}());
	/* harmony default export */ var transport_strategy = (transport_strategy_TransportStrategy);
	function failAttempt(error, callback) {
	    util.defer(function () {
	        callback(error);
	    });
	    return {
	        abort: function () { },
	        forceMinPriority: function () { }
	    };
	}

	// CONCATENATED MODULE: ./src/core/strategies/strategy_builder.ts





	var strategy_builder_Transports = runtime.Transports;
	var strategy_builder_defineTransport = function (config, name, type, priority, options, manager) {
	    var transportClass = strategy_builder_Transports[type];
	    if (!transportClass) {
	        throw new UnsupportedTransport(type);
	    }
	    var enabled = (!config.enabledTransports ||
	        arrayIndexOf(config.enabledTransports, name) !== -1) &&
	        (!config.disabledTransports ||
	            arrayIndexOf(config.disabledTransports, name) === -1);
	    var transport;
	    if (enabled) {
	        options = Object.assign({ ignoreNullOrigin: config.ignoreNullOrigin }, options);
	        transport = new transport_strategy(name, priority, manager ? manager.getAssistant(transportClass) : transportClass, options);
	    }
	    else {
	        transport = strategy_builder_UnsupportedStrategy;
	    }
	    return transport;
	};
	var strategy_builder_UnsupportedStrategy = {
	    isSupported: function () {
	        return false;
	    },
	    connect: function (_, callback) {
	        var deferred = util.defer(function () {
	            callback(new UnsupportedStrategy());
	        });
	        return {
	            abort: function () {
	                deferred.ensureAborted();
	            },
	            forceMinPriority: function () { }
	        };
	    }
	};

	// CONCATENATED MODULE: ./src/core/config.ts


	function getConfig(opts) {
	    var config = {
	        activityTimeout: opts.activityTimeout || defaults.activityTimeout,
	        authEndpoint: opts.authEndpoint || defaults.authEndpoint,
	        authTransport: opts.authTransport || defaults.authTransport,
	        cluster: opts.cluster || defaults.cluster,
	        httpPath: opts.httpPath || defaults.httpPath,
	        httpPort: opts.httpPort || defaults.httpPort,
	        httpsPort: opts.httpsPort || defaults.httpsPort,
	        pongTimeout: opts.pongTimeout || defaults.pongTimeout,
	        statsHost: opts.statsHost || defaults.stats_host,
	        unavailableTimeout: opts.unavailableTimeout || defaults.unavailableTimeout,
	        wsPath: opts.wsPath || defaults.wsPath,
	        wsPort: opts.wsPort || defaults.wsPort,
	        wssPort: opts.wssPort || defaults.wssPort,
	        enableStats: getEnableStatsConfig(opts),
	        httpHost: getHttpHost(opts),
	        useTLS: shouldUseTLS(opts),
	        wsHost: getWebsocketHost(opts)
	    };
	    if ('auth' in opts)
	        config.auth = opts.auth;
	    if ('authorizer' in opts)
	        config.authorizer = opts.authorizer;
	    if ('disabledTransports' in opts)
	        config.disabledTransports = opts.disabledTransports;
	    if ('enabledTransports' in opts)
	        config.enabledTransports = opts.enabledTransports;
	    if ('ignoreNullOrigin' in opts)
	        config.ignoreNullOrigin = opts.ignoreNullOrigin;
	    if ('timelineParams' in opts)
	        config.timelineParams = opts.timelineParams;
	    if ('nacl' in opts) {
	        config.nacl = opts.nacl;
	    }
	    return config;
	}
	function getHttpHost(opts) {
	    if (opts.httpHost) {
	        return opts.httpHost;
	    }
	    if (opts.cluster) {
	        return "sockjs-" + opts.cluster + ".pusher.com";
	    }
	    return defaults.httpHost;
	}
	function getWebsocketHost(opts) {
	    if (opts.wsHost) {
	        return opts.wsHost;
	    }
	    if (opts.cluster) {
	        return getWebsocketHostFromCluster(opts.cluster);
	    }
	    return getWebsocketHostFromCluster(defaults.cluster);
	}
	function getWebsocketHostFromCluster(cluster) {
	    return "ws-" + cluster + ".pusher.com";
	}
	function shouldUseTLS(opts) {
	    if (runtime.getProtocol() === 'https:') {
	        return true;
	    }
	    else if (opts.forceTLS === false) {
	        return false;
	    }
	    return true;
	}
	function getEnableStatsConfig(opts) {
	    if ('enableStats' in opts) {
	        return opts.enableStats;
	    }
	    if ('disableStats' in opts) {
	        return !opts.disableStats;
	    }
	    return false;
	}

	// CONCATENATED MODULE: ./src/core/pusher.ts












	var pusher_Pusher = (function () {
	    function Pusher(app_key, options) {
	        var _this = this;
	        checkAppKey(app_key);
	        options = options || {};
	        if (!options.cluster && !(options.wsHost || options.httpHost)) {
	            var suffix = url_store.buildLogSuffix('javascriptQuickStart');
	            logger.warn("You should always specify a cluster when connecting. " + suffix);
	        }
	        if ('disableStats' in options) {
	            logger.warn('The disableStats option is deprecated in favor of enableStats');
	        }
	        this.key = app_key;
	        this.config = getConfig(options);
	        this.channels = factory.createChannels();
	        this.global_emitter = new dispatcher();
	        this.sessionID = Math.floor(Math.random() * 1000000000);
	        this.timeline = new timeline_timeline(this.key, this.sessionID, {
	            cluster: this.config.cluster,
	            features: Pusher.getClientFeatures(),
	            params: this.config.timelineParams || {},
	            limit: 50,
	            level: timeline_level.INFO,
	            version: defaults.VERSION
	        });
	        if (this.config.enableStats) {
	            this.timelineSender = factory.createTimelineSender(this.timeline, {
	                host: this.config.statsHost,
	                path: '/timeline/v2/' + runtime.TimelineTransport.name
	            });
	        }
	        var getStrategy = function (options) {
	            return runtime.getDefaultStrategy(_this.config, options, strategy_builder_defineTransport);
	        };
	        this.connection = factory.createConnectionManager(this.key, {
	            getStrategy: getStrategy,
	            timeline: this.timeline,
	            activityTimeout: this.config.activityTimeout,
	            pongTimeout: this.config.pongTimeout,
	            unavailableTimeout: this.config.unavailableTimeout,
	            useTLS: Boolean(this.config.useTLS)
	        });
	        this.connection.bind('connected', function () {
	            _this.subscribeAll();
	            if (_this.timelineSender) {
	                _this.timelineSender.send(_this.connection.isUsingTLS());
	            }
	        });
	        this.connection.bind('message', function (event) {
	            var eventName = event.event;
	            var internal = eventName.indexOf('pusher_internal:') === 0;
	            if (event.channel) {
	                var channel = _this.channel(event.channel);
	                if (channel) {
	                    channel.handleEvent(event);
	                }
	            }
	            if (!internal) {
	                _this.global_emitter.emit(event.event, event.data);
	            }
	        });
	        this.connection.bind('connecting', function () {
	            _this.channels.disconnect();
	        });
	        this.connection.bind('disconnected', function () {
	            _this.channels.disconnect();
	        });
	        this.connection.bind('error', function (err) {
	            logger.warn(err);
	        });
	        Pusher.instances.push(this);
	        this.timeline.info({ instances: Pusher.instances.length });
	        if (Pusher.isReady) {
	            this.connect();
	        }
	    }
	    Pusher.ready = function () {
	        Pusher.isReady = true;
	        for (var i = 0, l = Pusher.instances.length; i < l; i++) {
	            Pusher.instances[i].connect();
	        }
	    };
	    Pusher.getClientFeatures = function () {
	        return keys(filterObject({ ws: runtime.Transports.ws }, function (t) {
	            return t.isSupported({});
	        }));
	    };
	    Pusher.prototype.channel = function (name) {
	        return this.channels.find(name);
	    };
	    Pusher.prototype.allChannels = function () {
	        return this.channels.all();
	    };
	    Pusher.prototype.connect = function () {
	        this.connection.connect();
	        if (this.timelineSender) {
	            if (!this.timelineSenderTimer) {
	                var usingTLS = this.connection.isUsingTLS();
	                var timelineSender = this.timelineSender;
	                this.timelineSenderTimer = new PeriodicTimer(60000, function () {
	                    timelineSender.send(usingTLS);
	                });
	            }
	        }
	    };
	    Pusher.prototype.disconnect = function () {
	        this.connection.disconnect();
	        if (this.timelineSenderTimer) {
	            this.timelineSenderTimer.ensureAborted();
	            this.timelineSenderTimer = null;
	        }
	    };
	    Pusher.prototype.bind = function (event_name, callback, context) {
	        this.global_emitter.bind(event_name, callback, context);
	        return this;
	    };
	    Pusher.prototype.unbind = function (event_name, callback, context) {
	        this.global_emitter.unbind(event_name, callback, context);
	        return this;
	    };
	    Pusher.prototype.bind_global = function (callback) {
	        this.global_emitter.bind_global(callback);
	        return this;
	    };
	    Pusher.prototype.unbind_global = function (callback) {
	        this.global_emitter.unbind_global(callback);
	        return this;
	    };
	    Pusher.prototype.unbind_all = function (callback) {
	        this.global_emitter.unbind_all();
	        return this;
	    };
	    Pusher.prototype.subscribeAll = function () {
	        var channelName;
	        for (channelName in this.channels.channels) {
	            if (this.channels.channels.hasOwnProperty(channelName)) {
	                this.subscribe(channelName);
	            }
	        }
	    };
	    Pusher.prototype.subscribe = function (channel_name) {
	        var channel = this.channels.add(channel_name, this);
	        if (channel.subscriptionPending && channel.subscriptionCancelled) {
	            channel.reinstateSubscription();
	        }
	        else if (!channel.subscriptionPending &&
	            this.connection.state === 'connected') {
	            channel.subscribe();
	        }
	        return channel;
	    };
	    Pusher.prototype.unsubscribe = function (channel_name) {
	        var channel = this.channels.find(channel_name);
	        if (channel && channel.subscriptionPending) {
	            channel.cancelSubscription();
	        }
	        else {
	            channel = this.channels.remove(channel_name);
	            if (channel && channel.subscribed) {
	                channel.unsubscribe();
	            }
	        }
	    };
	    Pusher.prototype.send_event = function (event_name, data, channel) {
	        return this.connection.send_event(event_name, data, channel);
	    };
	    Pusher.prototype.shouldUseTLS = function () {
	        return this.config.useTLS;
	    };
	    Pusher.instances = [];
	    Pusher.isReady = false;
	    Pusher.logToConsole = false;
	    Pusher.Runtime = runtime;
	    Pusher.ScriptReceivers = runtime.ScriptReceivers;
	    Pusher.DependenciesReceivers = runtime.DependenciesReceivers;
	    Pusher.auth_callbacks = runtime.auth_callbacks;
	    return Pusher;
	}());
	/* harmony default export */ var core_pusher = __webpack_exports__["default"] = (pusher_Pusher);
	function checkAppKey(key) {
	    if (key === null || key === undefined) {
	        throw 'You must pass your app key when you instantiate Pusher.';
	    }
	}
	runtime.setup(pusher_Pusher);


	/***/ })
	/******/ ]);
	});
	});

	unwrapExports(pusher);

	var bind = function bind(fn, thisArg) {
	  return function wrap() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    return fn.apply(thisArg, args);
	  };
	};

	// utils is a library of generic helper functions non-specific to axios

	var toString = Object.prototype.toString;

	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	function isArray(val) {
	  return toString.call(val) === '[object Array]';
	}

	/**
	 * Determine if a value is undefined
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	function isUndefined(val) {
	  return typeof val === 'undefined';
	}

	/**
	 * Determine if a value is a Buffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Buffer, otherwise false
	 */
	function isBuffer(val) {
	  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
	    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
	}

	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	function isArrayBuffer(val) {
	  return toString.call(val) === '[object ArrayBuffer]';
	}

	/**
	 * Determine if a value is a FormData
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	function isFormData(val) {
	  return (typeof FormData !== 'undefined') && (val instanceof FormData);
	}

	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  var result;
	  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
	  }
	  return result;
	}

	/**
	 * Determine if a value is a String
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	function isString(val) {
	  return typeof val === 'string';
	}

	/**
	 * Determine if a value is a Number
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	function isNumber(val) {
	  return typeof val === 'number';
	}

	/**
	 * Determine if a value is an Object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	function isObject(val) {
	  return val !== null && typeof val === 'object';
	}

	/**
	 * Determine if a value is a plain Object
	 *
	 * @param {Object} val The value to test
	 * @return {boolean} True if value is a plain Object, otherwise false
	 */
	function isPlainObject(val) {
	  if (toString.call(val) !== '[object Object]') {
	    return false;
	  }

	  var prototype = Object.getPrototypeOf(val);
	  return prototype === null || prototype === Object.prototype;
	}

	/**
	 * Determine if a value is a Date
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	function isDate(val) {
	  return toString.call(val) === '[object Date]';
	}

	/**
	 * Determine if a value is a File
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	function isFile(val) {
	  return toString.call(val) === '[object File]';
	}

	/**
	 * Determine if a value is a Blob
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	function isBlob(val) {
	  return toString.call(val) === '[object Blob]';
	}

	/**
	 * Determine if a value is a Function
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	function isFunction(val) {
	  return toString.call(val) === '[object Function]';
	}

	/**
	 * Determine if a value is a Stream
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	function isStream(val) {
	  return isObject(val) && isFunction(val.pipe);
	}

	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	function isURLSearchParams(val) {
	  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
	}

	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 * @returns {String} The String freed of excess whitespace
	 */
	function trim(str) {
	  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	}

	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  navigator.product -> 'ReactNative'
	 * nativescript
	 *  navigator.product -> 'NativeScript' or 'NS'
	 */
	function isStandardBrowserEnv() {
	  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
	                                           navigator.product === 'NativeScript' ||
	                                           navigator.product === 'NS')) {
	    return false;
	  }
	  return (
	    typeof window !== 'undefined' &&
	    typeof document !== 'undefined'
	  );
	}

	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 */
	function forEach(obj, fn) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }

	  // Force an array if not already something iterable
	  if (typeof obj !== 'object') {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }

	  if (isArray(obj)) {
	    // Iterate over array values
	    for (var i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    for (var key in obj) {
	      if (Object.prototype.hasOwnProperty.call(obj, key)) {
	        fn.call(null, obj[key], key, obj);
	      }
	    }
	  }
	}

	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function merge(/* obj1, obj2, obj3, ... */) {
	  var result = {};
	  function assignValue(val, key) {
	    if (isPlainObject(result[key]) && isPlainObject(val)) {
	      result[key] = merge(result[key], val);
	    } else if (isPlainObject(val)) {
	      result[key] = merge({}, val);
	    } else if (isArray(val)) {
	      result[key] = val.slice();
	    } else {
	      result[key] = val;
	    }
	  }

	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 * @return {Object} The resulting value of object a
	 */
	function extend(a, b, thisArg) {
	  forEach(b, function assignValue(val, key) {
	    if (thisArg && typeof val === 'function') {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  });
	  return a;
	}

	/**
	 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
	 *
	 * @param {string} content with BOM
	 * @return {string} content value without BOM
	 */
	function stripBOM(content) {
	  if (content.charCodeAt(0) === 0xFEFF) {
	    content = content.slice(1);
	  }
	  return content;
	}

	var utils$1 = {
	  isArray: isArray,
	  isArrayBuffer: isArrayBuffer,
	  isBuffer: isBuffer,
	  isFormData: isFormData,
	  isArrayBufferView: isArrayBufferView,
	  isString: isString,
	  isNumber: isNumber,
	  isObject: isObject,
	  isPlainObject: isPlainObject,
	  isUndefined: isUndefined,
	  isDate: isDate,
	  isFile: isFile,
	  isBlob: isBlob,
	  isFunction: isFunction,
	  isStream: isStream,
	  isURLSearchParams: isURLSearchParams,
	  isStandardBrowserEnv: isStandardBrowserEnv,
	  forEach: forEach,
	  merge: merge,
	  extend: extend,
	  trim: trim,
	  stripBOM: stripBOM
	};

	function encode(val) {
	  return encodeURIComponent(val).
	    replace(/%3A/gi, ':').
	    replace(/%24/g, '$').
	    replace(/%2C/gi, ',').
	    replace(/%20/g, '+').
	    replace(/%5B/gi, '[').
	    replace(/%5D/gi, ']');
	}

	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @returns {string} The formatted url
	 */
	var buildURL = function buildURL(url, params, paramsSerializer) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }

	  var serializedParams;
	  if (paramsSerializer) {
	    serializedParams = paramsSerializer(params);
	  } else if (utils$1.isURLSearchParams(params)) {
	    serializedParams = params.toString();
	  } else {
	    var parts = [];

	    utils$1.forEach(params, function serialize(val, key) {
	      if (val === null || typeof val === 'undefined') {
	        return;
	      }

	      if (utils$1.isArray(val)) {
	        key = key + '[]';
	      } else {
	        val = [val];
	      }

	      utils$1.forEach(val, function parseValue(v) {
	        if (utils$1.isDate(v)) {
	          v = v.toISOString();
	        } else if (utils$1.isObject(v)) {
	          v = JSON.stringify(v);
	        }
	        parts.push(encode(key) + '=' + encode(v));
	      });
	    });

	    serializedParams = parts.join('&');
	  }

	  if (serializedParams) {
	    var hashmarkIndex = url.indexOf('#');
	    if (hashmarkIndex !== -1) {
	      url = url.slice(0, hashmarkIndex);
	    }

	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }

	  return url;
	};

	function InterceptorManager() {
	  this.handlers = [];
	}

	/**
	 * Add a new interceptor to the stack
	 *
	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
	 * @param {Function} rejected The function to handle `reject` for a `Promise`
	 *
	 * @return {Number} An ID used to remove interceptor later
	 */
	InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
	  this.handlers.push({
	    fulfilled: fulfilled,
	    rejected: rejected,
	    synchronous: options ? options.synchronous : false,
	    runWhen: options ? options.runWhen : null
	  });
	  return this.handlers.length - 1;
	};

	/**
	 * Remove an interceptor from the stack
	 *
	 * @param {Number} id The ID that was returned by `use`
	 */
	InterceptorManager.prototype.eject = function eject(id) {
	  if (this.handlers[id]) {
	    this.handlers[id] = null;
	  }
	};

	/**
	 * Iterate over all the registered interceptors
	 *
	 * This method is particularly useful for skipping over any
	 * interceptors that may have become `null` calling `eject`.
	 *
	 * @param {Function} fn The function to call for each interceptor
	 */
	InterceptorManager.prototype.forEach = function forEach(fn) {
	  utils$1.forEach(this.handlers, function forEachHandler(h) {
	    if (h !== null) {
	      fn(h);
	    }
	  });
	};

	var InterceptorManager_1 = InterceptorManager;

	var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
	  utils$1.forEach(headers, function processHeader(value, name) {
	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
	      headers[normalizedName] = value;
	      delete headers[name];
	    }
	  });
	};

	/**
	 * Update an Error with the specified config, error code, and response.
	 *
	 * @param {Error} error The error to update.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 * @returns {Error} The error.
	 */
	var enhanceError = function enhanceError(error, config, code, request, response) {
	  error.config = config;
	  if (code) {
	    error.code = code;
	  }

	  error.request = request;
	  error.response = response;
	  error.isAxiosError = true;

	  error.toJSON = function toJSON() {
	    return {
	      // Standard
	      message: this.message,
	      name: this.name,
	      // Microsoft
	      description: this.description,
	      number: this.number,
	      // Mozilla
	      fileName: this.fileName,
	      lineNumber: this.lineNumber,
	      columnNumber: this.columnNumber,
	      stack: this.stack,
	      // Axios
	      config: this.config,
	      code: this.code
	    };
	  };
	  return error;
	};

	/**
	 * Create an Error with the specified message, config, error code, request and response.
	 *
	 * @param {string} message The error message.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 * @returns {Error} The created error.
	 */
	var createError = function createError(message, config, code, request, response) {
	  var error = new Error(message);
	  return enhanceError(error, config, code, request, response);
	};

	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 */
	var settle = function settle(resolve, reject, response) {
	  var validateStatus = response.config.validateStatus;
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(createError(
	      'Request failed with status code ' + response.status,
	      response.config,
	      null,
	      response.request,
	      response
	    ));
	  }
	};

	var cookies = (
	  utils$1.isStandardBrowserEnv() ?

	  // Standard browser envs support document.cookie
	    (function standardBrowserEnv() {
	      return {
	        write: function write(name, value, expires, path, domain, secure) {
	          var cookie = [];
	          cookie.push(name + '=' + encodeURIComponent(value));

	          if (utils$1.isNumber(expires)) {
	            cookie.push('expires=' + new Date(expires).toGMTString());
	          }

	          if (utils$1.isString(path)) {
	            cookie.push('path=' + path);
	          }

	          if (utils$1.isString(domain)) {
	            cookie.push('domain=' + domain);
	          }

	          if (secure === true) {
	            cookie.push('secure');
	          }

	          document.cookie = cookie.join('; ');
	        },

	        read: function read(name) {
	          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	          return (match ? decodeURIComponent(match[3]) : null);
	        },

	        remove: function remove(name) {
	          this.write(name, '', Date.now() - 86400000);
	        }
	      };
	    })() :

	  // Non standard browser env (web workers, react-native) lack needed support.
	    (function nonStandardBrowserEnv() {
	      return {
	        write: function write() {},
	        read: function read() { return null; },
	        remove: function remove() {}
	      };
	    })()
	);

	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	var isAbsoluteURL = function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
	};

	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 * @returns {string} The combined URL
	 */
	var combineURLs = function combineURLs(baseURL, relativeURL) {
	  return relativeURL
	    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
	    : baseURL;
	};

	/**
	 * Creates a new URL by combining the baseURL with the requestedURL,
	 * only when the requestedURL is not already an absolute URL.
	 * If the requestURL is absolute, this function returns the requestedURL untouched.
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} requestedURL Absolute or relative URL to combine
	 * @returns {string} The combined full path
	 */
	var buildFullPath = function buildFullPath(baseURL, requestedURL) {
	  if (baseURL && !isAbsoluteURL(requestedURL)) {
	    return combineURLs(baseURL, requestedURL);
	  }
	  return requestedURL;
	};

	// Headers whose duplicates are ignored by node
	// c.f. https://nodejs.org/api/http.html#http_message_headers
	var ignoreDuplicateOf = [
	  'age', 'authorization', 'content-length', 'content-type', 'etag',
	  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
	  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
	  'referer', 'retry-after', 'user-agent'
	];

	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} headers Headers needing to be parsed
	 * @returns {Object} Headers parsed into an object
	 */
	var parseHeaders = function parseHeaders(headers) {
	  var parsed = {};
	  var key;
	  var val;
	  var i;

	  if (!headers) { return parsed; }

	  utils$1.forEach(headers.split('\n'), function parser(line) {
	    i = line.indexOf(':');
	    key = utils$1.trim(line.substr(0, i)).toLowerCase();
	    val = utils$1.trim(line.substr(i + 1));

	    if (key) {
	      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
	        return;
	      }
	      if (key === 'set-cookie') {
	        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
	      } else {
	        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	      }
	    }
	  });

	  return parsed;
	};

	var isURLSameOrigin = (
	  utils$1.isStandardBrowserEnv() ?

	  // Standard browser envs have full support of the APIs needed to test
	  // whether the request URL is of the same origin as current location.
	    (function standardBrowserEnv() {
	      var msie = /(msie|trident)/i.test(navigator.userAgent);
	      var urlParsingNode = document.createElement('a');
	      var originURL;

	      /**
	    * Parse a URL to discover it's components
	    *
	    * @param {String} url The URL to be parsed
	    * @returns {Object}
	    */
	      function resolveURL(url) {
	        var href = url;

	        if (msie) {
	        // IE needs attribute set twice to normalize properties
	          urlParsingNode.setAttribute('href', href);
	          href = urlParsingNode.href;
	        }

	        urlParsingNode.setAttribute('href', href);

	        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	        return {
	          href: urlParsingNode.href,
	          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	          host: urlParsingNode.host,
	          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	          hostname: urlParsingNode.hostname,
	          port: urlParsingNode.port,
	          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
	            urlParsingNode.pathname :
	            '/' + urlParsingNode.pathname
	        };
	      }

	      originURL = resolveURL(window.location.href);

	      /**
	    * Determine if a URL shares the same origin as the current location
	    *
	    * @param {String} requestURL The URL to test
	    * @returns {boolean} True if URL shares the same origin, otherwise false
	    */
	      return function isURLSameOrigin(requestURL) {
	        var parsed = (utils$1.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
	        return (parsed.protocol === originURL.protocol &&
	            parsed.host === originURL.host);
	      };
	    })() :

	  // Non standard browser envs (web workers, react-native) lack needed support.
	    (function nonStandardBrowserEnv() {
	      return function isURLSameOrigin() {
	        return true;
	      };
	    })()
	);

	var xhr = function xhrAdapter(config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    var requestData = config.data;
	    var requestHeaders = config.headers;
	    var responseType = config.responseType;

	    if (utils$1.isFormData(requestData)) {
	      delete requestHeaders['Content-Type']; // Let the browser set it
	    }

	    var request = new XMLHttpRequest();

	    // HTTP basic authentication
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	    }

	    var fullPath = buildFullPath(config.baseURL, config.url);
	    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

	    // Set the request timeout in MS
	    request.timeout = config.timeout;

	    function onloadend() {
	      if (!request) {
	        return;
	      }
	      // Prepare the response
	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
	      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
	        request.responseText : request.response;
	      var response = {
	        data: responseData,
	        status: request.status,
	        statusText: request.statusText,
	        headers: responseHeaders,
	        config: config,
	        request: request
	      };

	      settle(resolve, reject, response);

	      // Clean up request
	      request = null;
	    }

	    if ('onloadend' in request) {
	      // Use onloadend if available
	      request.onloadend = onloadend;
	    } else {
	      // Listen for ready state to emulate onloadend
	      request.onreadystatechange = function handleLoad() {
	        if (!request || request.readyState !== 4) {
	          return;
	        }

	        // The request errored out and we didn't get a response, this will be
	        // handled by onerror instead
	        // With one exception: request that using file: protocol, most browsers
	        // will return status as 0 even though it's a successful request
	        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	          return;
	        }
	        // readystate handler is calling before onerror or ontimeout handlers,
	        // so we should call onloadend on the next 'tick'
	        setTimeout(onloadend);
	      };
	    }

	    // Handle browser request cancellation (as opposed to a manual cancellation)
	    request.onabort = function handleAbort() {
	      if (!request) {
	        return;
	      }

	      reject(createError('Request aborted', config, 'ECONNABORTED', request));

	      // Clean up request
	      request = null;
	    };

	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(createError('Network Error', config, null, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
	      if (config.timeoutErrorMessage) {
	        timeoutErrorMessage = config.timeoutErrorMessage;
	      }
	      reject(createError(
	        timeoutErrorMessage,
	        config,
	        config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
	        request));

	      // Clean up request
	      request = null;
	    };

	    // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.
	    if (utils$1.isStandardBrowserEnv()) {
	      // Add xsrf header
	      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
	        cookies.read(config.xsrfCookieName) :
	        undefined;

	      if (xsrfValue) {
	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
	      }
	    }

	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils$1.forEach(requestHeaders, function setRequestHeader(val, key) {
	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	          // Remove Content-Type if data is undefined
	          delete requestHeaders[key];
	        } else {
	          // Otherwise add header to the request
	          request.setRequestHeader(key, val);
	        }
	      });
	    }

	    // Add withCredentials to request if needed
	    if (!utils$1.isUndefined(config.withCredentials)) {
	      request.withCredentials = !!config.withCredentials;
	    }

	    // Add responseType to request if needed
	    if (responseType && responseType !== 'json') {
	      request.responseType = config.responseType;
	    }

	    // Handle progress if needed
	    if (typeof config.onDownloadProgress === 'function') {
	      request.addEventListener('progress', config.onDownloadProgress);
	    }

	    // Not all browsers support upload events
	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	      request.upload.addEventListener('progress', config.onUploadProgress);
	    }

	    if (config.cancelToken) {
	      // Handle cancellation
	      config.cancelToken.promise.then(function onCanceled(cancel) {
	        if (!request) {
	          return;
	        }

	        request.abort();
	        reject(cancel);
	        // Clean up request
	        request = null;
	      });
	    }

	    if (!requestData) {
	      requestData = null;
	    }

	    // Send the request
	    request.send(requestData);
	  });
	};

	var DEFAULT_CONTENT_TYPE = {
	  'Content-Type': 'application/x-www-form-urlencoded'
	};

	function setContentTypeIfUnset(headers, value) {
	  if (!utils$1.isUndefined(headers) && utils$1.isUndefined(headers['Content-Type'])) {
	    headers['Content-Type'] = value;
	  }
	}

	function getDefaultAdapter() {
	  var adapter;
	  if (typeof XMLHttpRequest !== 'undefined') {
	    // For browsers use XHR adapter
	    adapter = xhr;
	  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
	    // For node use HTTP adapter
	    adapter = xhr;
	  }
	  return adapter;
	}

	function stringifySafely(rawValue, parser, encoder) {
	  if (utils$1.isString(rawValue)) {
	    try {
	      (parser || JSON.parse)(rawValue);
	      return utils$1.trim(rawValue);
	    } catch (e) {
	      if (e.name !== 'SyntaxError') {
	        throw e;
	      }
	    }
	  }

	  return (encoder || JSON.stringify)(rawValue);
	}

	var defaults = {

	  transitional: {
	    silentJSONParsing: true,
	    forcedJSONParsing: true,
	    clarifyTimeoutError: false
	  },

	  adapter: getDefaultAdapter(),

	  transformRequest: [function transformRequest(data, headers) {
	    normalizeHeaderName(headers, 'Accept');
	    normalizeHeaderName(headers, 'Content-Type');

	    if (utils$1.isFormData(data) ||
	      utils$1.isArrayBuffer(data) ||
	      utils$1.isBuffer(data) ||
	      utils$1.isStream(data) ||
	      utils$1.isFile(data) ||
	      utils$1.isBlob(data)
	    ) {
	      return data;
	    }
	    if (utils$1.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils$1.isURLSearchParams(data)) {
	      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
	      return data.toString();
	    }
	    if (utils$1.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
	      setContentTypeIfUnset(headers, 'application/json');
	      return stringifySafely(data);
	    }
	    return data;
	  }],

	  transformResponse: [function transformResponse(data) {
	    var transitional = this.transitional;
	    var silentJSONParsing = transitional && transitional.silentJSONParsing;
	    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
	    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

	    if (strictJSONParsing || (forcedJSONParsing && utils$1.isString(data) && data.length)) {
	      try {
	        return JSON.parse(data);
	      } catch (e) {
	        if (strictJSONParsing) {
	          if (e.name === 'SyntaxError') {
	            throw enhanceError(e, this, 'E_JSON_PARSE');
	          }
	          throw e;
	        }
	      }
	    }

	    return data;
	  }],

	  /**
	   * A timeout in milliseconds to abort a request. If set to 0 (default) a
	   * timeout is not created.
	   */
	  timeout: 0,

	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',

	  maxContentLength: -1,
	  maxBodyLength: -1,

	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  }
	};

	defaults.headers = {
	  common: {
	    'Accept': 'application/json, text/plain, */*'
	  }
	};

	utils$1.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
	  defaults.headers[method] = {};
	});

	utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  defaults.headers[method] = utils$1.merge(DEFAULT_CONTENT_TYPE);
	});

	var defaults_1 = defaults;

	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Object|String} data The data to be transformed
	 * @param {Array} headers The headers for the request or response
	 * @param {Array|Function} fns A single function or Array of functions
	 * @returns {*} The resulting transformed data
	 */
	var transformData$1 = function transformData(data, headers, fns) {
	  var context = this || defaults_1;
	  /*eslint no-param-reassign:0*/
	  utils$1.forEach(fns, function transform(fn) {
	    data = fn.call(context, data, headers);
	  });

	  return data;
	};

	var isCancel = function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	};

	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }
	}

	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 * @returns {Promise} The Promise to be fulfilled
	 */
	var dispatchRequest = function dispatchRequest(config) {
	  throwIfCancellationRequested(config);

	  // Ensure headers exist
	  config.headers = config.headers || {};

	  // Transform request data
	  config.data = transformData$1.call(
	    config,
	    config.data,
	    config.headers,
	    config.transformRequest
	  );

	  // Flatten headers
	  config.headers = utils$1.merge(
	    config.headers.common || {},
	    config.headers[config.method] || {},
	    config.headers
	  );

	  utils$1.forEach(
	    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
	    function cleanHeaderConfig(method) {
	      delete config.headers[method];
	    }
	  );

	  var adapter = config.adapter || defaults_1.adapter;

	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);

	    // Transform response data
	    response.data = transformData$1.call(
	      config,
	      response.data,
	      response.headers,
	      config.transformResponse
	    );

	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel(reason)) {
	      throwIfCancellationRequested(config);

	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData$1.call(
	          config,
	          reason.response.data,
	          reason.response.headers,
	          config.transformResponse
	        );
	      }
	    }

	    return Promise.reject(reason);
	  });
	};

	/**
	 * Config-specific merge-function which creates a new config-object
	 * by merging two configuration objects together.
	 *
	 * @param {Object} config1
	 * @param {Object} config2
	 * @returns {Object} New object resulting from merging config2 to config1
	 */
	var mergeConfig = function mergeConfig(config1, config2) {
	  // eslint-disable-next-line no-param-reassign
	  config2 = config2 || {};
	  var config = {};

	  var valueFromConfig2Keys = ['url', 'method', 'data'];
	  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
	  var defaultToConfig2Keys = [
	    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
	    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
	    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
	    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
	    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
	  ];
	  var directMergeKeys = ['validateStatus'];

	  function getMergedValue(target, source) {
	    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
	      return utils$1.merge(target, source);
	    } else if (utils$1.isPlainObject(source)) {
	      return utils$1.merge({}, source);
	    } else if (utils$1.isArray(source)) {
	      return source.slice();
	    }
	    return source;
	  }

	  function mergeDeepProperties(prop) {
	    if (!utils$1.isUndefined(config2[prop])) {
	      config[prop] = getMergedValue(config1[prop], config2[prop]);
	    } else if (!utils$1.isUndefined(config1[prop])) {
	      config[prop] = getMergedValue(undefined, config1[prop]);
	    }
	  }

	  utils$1.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
	    if (!utils$1.isUndefined(config2[prop])) {
	      config[prop] = getMergedValue(undefined, config2[prop]);
	    }
	  });

	  utils$1.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

	  utils$1.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
	    if (!utils$1.isUndefined(config2[prop])) {
	      config[prop] = getMergedValue(undefined, config2[prop]);
	    } else if (!utils$1.isUndefined(config1[prop])) {
	      config[prop] = getMergedValue(undefined, config1[prop]);
	    }
	  });

	  utils$1.forEach(directMergeKeys, function merge(prop) {
	    if (prop in config2) {
	      config[prop] = getMergedValue(config1[prop], config2[prop]);
	    } else if (prop in config1) {
	      config[prop] = getMergedValue(undefined, config1[prop]);
	    }
	  });

	  var axiosKeys = valueFromConfig2Keys
	    .concat(mergeDeepPropertiesKeys)
	    .concat(defaultToConfig2Keys)
	    .concat(directMergeKeys);

	  var otherKeys = Object
	    .keys(config1)
	    .concat(Object.keys(config2))
	    .filter(function filterAxiosKeys(key) {
	      return axiosKeys.indexOf(key) === -1;
	    });

	  utils$1.forEach(otherKeys, mergeDeepProperties);

	  return config;
	};

	var _args = [
		[
			"axios@0.21.4",
			"/home/runner/work/core/core/sdk"
		]
	];
	var _from = "axios@0.21.4";
	var _id = "axios@0.21.4";
	var _inBundle = false;
	var _integrity = "sha512-ut5vewkiu8jjGBdqpM44XxjuCjq9LAKeHVmoVfHVzy8eHgxxq8SbAVQNovDA8mVi05kP0Ea/n/UzcSHcTJQfNg==";
	var _location = "/axios";
	var _phantomChildren = {
	};
	var _requested = {
		type: "version",
		registry: true,
		raw: "axios@0.21.4",
		name: "axios",
		escapedName: "axios",
		rawSpec: "0.21.4",
		saveSpec: null,
		fetchSpec: "0.21.4"
	};
	var _requiredBy = [
		"/"
	];
	var _resolved = "https://registry.npmjs.org/axios/-/axios-0.21.4.tgz";
	var _spec = "0.21.4";
	var _where = "/home/runner/work/core/core/sdk";
	var author = {
		name: "Matt Zabriskie"
	};
	var browser = {
		"./lib/adapters/http.js": "./lib/adapters/xhr.js"
	};
	var bugs = {
		url: "https://github.com/axios/axios/issues"
	};
	var bundlesize = [
		{
			path: "./dist/axios.min.js",
			threshold: "5kB"
		}
	];
	var dependencies = {
		"follow-redirects": "^1.14.0"
	};
	var description = "Promise based HTTP client for the browser and node.js";
	var devDependencies = {
		coveralls: "^3.0.0",
		"es6-promise": "^4.2.4",
		grunt: "^1.3.0",
		"grunt-banner": "^0.6.0",
		"grunt-cli": "^1.2.0",
		"grunt-contrib-clean": "^1.1.0",
		"grunt-contrib-watch": "^1.0.0",
		"grunt-eslint": "^23.0.0",
		"grunt-karma": "^4.0.0",
		"grunt-mocha-test": "^0.13.3",
		"grunt-ts": "^6.0.0-beta.19",
		"grunt-webpack": "^4.0.2",
		"istanbul-instrumenter-loader": "^1.0.0",
		"jasmine-core": "^2.4.1",
		karma: "^6.3.2",
		"karma-chrome-launcher": "^3.1.0",
		"karma-firefox-launcher": "^2.1.0",
		"karma-jasmine": "^1.1.1",
		"karma-jasmine-ajax": "^0.1.13",
		"karma-safari-launcher": "^1.0.0",
		"karma-sauce-launcher": "^4.3.6",
		"karma-sinon": "^1.0.5",
		"karma-sourcemap-loader": "^0.3.8",
		"karma-webpack": "^4.0.2",
		"load-grunt-tasks": "^3.5.2",
		minimist: "^1.2.0",
		mocha: "^8.2.1",
		sinon: "^4.5.0",
		"terser-webpack-plugin": "^4.2.3",
		typescript: "^4.0.5",
		"url-search-params": "^0.10.0",
		webpack: "^4.44.2",
		"webpack-dev-server": "^3.11.0"
	};
	var homepage = "https://axios-http.com";
	var jsdelivr = "dist/axios.min.js";
	var keywords = [
		"xhr",
		"http",
		"ajax",
		"promise",
		"node"
	];
	var license = "MIT";
	var main = "index.js";
	var name = "axios";
	var repository = {
		type: "git",
		url: "git+https://github.com/axios/axios.git"
	};
	var scripts = {
		build: "NODE_ENV=production grunt build",
		coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
		examples: "node ./examples/server.js",
		fix: "eslint --fix lib/**/*.js",
		postversion: "git push && git push --tags",
		preversion: "npm test",
		start: "node ./sandbox/server.js",
		test: "grunt test",
		version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json"
	};
	var typings = "./index.d.ts";
	var unpkg = "dist/axios.min.js";
	var version = "0.21.4";
	var _package = {
		_args: _args,
		_from: _from,
		_id: _id,
		_inBundle: _inBundle,
		_integrity: _integrity,
		_location: _location,
		_phantomChildren: _phantomChildren,
		_requested: _requested,
		_requiredBy: _requiredBy,
		_resolved: _resolved,
		_spec: _spec,
		_where: _where,
		author: author,
		browser: browser,
		bugs: bugs,
		bundlesize: bundlesize,
		dependencies: dependencies,
		description: description,
		devDependencies: devDependencies,
		homepage: homepage,
		jsdelivr: jsdelivr,
		keywords: keywords,
		license: license,
		main: main,
		name: name,
		repository: repository,
		scripts: scripts,
		typings: typings,
		unpkg: unpkg,
		version: version
	};

	var _package$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		_args: _args,
		_from: _from,
		_id: _id,
		_inBundle: _inBundle,
		_integrity: _integrity,
		_location: _location,
		_phantomChildren: _phantomChildren,
		_requested: _requested,
		_requiredBy: _requiredBy,
		_resolved: _resolved,
		_spec: _spec,
		_where: _where,
		author: author,
		browser: browser,
		bugs: bugs,
		bundlesize: bundlesize,
		dependencies: dependencies,
		description: description,
		devDependencies: devDependencies,
		homepage: homepage,
		jsdelivr: jsdelivr,
		keywords: keywords,
		license: license,
		main: main,
		name: name,
		repository: repository,
		scripts: scripts,
		typings: typings,
		unpkg: unpkg,
		version: version,
		'default': _package
	});

	var pkg = getCjsExportFromNamespace(_package$1);

	var validators$1 = {};

	// eslint-disable-next-line func-names
	['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
	  validators$1[type] = function validator(thing) {
	    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
	  };
	});

	var deprecatedWarnings = {};
	var currentVerArr = pkg.version.split('.');

	/**
	 * Compare package versions
	 * @param {string} version
	 * @param {string?} thanVersion
	 * @returns {boolean}
	 */
	function isOlderVersion(version, thanVersion) {
	  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
	  var destVer = version.split('.');
	  for (var i = 0; i < 3; i++) {
	    if (pkgVersionArr[i] > destVer[i]) {
	      return true;
	    } else if (pkgVersionArr[i] < destVer[i]) {
	      return false;
	    }
	  }
	  return false;
	}

	/**
	 * Transitional option validator
	 * @param {function|boolean?} validator
	 * @param {string?} version
	 * @param {string} message
	 * @returns {function}
	 */
	validators$1.transitional = function transitional(validator, version, message) {
	  var isDeprecated = version && isOlderVersion(version);

	  function formatMessage(opt, desc) {
	    return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
	  }

	  // eslint-disable-next-line func-names
	  return function(value, opt, opts) {
	    if (validator === false) {
	      throw new Error(formatMessage(opt, ' has been removed in ' + version));
	    }

	    if (isDeprecated && !deprecatedWarnings[opt]) {
	      deprecatedWarnings[opt] = true;
	      // eslint-disable-next-line no-console
	      console.warn(
	        formatMessage(
	          opt,
	          ' has been deprecated since v' + version + ' and will be removed in the near future'
	        )
	      );
	    }

	    return validator ? validator(value, opt, opts) : true;
	  };
	};

	/**
	 * Assert object's properties type
	 * @param {object} options
	 * @param {object} schema
	 * @param {boolean?} allowUnknown
	 */

	function assertOptions(options, schema, allowUnknown) {
	  if (typeof options !== 'object') {
	    throw new TypeError('options must be an object');
	  }
	  var keys = Object.keys(options);
	  var i = keys.length;
	  while (i-- > 0) {
	    var opt = keys[i];
	    var validator = schema[opt];
	    if (validator) {
	      var value = options[opt];
	      var result = value === undefined || validator(value, opt, options);
	      if (result !== true) {
	        throw new TypeError('option ' + opt + ' must be ' + result);
	      }
	      continue;
	    }
	    if (allowUnknown !== true) {
	      throw Error('Unknown option ' + opt);
	    }
	  }
	}

	var validator = {
	  isOlderVersion: isOlderVersion,
	  assertOptions: assertOptions,
	  validators: validators$1
	};

	var validators = validator.validators;
	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} instanceConfig The default config for the instance
	 */
	function Axios(instanceConfig) {
	  this.defaults = instanceConfig;
	  this.interceptors = {
	    request: new InterceptorManager_1(),
	    response: new InterceptorManager_1()
	  };
	}

	/**
	 * Dispatch a request
	 *
	 * @param {Object} config The config specific for this request (merged with this.defaults)
	 */
	Axios.prototype.request = function request(config) {
	  /*eslint no-param-reassign:0*/
	  // Allow for axios('example/url'[, config]) a la fetch API
	  if (typeof config === 'string') {
	    config = arguments[1] || {};
	    config.url = arguments[0];
	  } else {
	    config = config || {};
	  }

	  config = mergeConfig(this.defaults, config);

	  // Set config.method
	  if (config.method) {
	    config.method = config.method.toLowerCase();
	  } else if (this.defaults.method) {
	    config.method = this.defaults.method.toLowerCase();
	  } else {
	    config.method = 'get';
	  }

	  var transitional = config.transitional;

	  if (transitional !== undefined) {
	    validator.assertOptions(transitional, {
	      silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
	      forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
	      clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')
	    }, false);
	  }

	  // filter out skipped interceptors
	  var requestInterceptorChain = [];
	  var synchronousRequestInterceptors = true;
	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
	      return;
	    }

	    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

	    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
	  });

	  var responseInterceptorChain = [];
	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
	  });

	  var promise;

	  if (!synchronousRequestInterceptors) {
	    var chain = [dispatchRequest, undefined];

	    Array.prototype.unshift.apply(chain, requestInterceptorChain);
	    chain = chain.concat(responseInterceptorChain);

	    promise = Promise.resolve(config);
	    while (chain.length) {
	      promise = promise.then(chain.shift(), chain.shift());
	    }

	    return promise;
	  }


	  var newConfig = config;
	  while (requestInterceptorChain.length) {
	    var onFulfilled = requestInterceptorChain.shift();
	    var onRejected = requestInterceptorChain.shift();
	    try {
	      newConfig = onFulfilled(newConfig);
	    } catch (error) {
	      onRejected(error);
	      break;
	    }
	  }

	  try {
	    promise = dispatchRequest(newConfig);
	  } catch (error) {
	    return Promise.reject(error);
	  }

	  while (responseInterceptorChain.length) {
	    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
	  }

	  return promise;
	};

	Axios.prototype.getUri = function getUri(config) {
	  config = mergeConfig(this.defaults, config);
	  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
	};

	// Provide aliases for supported request methods
	utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, config) {
	    return this.request(mergeConfig(config || {}, {
	      method: method,
	      url: url,
	      data: (config || {}).data
	    }));
	  };
	});

	utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, data, config) {
	    return this.request(mergeConfig(config || {}, {
	      method: method,
	      url: url,
	      data: data
	    }));
	  };
	});

	var Axios_1 = Axios;

	/**
	 * A `Cancel` is an object that is thrown when an operation is canceled.
	 *
	 * @class
	 * @param {string=} message The message.
	 */
	function Cancel(message) {
	  this.message = message;
	}

	Cancel.prototype.toString = function toString() {
	  return 'Cancel' + (this.message ? ': ' + this.message : '');
	};

	Cancel.prototype.__CANCEL__ = true;

	var Cancel_1 = Cancel;

	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @class
	 * @param {Function} executor The executor function.
	 */
	function CancelToken(executor) {
	  if (typeof executor !== 'function') {
	    throw new TypeError('executor must be a function.');
	  }

	  var resolvePromise;
	  this.promise = new Promise(function promiseExecutor(resolve) {
	    resolvePromise = resolve;
	  });

	  var token = this;
	  executor(function cancel(message) {
	    if (token.reason) {
	      // Cancellation has already been requested
	      return;
	    }

	    token.reason = new Cancel_1(message);
	    resolvePromise(token.reason);
	  });
	}

	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	CancelToken.prototype.throwIfRequested = function throwIfRequested() {
	  if (this.reason) {
	    throw this.reason;
	  }
	};

	/**
	 * Returns an object that contains a new `CancelToken` and a function that, when called,
	 * cancels the `CancelToken`.
	 */
	CancelToken.source = function source() {
	  var cancel;
	  var token = new CancelToken(function executor(c) {
	    cancel = c;
	  });
	  return {
	    token: token,
	    cancel: cancel
	  };
	};

	var CancelToken_1 = CancelToken;

	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 * @returns {Function}
	 */
	var spread = function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	};

	/**
	 * Determines whether the payload is an error thrown by Axios
	 *
	 * @param {*} payload The value to test
	 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
	 */
	var isAxiosError = function isAxiosError(payload) {
	  return (typeof payload === 'object') && (payload.isAxiosError === true);
	};

	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 * @return {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  var context = new Axios_1(defaultConfig);
	  var instance = bind(Axios_1.prototype.request, context);

	  // Copy axios.prototype to instance
	  utils$1.extend(instance, Axios_1.prototype, context);

	  // Copy context to instance
	  utils$1.extend(instance, context);

	  return instance;
	}

	// Create the default instance to be exported
	var axios$1 = createInstance(defaults_1);

	// Expose Axios class to allow class inheritance
	axios$1.Axios = Axios_1;

	// Factory for creating new instances
	axios$1.create = function create(instanceConfig) {
	  return createInstance(mergeConfig(axios$1.defaults, instanceConfig));
	};

	// Expose Cancel & CancelToken
	axios$1.Cancel = Cancel_1;
	axios$1.CancelToken = CancelToken_1;
	axios$1.isCancel = isCancel;

	// Expose all/spread
	axios$1.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios$1.spread = spread;

	// Expose isAxiosError
	axios$1.isAxiosError = isAxiosError;

	var axios_1 = axios$1;

	// Allow use of default import syntax in TypeScript
	var default_1 = axios$1;
	axios_1.default = default_1;

	var axios = axios_1;

	var urlJoin = createCommonjsModule(function (module) {
	(function (name, context, definition) {
	  if (module.exports) module.exports = definition();
	  else context[name] = definition();
	})('urljoin', commonjsGlobal, function () {

	  function normalize (strArray) {
	    var resultArray = [];
	    if (strArray.length === 0) { return ''; }

	    if (typeof strArray[0] !== 'string') {
	      throw new TypeError('Url must be a string. Received ' + strArray[0]);
	    }

	    // If the first part is a plain protocol, we combine it with the next part.
	    if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
	      var first = strArray.shift();
	      strArray[0] = first + strArray[0];
	    }

	    // There must be two or three slashes in the file protocol, two slashes in anything else.
	    if (strArray[0].match(/^file:\/\/\//)) {
	      strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, '$1:///');
	    } else {
	      strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, '$1://');
	    }

	    for (var i = 0; i < strArray.length; i++) {
	      var component = strArray[i];

	      if (typeof component !== 'string') {
	        throw new TypeError('Url must be a string. Received ' + component);
	      }

	      if (component === '') { continue; }

	      if (i > 0) {
	        // Removing the starting slashes for each component but the first.
	        component = component.replace(/^[\/]+/, '');
	      }
	      if (i < strArray.length - 1) {
	        // Removing the ending slashes for each component but the last.
	        component = component.replace(/[\/]+$/, '');
	      } else {
	        // For the last component we will combine multiple slashes to a single one.
	        component = component.replace(/[\/]+$/, '/');
	      }

	      resultArray.push(component);

	    }

	    var str = resultArray.join('/');
	    // Each input component is now separated by a single slash except the possible first plain protocol part.

	    // remove trailing slash before parameters or hash
	    str = str.replace(/\/(\?|&|#[^!])/g, '$1');

	    // replace ? in parameters with &
	    var parts = str.split('?');
	    str = parts.shift() + (parts.length > 0 ? '?': '') + parts.join('&');

	    return str;
	  }

	  return function () {
	    var input;

	    if (typeof arguments[0] === 'object') {
	      input = arguments[0];
	    } else {
	      input = [].slice.call(arguments);
	    }

	    return normalize(input);
	  };

	});
	});

	var strictUriEncode = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);

	var token = '%[a-f0-9]{2}';
	var singleMatcher = new RegExp(token, 'gi');
	var multiMatcher = new RegExp('(' + token + ')+', 'gi');

	function decodeComponents(components, split) {
		try {
			// Try to decode the entire string first
			return decodeURIComponent(components.join(''));
		} catch (err) {
			// Do nothing
		}

		if (components.length === 1) {
			return components;
		}

		split = split || 1;

		// Split the array in 2 parts
		var left = components.slice(0, split);
		var right = components.slice(split);

		return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
	}

	function decode(input) {
		try {
			return decodeURIComponent(input);
		} catch (err) {
			var tokens = input.match(singleMatcher);

			for (var i = 1; i < tokens.length; i++) {
				input = decodeComponents(tokens, i).join('');

				tokens = input.match(singleMatcher);
			}

			return input;
		}
	}

	function customDecodeURIComponent(input) {
		// Keep track of all the replacements and prefill the map with the `BOM`
		var replaceMap = {
			'%FE%FF': '\uFFFD\uFFFD',
			'%FF%FE': '\uFFFD\uFFFD'
		};

		var match = multiMatcher.exec(input);
		while (match) {
			try {
				// Decode as big chunks as possible
				replaceMap[match[0]] = decodeURIComponent(match[0]);
			} catch (err) {
				var result = decode(match[0]);

				if (result !== match[0]) {
					replaceMap[match[0]] = result;
				}
			}

			match = multiMatcher.exec(input);
		}

		// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
		replaceMap['%C2'] = '\uFFFD';

		var entries = Object.keys(replaceMap);

		for (var i = 0; i < entries.length; i++) {
			// Replace all decoded components
			var key = entries[i];
			input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
		}

		return input;
	}

	var decodeUriComponent = function (encodedURI) {
		if (typeof encodedURI !== 'string') {
			throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
		}

		try {
			encodedURI = encodedURI.replace(/\+/g, ' ');

			// Try the built in decoder first
			return decodeURIComponent(encodedURI);
		} catch (err) {
			// Fallback to a more advanced decoder
			return customDecodeURIComponent(encodedURI);
		}
	};

	var splitOnFirst = (string, separator) => {
		if (!(typeof string === 'string' && typeof separator === 'string')) {
			throw new TypeError('Expected the arguments to be of type `string`');
		}

		if (separator === '') {
			return [string];
		}

		const separatorIndex = string.indexOf(separator);

		if (separatorIndex === -1) {
			return [string];
		}

		return [
			string.slice(0, separatorIndex),
			string.slice(separatorIndex + separator.length)
		];
	};

	var filterObj = function (obj, predicate) {
		var ret = {};
		var keys = Object.keys(obj);
		var isArr = Array.isArray(predicate);

		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			var val = obj[key];

			if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
				ret[key] = val;
			}
		}

		return ret;
	};

	var queryString = createCommonjsModule(function (module, exports) {





	const isNullOrUndefined = value => value === null || value === undefined;

	const encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');

	function encoderForArrayFormat(options) {
		switch (options.arrayFormat) {
			case 'index':
				return key => (result, value) => {
					const index = result.length;

					if (
						value === undefined ||
						(options.skipNull && value === null) ||
						(options.skipEmptyString && value === '')
					) {
						return result;
					}

					if (value === null) {
						return [...result, [encode(key, options), '[', index, ']'].join('')];
					}

					return [
						...result,
						[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')
					];
				};

			case 'bracket':
				return key => (result, value) => {
					if (
						value === undefined ||
						(options.skipNull && value === null) ||
						(options.skipEmptyString && value === '')
					) {
						return result;
					}

					if (value === null) {
						return [...result, [encode(key, options), '[]'].join('')];
					}

					return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
				};

			case 'colon-list-separator':
				return key => (result, value) => {
					if (
						value === undefined ||
						(options.skipNull && value === null) ||
						(options.skipEmptyString && value === '')
					) {
						return result;
					}

					if (value === null) {
						return [...result, [encode(key, options), ':list='].join('')];
					}

					return [...result, [encode(key, options), ':list=', encode(value, options)].join('')];
				};

			case 'comma':
			case 'separator':
			case 'bracket-separator': {
				const keyValueSep = options.arrayFormat === 'bracket-separator' ?
					'[]=' :
					'=';

				return key => (result, value) => {
					if (
						value === undefined ||
						(options.skipNull && value === null) ||
						(options.skipEmptyString && value === '')
					) {
						return result;
					}

					// Translate null to an empty string so that it doesn't serialize as 'null'
					value = value === null ? '' : value;

					if (result.length === 0) {
						return [[encode(key, options), keyValueSep, encode(value, options)].join('')];
					}

					return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
				};
			}

			default:
				return key => (result, value) => {
					if (
						value === undefined ||
						(options.skipNull && value === null) ||
						(options.skipEmptyString && value === '')
					) {
						return result;
					}

					if (value === null) {
						return [...result, encode(key, options)];
					}

					return [...result, [encode(key, options), '=', encode(value, options)].join('')];
				};
		}
	}

	function parserForArrayFormat(options) {
		let result;

		switch (options.arrayFormat) {
			case 'index':
				return (key, value, accumulator) => {
					result = /\[(\d*)\]$/.exec(key);

					key = key.replace(/\[\d*\]$/, '');

					if (!result) {
						accumulator[key] = value;
						return;
					}

					if (accumulator[key] === undefined) {
						accumulator[key] = {};
					}

					accumulator[key][result[1]] = value;
				};

			case 'bracket':
				return (key, value, accumulator) => {
					result = /(\[\])$/.exec(key);
					key = key.replace(/\[\]$/, '');

					if (!result) {
						accumulator[key] = value;
						return;
					}

					if (accumulator[key] === undefined) {
						accumulator[key] = [value];
						return;
					}

					accumulator[key] = [].concat(accumulator[key], value);
				};

			case 'colon-list-separator':
				return (key, value, accumulator) => {
					result = /(:list)$/.exec(key);
					key = key.replace(/:list$/, '');

					if (!result) {
						accumulator[key] = value;
						return;
					}

					if (accumulator[key] === undefined) {
						accumulator[key] = [value];
						return;
					}

					accumulator[key] = [].concat(accumulator[key], value);
				};

			case 'comma':
			case 'separator':
				return (key, value, accumulator) => {
					const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
					const isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));
					value = isEncodedArray ? decode(value, options) : value;
					const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
					accumulator[key] = newValue;
				};

			case 'bracket-separator':
				return (key, value, accumulator) => {
					const isArray = /(\[\])$/.test(key);
					key = key.replace(/\[\]$/, '');

					if (!isArray) {
						accumulator[key] = value ? decode(value, options) : value;
						return;
					}

					const arrayValue = value === null ?
						[] :
						value.split(options.arrayFormatSeparator).map(item => decode(item, options));

					if (accumulator[key] === undefined) {
						accumulator[key] = arrayValue;
						return;
					}

					accumulator[key] = [].concat(accumulator[key], arrayValue);
				};

			default:
				return (key, value, accumulator) => {
					if (accumulator[key] === undefined) {
						accumulator[key] = value;
						return;
					}

					accumulator[key] = [].concat(accumulator[key], value);
				};
		}
	}

	function validateArrayFormatSeparator(value) {
		if (typeof value !== 'string' || value.length !== 1) {
			throw new TypeError('arrayFormatSeparator must be single character string');
		}
	}

	function encode(value, options) {
		if (options.encode) {
			return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
		}

		return value;
	}

	function decode(value, options) {
		if (options.decode) {
			return decodeUriComponent(value);
		}

		return value;
	}

	function keysSorter(input) {
		if (Array.isArray(input)) {
			return input.sort();
		}

		if (typeof input === 'object') {
			return keysSorter(Object.keys(input))
				.sort((a, b) => Number(a) - Number(b))
				.map(key => input[key]);
		}

		return input;
	}

	function removeHash(input) {
		const hashStart = input.indexOf('#');
		if (hashStart !== -1) {
			input = input.slice(0, hashStart);
		}

		return input;
	}

	function getHash(url) {
		let hash = '';
		const hashStart = url.indexOf('#');
		if (hashStart !== -1) {
			hash = url.slice(hashStart);
		}

		return hash;
	}

	function extract(input) {
		input = removeHash(input);
		const queryStart = input.indexOf('?');
		if (queryStart === -1) {
			return '';
		}

		return input.slice(queryStart + 1);
	}

	function parseValue(value, options) {
		if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
			value = Number(value);
		} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
			value = value.toLowerCase() === 'true';
		}

		return value;
	}

	function parse(query, options) {
		options = Object.assign({
			decode: true,
			sort: true,
			arrayFormat: 'none',
			arrayFormatSeparator: ',',
			parseNumbers: false,
			parseBooleans: false
		}, options);

		validateArrayFormatSeparator(options.arrayFormatSeparator);

		const formatter = parserForArrayFormat(options);

		// Create an object with no prototype
		const ret = Object.create(null);

		if (typeof query !== 'string') {
			return ret;
		}

		query = query.trim().replace(/^[?#&]/, '');

		if (!query) {
			return ret;
		}

		for (const param of query.split('&')) {
			if (param === '') {
				continue;
			}

			let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '=');

			// Missing `=` should be `null`:
			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
			value = value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options);
			formatter(decode(key, options), value, ret);
		}

		for (const key of Object.keys(ret)) {
			const value = ret[key];
			if (typeof value === 'object' && value !== null) {
				for (const k of Object.keys(value)) {
					value[k] = parseValue(value[k], options);
				}
			} else {
				ret[key] = parseValue(value, options);
			}
		}

		if (options.sort === false) {
			return ret;
		}

		return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
			const value = ret[key];
			if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
				// Sort object keys, not values
				result[key] = keysSorter(value);
			} else {
				result[key] = value;
			}

			return result;
		}, Object.create(null));
	}

	exports.extract = extract;
	exports.parse = parse;

	exports.stringify = (object, options) => {
		if (!object) {
			return '';
		}

		options = Object.assign({
			encode: true,
			strict: true,
			arrayFormat: 'none',
			arrayFormatSeparator: ','
		}, options);

		validateArrayFormatSeparator(options.arrayFormatSeparator);

		const shouldFilter = key => (
			(options.skipNull && isNullOrUndefined(object[key])) ||
			(options.skipEmptyString && object[key] === '')
		);

		const formatter = encoderForArrayFormat(options);

		const objectCopy = {};

		for (const key of Object.keys(object)) {
			if (!shouldFilter(key)) {
				objectCopy[key] = object[key];
			}
		}

		const keys = Object.keys(objectCopy);

		if (options.sort !== false) {
			keys.sort(options.sort);
		}

		return keys.map(key => {
			const value = object[key];

			if (value === undefined) {
				return '';
			}

			if (value === null) {
				return encode(key, options);
			}

			if (Array.isArray(value)) {
				if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
					return encode(key, options) + '[]';
				}

				return value
					.reduce(formatter(key), [])
					.join('&');
			}

			return encode(key, options) + '=' + encode(value, options);
		}).filter(x => x.length > 0).join('&');
	};

	exports.parseUrl = (url, options) => {
		options = Object.assign({
			decode: true
		}, options);

		const [url_, hash] = splitOnFirst(url, '#');

		return Object.assign(
			{
				url: url_.split('?')[0] || '',
				query: parse(extract(url), options)
			},
			options && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}
		);
	};

	exports.stringifyUrl = (object, options) => {
		options = Object.assign({
			encode: true,
			strict: true,
			[encodeFragmentIdentifier]: true
		}, options);

		const url = removeHash(object.url).split('?')[0] || '';
		const queryFromUrl = exports.extract(object.url);
		const parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});

		const query = Object.assign(parsedQueryFromUrl, object.query);
		let queryString = exports.stringify(query, options);
		if (queryString) {
			queryString = `?${queryString}`;
		}

		let hash = getHash(object.url);
		if (object.fragmentIdentifier) {
			hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
		}

		return `${url}${queryString}${hash}`;
	};

	exports.pick = (input, filter, options) => {
		options = Object.assign({
			parseFragmentIdentifier: true,
			[encodeFragmentIdentifier]: false
		}, options);

		const {url, query, fragmentIdentifier} = exports.parseUrl(input, options);
		return exports.stringifyUrl({
			url,
			query: filterObj(query, filter),
			fragmentIdentifier
		}, options);
	};

	exports.exclude = (input, filter, options) => {
		const exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);

		return exports.pick(input, exclusionFilter, options);
	};
	});
	queryString.extract;
	queryString.parse;
	queryString.stringify;
	queryString.parseUrl;
	queryString.stringifyUrl;
	queryString.pick;
	queryString.exclude;

	var accessors$b = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ElementInstanceAccessor = exports.ElementInstanceListAccessor = exports.ElementListAccessor = exports.ElementAccessor = void 0;

	const query_string_1 = tslib_es6.__importDefault(queryString);
	class ElementAccessor {
	    constructor(options) {
	        this.options = options;
	    }
	    async get() {
	        return this.options.client.get(`${this.options.path}/${this.options.idOrKey}`);
	    }
	    async create(data) {
	        return this.options.client.put(this.options.path, data);
	    }
	    async put(data) {
	        return this.options.client.put(`${this.options.path}/${this.options.idOrKey}`, data);
	    }
	    async patch(data) {
	        return this.options.client.patch(`${this.options.path}/${this.options.idOrKey}`, data);
	    }
	    async archive() {
	        await this.options.client.delete(`${this.options.path}/${this.options.idOrKey}`);
	    }
	}
	exports.ElementAccessor = ElementAccessor;
	class ElementListAccessor {
	    constructor(client, path) {
	        this.client = client;
	        this.path = path;
	    }
	    async find(query) {
	        return this.client.get(this.path, query);
	    }
	    async create(data) {
	        return this.client.post(this.path, data);
	    }
	}
	exports.ElementListAccessor = ElementListAccessor;
	class ElementInstanceListAccessor {
	    constructor(client, path) {
	        this.client = client;
	        this.path = path;
	    }
	    async find(query) {
	        return this.client.get(this.path, query);
	    }
	}
	exports.ElementInstanceListAccessor = ElementInstanceListAccessor;
	class ElementInstanceAccessor {
	    constructor(options) {
	        this.options = options;
	    }
	    async get() {
	        return this.options.client.get(this.getPath());
	    }
	    async getId() {
	        if (!this.id) {
	            if (this.options.selector && typeof this.options.selector === 'string') {
	                this.id = this.options.selector;
	            }
	            else {
	                const element = await this.get();
	                if (!element) {
	                    throw new Error(`Element not found using selector ${JSON.stringify(this.options.selector)}`);
	                }
	                this.id = element.id;
	            }
	        }
	        return this.id;
	    }
	    async create(data) {
	        if (this.id) {
	            throw new Error('Cannot create: element already exists');
	        }
	        const element = await this.options.client.post(this.getPath(), data);
	        this.id = element.id;
	        return element;
	    }
	    async put(data) {
	        return this.options.client.put(this.getPath(), data);
	    }
	    async patch(data) {
	        return this.options.client.patch(this.getPath(), data);
	    }
	    async archive() {
	        return this.options.client.delete(this.getPath());
	    }
	    async delete() {
	        return this.options.client.delete(this.getPath());
	    }
	    getPath(operation = '') {
	        return (this.options.instancePath +
	            (operation ? `/${operation}` : '') +
	            '?' +
	            query_string_1.default.stringify(this.getSelector()));
	    }
	    getSelector() {
	        return typeof this.options.selector === 'string'
	            ? {
	                id: this.options.selector,
	            }
	            : this.options.selector;
	    }
	}
	exports.ElementInstanceAccessor = ElementInstanceAccessor;

	});

	unwrapExports(accessors$b);
	accessors$b.ElementInstanceAccessor;
	accessors$b.ElementInstanceListAccessor;
	accessors$b.ElementListAccessor;
	accessors$b.ElementAccessor;

	var MessageType;
	(function (MessageType) {
	    MessageType["Call"] = "call";
	    MessageType["Reply"] = "reply";
	    MessageType["Syn"] = "syn";
	    MessageType["SynAck"] = "synAck";
	    MessageType["Ack"] = "ack";
	})(MessageType || (MessageType = {}));
	var Resolution;
	(function (Resolution) {
	    Resolution["Fulfilled"] = "fulfilled";
	    Resolution["Rejected"] = "rejected";
	})(Resolution || (Resolution = {}));
	var ErrorCode;
	(function (ErrorCode) {
	    ErrorCode["ConnectionDestroyed"] = "ConnectionDestroyed";
	    ErrorCode["ConnectionTimeout"] = "ConnectionTimeout";
	    ErrorCode["NoIframeSrc"] = "NoIframeSrc";
	})(ErrorCode || (ErrorCode = {}));
	var NativeErrorName;
	(function (NativeErrorName) {
	    NativeErrorName["DataCloneError"] = "DataCloneError";
	})(NativeErrorName || (NativeErrorName = {}));
	var NativeEventType;
	(function (NativeEventType) {
	    NativeEventType["Message"] = "message";
	})(NativeEventType || (NativeEventType = {}));

	var createDestructor = (localName, log) => {
	    const callbacks = [];
	    let destroyed = false;
	    return {
	        destroy(error) {
	            if (!destroyed) {
	                destroyed = true;
	                log(`${localName}: Destroying connection`);
	                callbacks.forEach((callback) => {
	                    callback(error);
	                });
	            }
	        },
	        onDestroy(callback) {
	            destroyed ? callback() : callbacks.push(callback);
	        },
	    };
	};

	var createLogger = (debug) => {
	    /**
	     * Logs a message if debug is enabled.
	     */
	    return (...args) => {
	        if (debug) {
	            console.log('[Penpal]', ...args); // eslint-disable-line no-console
	        }
	    };
	};

	const DEFAULT_PORT_BY_PROTOCOL = {
	    'http:': '80',
	    'https:': '443',
	};
	const URL_REGEX = /^(https?:)?\/\/([^/:]+)?(:(\d+))?/;
	const opaqueOriginSchemes = ['file:', 'data:'];
	/**
	 * Converts a src value into an origin.
	 */
	var getOriginFromSrc = (src) => {
	    if (src && opaqueOriginSchemes.find((scheme) => src.startsWith(scheme))) {
	        // The origin of the child document is an opaque origin and its
	        // serialization is "null"
	        // https://html.spec.whatwg.org/multipage/origin.html#origin
	        return 'null';
	    }
	    // Note that if src is undefined, then srcdoc is being used instead of src
	    // and we can follow this same logic below to get the origin of the parent,
	    // which is the origin that we will need to use.
	    const location = document.location;
	    const regexResult = URL_REGEX.exec(src);
	    let protocol;
	    let hostname;
	    let port;
	    if (regexResult) {
	        // It's an absolute URL. Use the parsed info.
	        // regexResult[1] will be undefined if the URL starts with //
	        protocol = regexResult[1] ? regexResult[1] : location.protocol;
	        hostname = regexResult[2];
	        port = regexResult[4];
	    }
	    else {
	        // It's a relative path. Use the current location's info.
	        protocol = location.protocol;
	        hostname = location.hostname;
	        port = location.port;
	    }
	    // If the port is the default for the protocol, we don't want to add it to the origin string
	    // or it won't match the message's event.origin.
	    const portSuffix = port && port !== DEFAULT_PORT_BY_PROTOCOL[protocol] ? `:${port}` : '';
	    return `${protocol}//${hostname}${portSuffix}`;
	};

	/**
	 * Converts an error object into a plain object.
	 */
	const serializeError = ({ name, message, stack, }) => ({
	    name,
	    message,
	    stack,
	});
	/**
	 * Converts a plain object into an error object.
	 */
	const deserializeError = (obj) => {
	    const deserializedError = new Error();
	    // @ts-ignore
	    Object.keys(obj).forEach((key) => (deserializedError[key] = obj[key]));
	    return deserializedError;
	};

	/**
	 * Listens for "call" messages coming from the remote, executes the corresponding method, and
	 * responds with the return value.
	 */
	var connectCallReceiver = (info, serializedMethods, log) => {
	    const { localName, local, remote, originForSending, originForReceiving, } = info;
	    let destroyed = false;
	    const handleMessageEvent = (event) => {
	        if (event.source !== remote || event.data.penpal !== MessageType.Call) {
	            return;
	        }
	        if (originForReceiving !== '*' && event.origin !== originForReceiving) {
	            log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);
	            return;
	        }
	        const callMessage = event.data;
	        const { methodName, args, id } = callMessage;
	        log(`${localName}: Received ${methodName}() call`);
	        const createPromiseHandler = (resolution) => {
	            return (returnValue) => {
	                log(`${localName}: Sending ${methodName}() reply`);
	                if (destroyed) {
	                    // It's possible to throw an error here, but it would need to be thrown asynchronously
	                    // and would only be catchable using window.onerror. This is because the consumer
	                    // is merely returning a value from their method and not calling any function
	                    // that they could wrap in a try-catch. Even if the consumer were to catch the error,
	                    // the value of doing so is questionable. Instead, we'll just log a message.
	                    log(`${localName}: Unable to send ${methodName}() reply due to destroyed connection`);
	                    return;
	                }
	                const message = {
	                    penpal: MessageType.Reply,
	                    id,
	                    resolution,
	                    returnValue,
	                };
	                if (resolution === Resolution.Rejected &&
	                    returnValue instanceof Error) {
	                    message.returnValue = serializeError(returnValue);
	                    message.returnValueIsError = true;
	                }
	                try {
	                    remote.postMessage(message, originForSending);
	                }
	                catch (err) {
	                    // If a consumer attempts to send an object that's not cloneable (e.g., window),
	                    // we want to ensure the receiver's promise gets rejected.
	                    if (err.name === NativeErrorName.DataCloneError) {
	                        const errorReplyMessage = {
	                            penpal: MessageType.Reply,
	                            id,
	                            resolution: Resolution.Rejected,
	                            returnValue: serializeError(err),
	                            returnValueIsError: true,
	                        };
	                        remote.postMessage(errorReplyMessage, originForSending);
	                    }
	                    throw err;
	                }
	            };
	        };
	        new Promise((resolve) => resolve(serializedMethods[methodName].apply(serializedMethods, args))).then(createPromiseHandler(Resolution.Fulfilled), createPromiseHandler(Resolution.Rejected));
	    };
	    local.addEventListener(NativeEventType.Message, handleMessageEvent);
	    return () => {
	        destroyed = true;
	        local.removeEventListener(NativeEventType.Message, handleMessageEvent);
	    };
	};

	let id = 0;
	/**
	 * @return {number} A unique ID (not universally unique)
	 */
	var generateId = () => ++id;

	const KEY_PATH_DELIMITER = '.';
	const keyPathToSegments = (keyPath) => keyPath ? keyPath.split(KEY_PATH_DELIMITER) : [];
	const segmentsToKeyPath = (segments) => segments.join(KEY_PATH_DELIMITER);
	const createKeyPath = (key, prefix) => {
	    const segments = keyPathToSegments(prefix || '');
	    segments.push(key);
	    return segmentsToKeyPath(segments);
	};
	/**
	 * Given a `keyPath`, set it to be `value` on `subject`, creating any intermediate
	 * objects along the way.
	 *
	 * @param {Object} subject The object on which to set value.
	 * @param {string} keyPath The key path at which to set value.
	 * @param {Object} value The value to store at the given key path.
	 * @returns {Object} Updated subject.
	 */
	const setAtKeyPath = (subject, keyPath, value) => {
	    const segments = keyPathToSegments(keyPath);
	    segments.reduce((prevSubject, key, idx) => {
	        if (typeof prevSubject[key] === 'undefined') {
	            prevSubject[key] = {};
	        }
	        if (idx === segments.length - 1) {
	            prevSubject[key] = value;
	        }
	        return prevSubject[key];
	    }, subject);
	    return subject;
	};
	/**
	 * Given a dictionary of (nested) keys to function, flatten them to a map
	 * from key path to function.
	 *
	 * @param {Object} methods The (potentially nested) object to serialize.
	 * @param {string} prefix A string with which to prefix entries. Typically not intended to be used by consumers.
	 * @returns {Object} An map from key path in `methods` to functions.
	 */
	const serializeMethods = (methods, prefix) => {
	    const flattenedMethods = {};
	    Object.keys(methods).forEach((key) => {
	        const value = methods[key];
	        const keyPath = createKeyPath(key, prefix);
	        if (typeof value === 'object') {
	            // Recurse into any nested children.
	            Object.assign(flattenedMethods, serializeMethods(value, keyPath));
	        }
	        if (typeof value === 'function') {
	            // If we've found a method, expose it.
	            flattenedMethods[keyPath] = value;
	        }
	    });
	    return flattenedMethods;
	};
	/**
	 * Given a map of key paths to functions, unpack the key paths to an object.
	 *
	 * @param {Object} flattenedMethods A map of key paths to functions to unpack.
	 * @returns {Object} A (potentially nested) map of functions.
	 */
	const deserializeMethods = (flattenedMethods) => {
	    const methods = {};
	    for (const keyPath in flattenedMethods) {
	        setAtKeyPath(methods, keyPath, flattenedMethods[keyPath]);
	    }
	    return methods;
	};

	/**
	 * Augments an object with methods that match those defined by the remote. When these methods are
	 * called, a "call" message will be sent to the remote, the remote's corresponding method will be
	 * executed, and the method's return value will be returned via a message.
	 * @param {Object} callSender Sender object that should be augmented with methods.
	 * @param {Object} info Information about the local and remote windows.
	 * @param {Array} methodKeyPaths Key paths of methods available to be called on the remote.
	 * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal
	 * connection.
	 * @returns {Object} The call sender object with methods that may be called.
	 */
	var connectCallSender = (callSender, info, methodKeyPaths, destroyConnection, log) => {
	    const { localName, local, remote, originForSending, originForReceiving, } = info;
	    let destroyed = false;
	    log(`${localName}: Connecting call sender`);
	    const createMethodProxy = (methodName) => {
	        return (...args) => {
	            log(`${localName}: Sending ${methodName}() call`);
	            // This handles the case where the iframe has been removed from the DOM
	            // (and therefore its window closed), the consumer has not yet
	            // called destroy(), and the user calls a method exposed by
	            // the remote. We detect the iframe has been removed and force
	            // a destroy() immediately so that the consumer sees the error saying
	            // the connection has been destroyed. We wrap this check in a try catch
	            // because Edge throws an "Object expected" error when accessing
	            // contentWindow.closed on a contentWindow from an iframe that's been
	            // removed from the DOM.
	            let iframeRemoved;
	            try {
	                if (remote.closed) {
	                    iframeRemoved = true;
	                }
	            }
	            catch (e) {
	                iframeRemoved = true;
	            }
	            if (iframeRemoved) {
	                destroyConnection();
	            }
	            if (destroyed) {
	                const error = new Error(`Unable to send ${methodName}() call due ` + `to destroyed connection`);
	                error.code = ErrorCode.ConnectionDestroyed;
	                throw error;
	            }
	            return new Promise((resolve, reject) => {
	                const id = generateId();
	                const handleMessageEvent = (event) => {
	                    if (event.source !== remote ||
	                        event.data.penpal !== MessageType.Reply ||
	                        event.data.id !== id) {
	                        return;
	                    }
	                    if (originForReceiving !== '*' &&
	                        event.origin !== originForReceiving) {
	                        log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);
	                        return;
	                    }
	                    const replyMessage = event.data;
	                    log(`${localName}: Received ${methodName}() reply`);
	                    local.removeEventListener(NativeEventType.Message, handleMessageEvent);
	                    let returnValue = replyMessage.returnValue;
	                    if (replyMessage.returnValueIsError) {
	                        returnValue = deserializeError(returnValue);
	                    }
	                    (replyMessage.resolution === Resolution.Fulfilled ? resolve : reject)(returnValue);
	                };
	                local.addEventListener(NativeEventType.Message, handleMessageEvent);
	                const callMessage = {
	                    penpal: MessageType.Call,
	                    id,
	                    methodName,
	                    args,
	                };
	                remote.postMessage(callMessage, originForSending);
	            });
	        };
	    };
	    // Wrap each method in a proxy which sends it to the corresponding receiver.
	    const flattenedMethods = methodKeyPaths.reduce((api, name) => {
	        api[name] = createMethodProxy(name);
	        return api;
	    }, {});
	    // Unpack the structure of the provided methods object onto the CallSender, exposing
	    // the methods in the same shape they were provided.
	    Object.assign(callSender, deserializeMethods(flattenedMethods));
	    return () => {
	        destroyed = true;
	    };
	};

	/**
	 * Handles an ACK handshake message.
	 */
	var handleAckMessageFactory = (serializedMethods, childOrigin, originForSending, destructor, log) => {
	    const { destroy, onDestroy } = destructor;
	    let destroyCallReceiver;
	    let receiverMethodNames;
	    // We resolve the promise with the call sender. If the child reconnects
	    // (for example, after refreshing or navigating to another page that
	    // uses Penpal, we'll update the call sender with methods that match the
	    // latest provided by the child.
	    const callSender = {};
	    return (event) => {
	        if (childOrigin !== '*' && event.origin !== childOrigin) {
	            log(`Parent: Handshake - Received ACK message from origin ${event.origin} which did not match expected origin ${childOrigin}`);
	            return;
	        }
	        log('Parent: Handshake - Received ACK');
	        const info = {
	            localName: 'Parent',
	            local: window,
	            remote: event.source,
	            originForSending: originForSending,
	            originForReceiving: childOrigin,
	        };
	        // If the child reconnected, we need to destroy the prior call receiver
	        // before setting up a new one.
	        if (destroyCallReceiver) {
	            destroyCallReceiver();
	        }
	        destroyCallReceiver = connectCallReceiver(info, serializedMethods, log);
	        onDestroy(destroyCallReceiver);
	        // If the child reconnected, we need to remove the methods from the
	        // previous call receiver off the sender.
	        if (receiverMethodNames) {
	            receiverMethodNames.forEach((receiverMethodName) => {
	                delete callSender[receiverMethodName];
	            });
	        }
	        receiverMethodNames = event.data.methodNames;
	        const destroyCallSender = connectCallSender(callSender, info, receiverMethodNames, destroy, log);
	        onDestroy(destroyCallSender);
	        return callSender;
	    };
	};

	/**
	 * Handles a SYN handshake message.
	 */
	var handleSynMessageFactory = (log, serializedMethods, childOrigin, originForSending) => {
	    return (event) => {
	        if (childOrigin !== '*' && event.origin !== childOrigin) {
	            log(`Parent: Handshake - Received SYN message from origin ${event.origin} which did not match expected origin ${childOrigin}`);
	            return;
	        }
	        log('Parent: Handshake - Received SYN, responding with SYN-ACK');
	        const synAckMessage = {
	            penpal: MessageType.SynAck,
	            methodNames: Object.keys(serializedMethods),
	        };
	        event.source.postMessage(synAckMessage, originForSending);
	    };
	};

	const CHECK_IFRAME_IN_DOC_INTERVAL = 60000;
	/**
	 * Monitors for iframe removal and destroys connection if iframe
	 * is found to have been removed from DOM. This is to prevent memory
	 * leaks when the iframe is removed from the document and the consumer
	 * hasn't called destroy(). Without this, event listeners attached to
	 * the window would stick around and since the event handlers have a
	 * reference to the iframe in their closures, the iframe would stick
	 * around too.
	 */
	var monitorIframeRemoval = (iframe, destructor) => {
	    const { destroy, onDestroy } = destructor;
	    const checkIframeInDocIntervalId = setInterval(() => {
	        if (!iframe.isConnected) {
	            clearInterval(checkIframeInDocIntervalId);
	            destroy();
	        }
	    }, CHECK_IFRAME_IN_DOC_INTERVAL);
	    onDestroy(() => {
	        clearInterval(checkIframeInDocIntervalId);
	    });
	};

	/**
	 * Starts a timeout and calls the callback with an error
	 * if the timeout completes before the stop function is called.
	 */
	var startConnectionTimeout = (timeout, callback) => {
	    let timeoutId;
	    if (timeout !== undefined) {
	        timeoutId = window.setTimeout(() => {
	            const error = new Error(`Connection timed out after ${timeout}ms`);
	            error.code = ErrorCode.ConnectionTimeout;
	            callback(error);
	        }, timeout);
	    }
	    return () => {
	        clearTimeout(timeoutId);
	    };
	};

	var validateIframeHasSrcOrSrcDoc = (iframe) => {
	    if (!iframe.src && !iframe.srcdoc) {
	        const error = new Error('Iframe must have src or srcdoc property defined.');
	        error.code = ErrorCode.NoIframeSrc;
	        throw error;
	    }
	};

	/**
	 * Attempts to establish communication with an iframe.
	 */
	var connectToChild = (options) => {
	    let { iframe, methods = {}, childOrigin, timeout, debug = false } = options;
	    const log = createLogger(debug);
	    const destructor = createDestructor('Parent', log);
	    const { onDestroy, destroy } = destructor;
	    if (!childOrigin) {
	        validateIframeHasSrcOrSrcDoc(iframe);
	        childOrigin = getOriginFromSrc(iframe.src);
	    }
	    // If event.origin is "null", the remote protocol is file: or data: and we
	    // must post messages with "*" as targetOrigin when sending messages.
	    // https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#Using_window.postMessage_in_extensions
	    const originForSending = childOrigin === 'null' ? '*' : childOrigin;
	    const serializedMethods = serializeMethods(methods);
	    const handleSynMessage = handleSynMessageFactory(log, serializedMethods, childOrigin, originForSending);
	    const handleAckMessage = handleAckMessageFactory(serializedMethods, childOrigin, originForSending, destructor, log);
	    const promise = new Promise((resolve, reject) => {
	        const stopConnectionTimeout = startConnectionTimeout(timeout, destroy);
	        const handleMessage = (event) => {
	            if (event.source !== iframe.contentWindow || !event.data) {
	                return;
	            }
	            if (event.data.penpal === MessageType.Syn) {
	                handleSynMessage(event);
	                return;
	            }
	            if (event.data.penpal === MessageType.Ack) {
	                const callSender = handleAckMessage(event);
	                if (callSender) {
	                    stopConnectionTimeout();
	                    resolve(callSender);
	                }
	                return;
	            }
	        };
	        window.addEventListener(NativeEventType.Message, handleMessage);
	        log('Parent: Awaiting handshake');
	        monitorIframeRemoval(iframe, destructor);
	        onDestroy((error) => {
	            window.removeEventListener(NativeEventType.Message, handleMessage);
	            if (error) {
	                reject(error);
	            }
	        });
	    });
	    return {
	        promise,
	        destroy() {
	            // Don't allow consumer to pass an error into destroy.
	            destroy();
	        },
	    };
	};

	/**
	 * Handles a SYN-ACK handshake message.
	 */
	var handleSynAckMessageFactory = (parentOrigin, serializedMethods, destructor, log) => {
	    const { destroy, onDestroy } = destructor;
	    return (event) => {
	        let originQualifies = parentOrigin instanceof RegExp
	            ? parentOrigin.test(event.origin)
	            : parentOrigin === '*' || parentOrigin === event.origin;
	        if (!originQualifies) {
	            log(`Child: Handshake - Received SYN-ACK from origin ${event.origin} which did not match expected origin ${parentOrigin}`);
	            return;
	        }
	        log('Child: Handshake - Received SYN-ACK, responding with ACK');
	        // If event.origin is "null", the remote protocol is file: or data: and we
	        // must post messages with "*" as targetOrigin when sending messages.
	        // https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#Using_window.postMessage_in_extensions
	        const originForSending = event.origin === 'null' ? '*' : event.origin;
	        const ackMessage = {
	            penpal: MessageType.Ack,
	            methodNames: Object.keys(serializedMethods),
	        };
	        window.parent.postMessage(ackMessage, originForSending);
	        const info = {
	            localName: 'Child',
	            local: window,
	            remote: window.parent,
	            originForSending,
	            originForReceiving: event.origin,
	        };
	        const destroyCallReceiver = connectCallReceiver(info, serializedMethods, log);
	        onDestroy(destroyCallReceiver);
	        const callSender = {};
	        const destroyCallSender = connectCallSender(callSender, info, event.data.methodNames, destroy, log);
	        onDestroy(destroyCallSender);
	        return callSender;
	    };
	};

	const areGlobalsAccessible = () => {
	    try {
	        clearTimeout();
	    }
	    catch (e) {
	        return false;
	    }
	    return true;
	};
	/**
	 * Attempts to establish communication with the parent window.
	 */
	var connectToParent = (options = {}) => {
	    const { parentOrigin = '*', methods = {}, timeout, debug = false } = options;
	    const log = createLogger(debug);
	    const destructor = createDestructor('Child', log);
	    const { destroy, onDestroy } = destructor;
	    const serializedMethods = serializeMethods(methods);
	    const handleSynAckMessage = handleSynAckMessageFactory(parentOrigin, serializedMethods, destructor, log);
	    const sendSynMessage = () => {
	        log('Child: Handshake - Sending SYN');
	        const synMessage = { penpal: MessageType.Syn };
	        const parentOriginForSyn = parentOrigin instanceof RegExp ? '*' : parentOrigin;
	        window.parent.postMessage(synMessage, parentOriginForSyn);
	    };
	    const promise = new Promise((resolve, reject) => {
	        const stopConnectionTimeout = startConnectionTimeout(timeout, destroy);
	        const handleMessage = (event) => {
	            // Under niche scenarios, we get into this function after
	            // the iframe has been removed from the DOM. In Edge, this
	            // results in "Object expected" errors being thrown when we
	            // try to access properties on window (global properties).
	            // For this reason, we try to access a global up front (clearTimeout)
	            // and if it fails we can assume the iframe has been removed
	            // and we ignore the message event.
	            if (!areGlobalsAccessible()) {
	                return;
	            }
	            if (event.source !== parent || !event.data) {
	                return;
	            }
	            if (event.data.penpal === MessageType.SynAck) {
	                const callSender = handleSynAckMessage(event);
	                if (callSender) {
	                    window.removeEventListener(NativeEventType.Message, handleMessage);
	                    stopConnectionTimeout();
	                    resolve(callSender);
	                }
	            }
	        };
	        window.addEventListener(NativeEventType.Message, handleMessage);
	        sendSynMessage();
	        onDestroy((error) => {
	            window.removeEventListener(NativeEventType.Message, handleMessage);
	            if (error) {
	                reject(error);
	            }
	        });
	    });
	    return {
	        promise,
	        destroy() {
	            // Don't allow consumer to pass an error into destroy.
	            destroy();
	        },
	    };
	};

	var lib = /*#__PURE__*/Object.freeze({
		__proto__: null,
		connectToChild: connectToChild,
		connectToParent: connectToParent,
		get ErrorCode () { return ErrorCode; }
	});

	var containers = []; // will store container HTMLElement references
	var styleElements = []; // will store {prepend: HTMLElement, append: HTMLElement}

	var usage = 'insert-css: You need to provide a CSS string. Usage: insertCss(cssString[, options]).';

	function insertCss(css, options) {
	    options = options || {};

	    if (css === undefined) {
	        throw new Error(usage);
	    }

	    var position = options.prepend === true ? 'prepend' : 'append';
	    var container = options.container !== undefined ? options.container : document.querySelector('head');
	    var containerId = containers.indexOf(container);

	    // first time we see this container, create the necessary entries
	    if (containerId === -1) {
	        containerId = containers.push(container) - 1;
	        styleElements[containerId] = {};
	    }

	    // try to get the correponding container + position styleElement, create it otherwise
	    var styleElement;

	    if (styleElements[containerId] !== undefined && styleElements[containerId][position] !== undefined) {
	        styleElement = styleElements[containerId][position];
	    } else {
	        styleElement = styleElements[containerId][position] = createStyleElement();

	        if (position === 'prepend') {
	            container.insertBefore(styleElement, container.childNodes[0]);
	        } else {
	            container.appendChild(styleElement);
	        }
	    }

	    // strip potential UTF-8 BOM if css was read from a file
	    if (css.charCodeAt(0) === 0xFEFF) { css = css.substr(1, css.length); }

	    // actually add the stylesheet
	    if (styleElement.styleSheet) {
	        styleElement.styleSheet.cssText += css;
	    } else {
	        styleElement.textContent += css;
	    }

	    return styleElement;
	}
	function createStyleElement() {
	    var styleElement = document.createElement('style');
	    styleElement.setAttribute('type', 'text/css');
	    return styleElement;
	}

	var insertCss_1 = insertCss;
	var insertCss_2 = insertCss;
	insertCss_1.insertCss = insertCss_2;

	var iframe = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.init = exports.openIframe = exports.showIframeLoader = exports.POPUP_ELEMENT_ID = void 0;


	exports.POPUP_ELEMENT_ID = '__integration-app-popup';
	const CONTAINER_ELEMENT_ID = '__integration-app-container';
	const CONTAINER_ELEMENT_CLASS = '__integration-app-container';
	const CONTAINER_ELEMENT_CLASS__VISIBLE = '__integration-app-container__visible';
	const CONTAINER_ELEMENT_CLASS__LOADER = '__integration-app-container__loader';
	const CONTAINER_ELEMENT_CLASS_KEYFRAMES = '__integration-app-container-keyframes';
	const BODY_CLASS = '__integration-app-open';
	let initialized = false;
	let handshakeTimeout = null;
	const HANDSHAKE_TIMEOUT_MS = 10000;
	function showIframeLoader() {
	    if (!initialized) {
	        initialized = true;
	        init();
	    }
	    const container = getContainer();
	    container.classList.add(CONTAINER_ELEMENT_CLASS__LOADER);
	}
	exports.showIframeLoader = showIframeLoader;
	function hideIframeLoader() {
	    const container = getContainer();
	    container.classList.remove(CONTAINER_ELEMENT_CLASS__LOADER);
	}
	async function openIframe(uri, callbacks = {}) {
	    if (!initialized) {
	        initialized = true;
	        init();
	    }
	    close();
	    return new Promise((resolve) => {
	        function complete(callback) {
	            close(callback);
	            resolve();
	        }
	        handshakeTimeout = setTimeout(() => {
	            console.error('It takes too long for Integration UI to load. Something must be wrong.');
	            complete(callbacks.onClose);
	        }, HANDSHAKE_TIMEOUT_MS);
	        function handshake() {
	            clearHandshakeTimeout();
	        }
	        function doOpen() {
	            const iframe = document.createElement('iframe');
	            iframe.src = uri;
	            iframe.id = exports.POPUP_ELEMENT_ID;
	            if (!!getContainer()) {
	                document.body.classList.add(BODY_CLASS);
	                appendToContainer(iframe);
	                showContainer();
	                (0, lib.connectToChild)({
	                    iframe,
	                    methods: {
	                        ...callbacks,
	                        close: () => complete(callbacks.onClose),
	                        handshake,
	                    },
	                });
	            }
	            else {
	                throw Error('Integration.app container element not found. Was it manually removed?');
	            }
	        }
	        if (document.readyState === 'complete' ||
	            document.readyState === 'interactive') {
	            doOpen();
	        }
	        else {
	            document.addEventListener('DOMContentLoaded', () => {
	                doOpen();
	            });
	        }
	    });
	}
	exports.openIframe = openIframe;
	function close(callback) {
	    document.body.classList.remove(BODY_CLASS);
	    if (!!getContainer()) {
	        hideIframeLoader();
	        hideContainer();
	        clearContainer();
	        if (callback) {
	            callback();
	        }
	    }
	    clearHandshakeTimeout();
	}
	function init() {
	    (0, insertCss_1.insertCss)(`
    .${CONTAINER_ELEMENT_CLASS} {
      position: fixed;
      top: 0;
      bottom: 0;
      right: 0;
      left: 0;
      z-index: 2147483647;
      display: none;
    }
    .${CONTAINER_ELEMENT_CLASS}.${CONTAINER_ELEMENT_CLASS__LOADER}:not(.${CONTAINER_ELEMENT_CLASS__VISIBLE}):empty {
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.5);
    }
    .${CONTAINER_ELEMENT_CLASS}.${CONTAINER_ELEMENT_CLASS__LOADER}:not(.${CONTAINER_ELEMENT_CLASS__VISIBLE}):empty::before {
      content: "";
      border-radius: 50%;
      width: 2rem;
      height: 2rem;
      border: 0.3rem solid rgba(255, 255, 255, 0.2);
      border-top-color: white;
      -webkit-animation: ${CONTAINER_ELEMENT_CLASS_KEYFRAMES} 1s infinite linear;
      animation: ${CONTAINER_ELEMENT_CLASS_KEYFRAMES} 1s infinite linear;
    }
    .${CONTAINER_ELEMENT_CLASS__VISIBLE} {
      display: block;
    }
    .${CONTAINER_ELEMENT_CLASS} iframe {
      position: absolute;
      width: 100%;
      height: 100%;
      border-width: 0;
    }
    body.${BODY_CLASS} {
      overflow: hidden;
    }


    @-webkit-keyframes ${CONTAINER_ELEMENT_CLASS_KEYFRAMES} {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }
    @keyframes ${CONTAINER_ELEMENT_CLASS_KEYFRAMES} {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }
  `);
	    const container = document.createElement('div');
	    container.id = CONTAINER_ELEMENT_ID;
	    container.classList.add(CONTAINER_ELEMENT_CLASS);
	    document.body.appendChild(container);
	}
	exports.init = init;
	function clearHandshakeTimeout() {
	    if (handshakeTimeout) {
	        clearTimeout(handshakeTimeout);
	        handshakeTimeout = null;
	    }
	}
	function getContainer() {
	    return document.getElementById(CONTAINER_ELEMENT_ID);
	}
	function showContainer() {
	    const container = getContainer();
	    container.classList.add(CONTAINER_ELEMENT_CLASS__VISIBLE);
	}
	function hideContainer() {
	    const container = getContainer();
	    container.classList.remove(CONTAINER_ELEMENT_CLASS__VISIBLE);
	}
	function appendToContainer(el) {
	    const container = getContainer();
	    container.appendChild(el);
	}
	function clearContainer() {
	    const container = getContainer();
	    if (container.firstChild) {
	        container.removeChild(container.firstChild);
	    }
	}

	});

	unwrapExports(iframe);
	iframe.init;
	iframe.openIframe;
	iframe.showIframeLoader;
	iframe.POPUP_ELEMENT_ID;

	var accessors$a = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ConnectionProxy = exports.ConnectionAccessor = exports.ConnectionsAccessor = void 0;

	const url_join_1 = tslib_es6.__importDefault(urlJoin);


	class ConnectionsAccessor extends accessors$b.ElementInstanceListAccessor {
	    constructor(client) {
	        super(client, 'connections');
	    }
	}
	exports.ConnectionsAccessor = ConnectionsAccessor;
	class ConnectionAccessor {
	    constructor(client, id) {
	        this.client = client;
	        this.id = id;
	    }
	    async get() {
	        return this.client.get(`/connections/${this.id}`);
	    }
	    async patch(data) {
	        return this.client.patch(`/connections/${this.id}`, data);
	    }
	    async archive() {
	        return this.client.delete(`/connections/${this.id}`);
	    }
	    async request(path, data = null) {
	        const pathWithoutSlash = path.startsWith('/') ? path.slice(1) : path;
	        return this.client.post(`/connections/${this.id}/api/${pathWithoutSlash}`, data);
	    }
	    get proxy() {
	        return new ConnectionProxy(this);
	    }
	    async refresh() {
	        (0, iframe.showIframeLoader)();
	        const uri = this.client.getEmbedUri(`/connections/${this.id}/refresh`);
	        return new Promise((resolve) => {
	            (0, iframe.openIframe)(uri, {
	                onClose: () => resolve(null),
	                onSuccess: (connection) => resolve(connection),
	            });
	        });
	    }
	}
	exports.ConnectionAccessor = ConnectionAccessor;
	class ConnectionProxy {
	    constructor(connection) {
	        this.connection = connection;
	    }
	    async get(path) {
	        return this.connection.client.get(this.getProxyPath(path));
	    }
	    async post(path, data) {
	        return this.connection.client.post(this.getProxyPath(path), data);
	    }
	    async put(path, data) {
	        return this.connection.client.put(this.getProxyPath(path), data);
	    }
	    async patch(path, data) {
	        return this.connection.client.patch(this.getProxyPath(path), data);
	    }
	    async delete(path) {
	        return this.connection.client.delete(this.getProxyPath(path));
	    }
	    getProxyPath(path) {
	        return (0, url_join_1.default)(`/connections/${this.connection.id}/api/proxy`, path);
	    }
	}
	exports.ConnectionProxy = ConnectionProxy;

	});

	unwrapExports(accessors$a);
	accessors$a.ConnectionProxy;
	accessors$a.ConnectionAccessor;
	accessors$a.ConnectionsAccessor;

	var entityRepository = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PaginationResponse = exports.PaginationQuery = void 0;
	class PaginationQuery {
	}
	exports.PaginationQuery = PaginationQuery;
	class PaginationResponse {
	}
	exports.PaginationResponse = PaginationResponse;

	});

	unwrapExports(entityRepository);
	entityRepository.PaginationResponse;
	entityRepository.PaginationQuery;

	var flowRuns = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.FlowRunAccessor = exports.FlowRunsAccessor = exports.FindFlowRunsResponse = exports.FlowRunsQuery = exports.FlowRunLaunchedByTrigger = exports.FlowRunState = exports.FLOW_RUN_CHANNEL_PREFIX = void 0;

	exports.FLOW_RUN_CHANNEL_PREFIX = 'private-flow-runs-';
	var FlowRunState;
	(function (FlowRunState) {
	    FlowRunState["RUNNING"] = "running";
	    FlowRunState["COMPLETED"] = "completed";
	    FlowRunState["FAILED"] = "failed";
	})(FlowRunState = exports.FlowRunState || (exports.FlowRunState = {}));
	(function (FlowRunLaunchedByTrigger) {
	    FlowRunLaunchedByTrigger["ApiTrigger"] = "api-trigger";
	    FlowRunLaunchedByTrigger["ScheduleTrigger"] = "schedule-trigger";
	    FlowRunLaunchedByTrigger["AppEventTrigger"] = "app-event-trigger";
	    FlowRunLaunchedByTrigger["DataSourceTrigger"] = "data-source-trigger";
	})(exports.FlowRunLaunchedByTrigger || (exports.FlowRunLaunchedByTrigger = {}));
	class FlowRunsQuery extends entityRepository.PaginationQuery {
	}
	exports.FlowRunsQuery = FlowRunsQuery;
	class FindFlowRunsResponse extends entityRepository.PaginationResponse {
	}
	exports.FindFlowRunsResponse = FindFlowRunsResponse;
	class FlowRunsAccessor {
	    constructor(client) {
	        this.client = client;
	    }
	    async find(query) {
	        return this.client.get('/flow-runs', query);
	    }
	    async create(request) {
	        return this.client.post('/flow-runs', request);
	    }
	}
	exports.FlowRunsAccessor = FlowRunsAccessor;
	class FlowRunAccessor {
	    constructor(client, id) {
	        this.client = client;
	        this.id = id;
	        this.baseUri = `/flow-runs/${id}`;
	    }
	    async get() {
	        return this.client.get(this.baseUri);
	    }
	    async getOutput() {
	        return this.client.get(`${this.baseUri}/output`);
	    }
	    async subscribe(options) {
	        const channelKey = `${exports.FLOW_RUN_CHANNEL_PREFIX}${this.id}`;
	        await this.client.subscribeToChannel(channelKey, options);
	    }
	    async unsubscribe() {
	        const channelKey = `${exports.FLOW_RUN_CHANNEL_PREFIX}${this.id}`;
	        await this.client.unsubscribeFromChannel(channelKey);
	    }
	    async repeat({ onUpdate, } = {}) {
	        const flowRun = await this.get();
	        if (flowRun.state === FlowRunState.RUNNING) {
	            throw new Error('Cannot repeat a running flow run.');
	        }
	        const flowInstanceAccessor = await this.client.flowInstance(flowRun.flowInstanceId);
	        return flowInstanceAccessor.run({
	            nodeKey: flowRun.startNodeKey,
	            input: flowRun.input,
	            onUpdate,
	        });
	    }
	}
	exports.FlowRunAccessor = FlowRunAccessor;

	});

	unwrapExports(flowRuns);
	flowRuns.FlowRunAccessor;
	flowRuns.FlowRunsAccessor;
	flowRuns.FindFlowRunsResponse;
	flowRuns.FlowRunsQuery;
	flowRuns.FlowRunLaunchedByTrigger;
	flowRuns.FlowRunState;
	flowRuns.FLOW_RUN_CHANNEL_PREFIX;

	var base = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.FlowNodeSpec = void 0;
	class FlowNodeSpec {
	    constructor(args) {
	        Object.assign(this, args);
	    }
	}
	exports.FlowNodeSpec = FlowNodeSpec;

	});

	unwrapExports(base);
	base.FlowNodeSpec;

	var apiTrigger = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.default = new base.FlowNodeSpec({
	    name: 'API Trigger',
	    description: 'Launch flow via API',
	    isTrigger: true,
	});

	});

	unwrapExports(apiTrigger);

	var scheduleTrigger = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.default = new base.FlowNodeSpec({
	    name: 'Schedule Trigger',
	    description: 'Run flow on schedule',
	    isTrigger: true,
	});

	});

	unwrapExports(scheduleTrigger);

	var appEventTrigger = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.default = new base.FlowNodeSpec({
	    name: 'App Event Trigger',
	    description: 'Trigger flow when a matching App Event is received',
	    isTrigger: true,
	});

	});

	unwrapExports(appEventTrigger);

	var dataRecordCreatedTrigger = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.default = new base.FlowNodeSpec({
	    name: 'Data Record Created Trigger',
	    description: 'Launch flow when a data record is created in a remote data collection',
	    isTrigger: true,
	});

	});

	unwrapExports(dataRecordCreatedTrigger);

	var dataRecordUpdatedTrigger = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.default = new base.FlowNodeSpec({
	    name: 'Data Record Updated Trigger',
	    description: 'Launch flow when a data record is updated in a remote data collection',
	    isTrigger: true,
	});

	});

	unwrapExports(dataRecordUpdatedTrigger);

	var dataRecordDeletedTrigger = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.default = new base.FlowNodeSpec({
	    name: 'Data Record Deleted Trigger',
	    description: 'Launch flow when a data record is deleted in a remote data collection',
	    isTrigger: true,
	});

	});

	unwrapExports(dataRecordDeletedTrigger);

	var listDataRecords = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.default = new base.FlowNodeSpec({
	    name: 'List Data Records',
	    description: 'List all records from a data collection with an optional filter',
	});

	});

	unwrapExports(listDataRecords);

	var lookupDataRecord = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.default = new base.FlowNodeSpec({
	    name: 'Lookup Data Record',
	    description: 'Find a one data record by its fields',
	});

	});

	unwrapExports(lookupDataRecord);

	var findDataRecords = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.default = new base.FlowNodeSpec({
	    name: 'Find Data Records',
	    description: 'Find records in a data collection by their field values',
	    isDeprecated: true,
	});

	});

	unwrapExports(findDataRecords);

	var findDataRecordById = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.default = new base.FlowNodeSpec({
	    name: 'Find Data Record By Id',
	    description: 'Find a single data record by id',
	});

	});

	unwrapExports(findDataRecordById);

	var createDataRecord = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.default = new base.FlowNodeSpec({
	    name: 'Create Data Record',
	    description: 'Create a new data record in a collection',
	});

	});

	unwrapExports(createDataRecord);

	var updateDataRecord = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.default = new base.FlowNodeSpec({
	    name: 'Update Data Record',
	    description: 'Update a new data record in a collection using its id',
	});

	});

	unwrapExports(updateDataRecord);

	var deleteDataRecord = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.default = new base.FlowNodeSpec({
	    name: 'Delete Data Record',
	    description: 'Delete a new data record from a collection using its id',
	});

	});

	unwrapExports(deleteDataRecord);

	var transformData = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.default = new base.FlowNodeSpec({
	    name: 'Transform Data',
	    description: 'Create a data structure of any shape by combining and transforming inputs',
	});

	});

	unwrapExports(transformData);

	var filter = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.default = new base.FlowNodeSpec({
	    name: 'Filter',
	    description: 'Filter records that go forward through the flow',
	});

	});

	unwrapExports(filter);

	var httpRequest = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.default = new base.FlowNodeSpec({
	    name: 'Http Request',
	    description: 'Send an arbitrary HTTP/S request',
	});

	});

	unwrapExports(httpRequest);

	var createDataLink = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.default = new base.FlowNodeSpec({
	    name: 'Create Data Link',
	    description: 'Link records between your app and external app',
	});

	});

	unwrapExports(createDataLink);

	var findDataLink = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.default = new base.FlowNodeSpec({
	    name: 'Find Data Link',
	    description: 'Find a link between records in your app and external app',
	});

	});

	unwrapExports(findDataLink);

	var nodes = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.FLOW_NODE_SPECS = exports.FlowNodeType = exports.FlowNodeSpec = void 0;

	Object.defineProperty(exports, "FlowNodeSpec", { enumerable: true, get: function () { return base.FlowNodeSpec; } });
	var FlowNodeType;
	(function (FlowNodeType) {
	    FlowNodeType["ApiTrigger"] = "api-trigger";
	    FlowNodeType["ScheduleTrigger"] = "schedule-trigger";
	    FlowNodeType["AppEventTrigger"] = "app-event-trigger";
	    FlowNodeType["DataRecordCreatedTrigger"] = "data-record-created-trigger";
	    FlowNodeType["DataRecordUpdatedTrigger"] = "data-record-updated-trigger";
	    FlowNodeType["DataRecordDeletedTrigger"] = "data-record-deleted-trigger";
	    FlowNodeType["TransformData"] = "transform-data";
	    FlowNodeType["ListDataRecords"] = "list-data-records";
	    FlowNodeType["LookupDataRecord"] = "lookup-data-record";
	    FlowNodeType["FindDataRecordById"] = "find-data-record-by-id";
	    FlowNodeType["CreateDataRecord"] = "create-data-record";
	    FlowNodeType["UpdateDataRecord"] = "update-data-record";
	    FlowNodeType["DeleteDataRecord"] = "delete-data-record";
	    FlowNodeType["HttpRequest"] = "http-request";
	    FlowNodeType["Filter"] = "filter";
	    FlowNodeType["CreateDataLink"] = "create-data-link";
	    FlowNodeType["FindDataLink"] = "find-data-link";
	    FlowNodeType["FindDataRecords"] = "find-data-records";
	})(FlowNodeType = exports.FlowNodeType || (exports.FlowNodeType = {}));
	exports.FLOW_NODE_SPECS = {
	    [FlowNodeType.ApiTrigger]: apiTrigger.default,
	    [FlowNodeType.ScheduleTrigger]: scheduleTrigger.default,
	    [FlowNodeType.AppEventTrigger]: appEventTrigger.default,
	    [FlowNodeType.DataRecordCreatedTrigger]: dataRecordCreatedTrigger.default,
	    [FlowNodeType.DataRecordUpdatedTrigger]: dataRecordUpdatedTrigger.default,
	    [FlowNodeType.DataRecordDeletedTrigger]: dataRecordDeletedTrigger.default,
	    [FlowNodeType.ListDataRecords]: listDataRecords.default,
	    [FlowNodeType.LookupDataRecord]: lookupDataRecord.default,
	    [FlowNodeType.FindDataRecords]: findDataRecords.default,
	    [FlowNodeType.FindDataRecordById]: findDataRecordById
	        .default,
	    [FlowNodeType.CreateDataRecord]: createDataRecord.default,
	    [FlowNodeType.UpdateDataRecord]: updateDataRecord.default,
	    [FlowNodeType.DeleteDataRecord]: deleteDataRecord.default,
	    [FlowNodeType.TransformData]: transformData.default,
	    [FlowNodeType.Filter]: filter.default,
	    [FlowNodeType.HttpRequest]: httpRequest.default,
	    [FlowNodeType.CreateDataLink]: createDataLink.default,
	    [FlowNodeType.FindDataLink]: findDataLink.default,
	};

	});

	unwrapExports(nodes);
	nodes.FLOW_NODE_SPECS;
	nodes.FlowNodeType;
	nodes.FlowNodeSpec;

	var utils = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getOrderedNodeKeys = exports.getUpstreamNodeKeys = exports.getParentNodeKeys = exports.getDownstreamNodeKeys = exports.getChildNodeKeys = exports.getRootNodeKeys = exports.getFlowNodeSpec = exports.getFlowNode = void 0;

	function getFlowNode(flow, nodeKey) {
	    var _a;
	    return (_a = flow.nodes) === null || _a === void 0 ? void 0 : _a[nodeKey];
	}
	exports.getFlowNode = getFlowNode;
	function getFlowNodeSpec(node) {
	    if (!node) {
	        throw new Error(`getFlowNodeSpec called without a node`);
	    }
	    const spec = nodes.FLOW_NODE_SPECS[node.type];
	    if (!spec) {
	        throw new Error(`Unknow flow node type: ${node.type}`);
	    }
	    return spec;
	}
	exports.getFlowNodeSpec = getFlowNodeSpec;
	function getRootNodeKeys(flow) {
	    var _a, _b;
	    const allNodeKeys = Object.keys((_a = flow.nodes) !== null && _a !== void 0 ? _a : {});
	    const allLinkKeys = Object.values((_b = flow.nodes) !== null && _b !== void 0 ? _b : {})
	        .flatMap((n) => { var _a, _b; return (_b = (_a = n.links) === null || _a === void 0 ? void 0 : _a.map((l) => l.key)) !== null && _b !== void 0 ? _b : []; })
	        .filter(Boolean);
	    return allNodeKeys.filter((k) => !allLinkKeys.includes(k));
	}
	exports.getRootNodeKeys = getRootNodeKeys;
	function getChildNodeKeys(flow, nodeKey) {
	    const node = getFlowNode(flow, nodeKey);
	    const nodeLinks = (node === null || node === void 0 ? void 0 : node.links) || [];
	    return nodeLinks
	        .map((nodeLink) => nodeLink.key)
	        .filter(Boolean)
	        .filter((k) => { var _a; return !!((_a = flow.nodes) === null || _a === void 0 ? void 0 : _a[k]); });
	}
	exports.getChildNodeKeys = getChildNodeKeys;
	function getDownstreamNodeKeys(flow, nodeKey) {
	    const linkedKeys = getChildNodeKeys(flow, nodeKey);
	    return linkedKeys.concat(linkedKeys.map((k) => getChildNodeKeys(flow, k)).flat());
	}
	exports.getDownstreamNodeKeys = getDownstreamNodeKeys;
	function getParentNodeKeys(flow, nodeKey) {
	    return Object.keys(flow.nodes || {}).filter((key) => {
	        var _a;
	        const node = getFlowNode(flow, key);
	        return (_a = node === null || node === void 0 ? void 0 : node.links) === null || _a === void 0 ? void 0 : _a.some((link) => link.key === nodeKey);
	    });
	}
	exports.getParentNodeKeys = getParentNodeKeys;
	function getUpstreamNodeKeys(flow, nodeKey) {
	    const parentKeys = getParentNodeKeys(flow, nodeKey);
	    return parentKeys.concat(parentKeys.map((n) => getUpstreamNodeKeys(flow, n)).flat());
	}
	exports.getUpstreamNodeKeys = getUpstreamNodeKeys;
	function getOrderedNodeKeys(flow) {
	    const rootNodeKeys = getRootNodeKeys(flow);
	    const orderedNodeKeys = rootNodeKeys;
	    let hasMore = true;
	    while (hasMore) {
	        hasMore = false;
	        for (const nodeKey of orderedNodeKeys) {
	            for (const childNodeKey of getChildNodeKeys(flow, nodeKey)) {
	                if (!orderedNodeKeys.includes(childNodeKey)) {
	                    orderedNodeKeys.push(childNodeKey);
	                    hasMore = true;
	                }
	            }
	        }
	    }
	    return orderedNodeKeys;
	}
	exports.getOrderedNodeKeys = getOrderedNodeKeys;

	});

	unwrapExports(utils);
	utils.getOrderedNodeKeys;
	utils.getUpstreamNodeKeys;
	utils.getParentNodeKeys;
	utils.getDownstreamNodeKeys;
	utils.getChildNodeKeys;
	utils.getRootNodeKeys;
	utils.getFlowNodeSpec;
	utils.getFlowNode;

	var flows = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getOrderedNodeKeys = exports.getRootNodeKeys = exports.getUpstreamNodeKeys = exports.getParentNodeKeys = exports.getDownstreamNodeKeys = exports.getChildNodeKeys = exports.getFlowNode = exports.FlowInstanceNodeState = exports.FlowInstanceState = exports.FLOW_INSTANCE_CHANNEL_PREFIX = exports.FLOW_CHANNEL_PREFIX = void 0;
	exports.FLOW_CHANNEL_PREFIX = 'private-flows-';
	exports.FLOW_INSTANCE_CHANNEL_PREFIX = 'private-flow-instances-';
	(function (FlowInstanceState) {
	    FlowInstanceState["SETTING_UP"] = "SETTING_UP";
	    FlowInstanceState["SETUP_FAILED"] = "SETUP_FAILED";
	    FlowInstanceState["READY"] = "READY";
	})(exports.FlowInstanceState || (exports.FlowInstanceState = {}));
	(function (FlowInstanceNodeState) {
	    FlowInstanceNodeState["SETTING_UP"] = "SETTING_UP";
	    FlowInstanceNodeState["SETUP_FAILED"] = "SETUP_FAILED";
	    FlowInstanceNodeState["READY"] = "READY";
	})(exports.FlowInstanceNodeState || (exports.FlowInstanceNodeState = {}));

	Object.defineProperty(exports, "getFlowNode", { enumerable: true, get: function () { return utils.getFlowNode; } });
	Object.defineProperty(exports, "getChildNodeKeys", { enumerable: true, get: function () { return utils.getChildNodeKeys; } });
	Object.defineProperty(exports, "getDownstreamNodeKeys", { enumerable: true, get: function () { return utils.getDownstreamNodeKeys; } });
	Object.defineProperty(exports, "getParentNodeKeys", { enumerable: true, get: function () { return utils.getParentNodeKeys; } });
	Object.defineProperty(exports, "getUpstreamNodeKeys", { enumerable: true, get: function () { return utils.getUpstreamNodeKeys; } });
	Object.defineProperty(exports, "getRootNodeKeys", { enumerable: true, get: function () { return utils.getRootNodeKeys; } });
	Object.defineProperty(exports, "getOrderedNodeKeys", { enumerable: true, get: function () { return utils.getOrderedNodeKeys; } });

	});

	unwrapExports(flows);
	flows.getOrderedNodeKeys;
	flows.getRootNodeKeys;
	flows.getUpstreamNodeKeys;
	flows.getParentNodeKeys;
	flows.getDownstreamNodeKeys;
	flows.getChildNodeKeys;
	flows.getFlowNode;
	flows.FlowInstanceNodeState;
	flows.FlowInstanceState;
	flows.FLOW_INSTANCE_CHANNEL_PREFIX;
	flows.FLOW_CHANNEL_PREFIX;

	var accessors$9 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.FlowInstanceAccessor = exports.FlowInstancesAccessor = exports.FlowAccessor = exports.FlowsAccessor = void 0;




	const query_string_1 = tslib_es6.__importDefault(queryString);

	const MAX_POLLING_ERRORS = 10;
	class FlowsAccessor extends accessors$b.ElementListAccessor {
	    constructor(client) {
	        super(client, 'flows');
	    }
	}
	exports.FlowsAccessor = FlowsAccessor;
	class FlowAccessor extends accessors$b.ElementAccessor {
	    constructor(client, idOrKey) {
	        super({
	            client: client,
	            path: 'flows',
	            idOrKey,
	        });
	        this.client = client;
	    }
	    async runAll(params) {
	        const flow = await this.get();
	        const instancesPage = await this.client.flowInstances.find({
	            flowId: flow.id,
	            enabled: true,
	        });
	        const accessors = instancesPage.items.map((instance) => new FlowInstanceAccessor(this.client, instance.id));
	        return await Promise.all(accessors.map((accessor) => accessor.run(params)));
	    }
	    async subscribe(options) {
	        const flow = await this.get();
	        const channelKey = `${flows.FLOW_CHANNEL_PREFIX}${flow.id}`;
	        await this.client.subscribeToChannel(channelKey, options);
	    }
	    async unsubscribe() {
	        const flow = await this.get();
	        const channelKey = `${flows.FLOW_INSTANCE_CHANNEL_PREFIX}${flow.id}`;
	        await this.client.unsubscribeFromChannel(channelKey);
	    }
	}
	exports.FlowAccessor = FlowAccessor;
	class FlowInstancesAccessor extends accessors$b.ElementInstanceListAccessor {
	    constructor(client) {
	        super(client, 'flow-instances');
	    }
	}
	exports.FlowInstancesAccessor = FlowInstancesAccessor;
	class FlowInstanceAccessor extends accessors$b.ElementInstanceAccessor {
	    constructor(client, selector) {
	        super({
	            client,
	            selector,
	            instancePath: 'flow-instance',
	        });
	        this.client = client;
	        this.selector = selector;
	    }
	    async enable() {
	        return this.patch({ enabled: true });
	    }
	    async disable() {
	        return this.patch({ enabled: false });
	    }
	    async updateToLatestFlow() {
	        const id = await this.getId();
	        return this.client.post(`/flow-instances/${id}/update-to-latest-flow`);
	    }
	    async setup() {
	        const id = await this.getId();
	        return this.client.post(`/flow-instances/${id}/setup`);
	    }
	    async reset() {
	        const id = await this.getId();
	        return this.client.post(`/flow-instances/${id}/reset`);
	    }
	    async openConfiguration(options = {}) {
	        (0, iframe.showIframeLoader)();
	        const id = await this.getId();
	        const queryParams = {
	            nodeKey: options.nodeKey,
	        };
	        const uri = this.client.getEmbedUri(`/flow-instances/${id}/configuration?${query_string_1.default.stringify(queryParams)}`);
	        return (0, iframe.openIframe)(uri, {
	            onClose: options.onClose,
	        });
	    }
	    async run(options = {}) {
	        function onUpdate(flowRun) {
	            options.onUpdate && options.onUpdate(flowRun);
	        }
	        const id = await this.getId();
	        const flowRun = await this.client.flowRuns.create({
	            flowInstanceId: id,
	            nodeKey: options.nodeKey,
	            input: options.input,
	        });
	        onUpdate(flowRun);
	        const pusher = await this.client.getPusherInstance();
	        const pusherChannelName = `${flowRuns.FLOW_RUN_CHANNEL_PREFIX}${flowRun.id}`;
	        const pusherEventNameFlowRun = 'flow-run-update';
	        let pusherChannel;
	        let checkFlowRunInterval;
	        function cleanup() {
	            checkFlowRunInterval && clearInterval(checkFlowRunInterval);
	            pusherChannel && pusherChannel.unbind(pusherEventNameFlowRun);
	            pusher && pusher.unsubscribe(pusherChannelName);
	        }
	        return new Promise((resolve, reject) => {
	            const handleFlowRunUpdate = async (flowRun) => {
	                var _a, _b;
	                onUpdate(flowRun);
	                if (flowRun.state === flowRuns.FlowRunState.COMPLETED) {
	                    cleanup();
	                    resolve(flowRun);
	                }
	                else if (flowRun.state === flowRuns.FlowRunState.FAILED) {
	                    cleanup();
	                    reject(new Error(`Flow run ${flowRun.id} failed: ${(_b = (_a = flowRun.errors) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.message}`));
	                }
	            };
	            const fetchFlowRun = async () => {
	                handleFlowRunUpdate(await this.client.flowRun(flowRun.id).get());
	            };
	            let pollingFlowRun = false;
	            let errors = 0;
	            checkFlowRunInterval = setInterval(async () => {
	                if (!pollingFlowRun) {
	                    pollingFlowRun = true;
	                    try {
	                        await fetchFlowRun();
	                        errors = 0;
	                    }
	                    finally {
	                        errors += 1;
	                        if (errors > MAX_POLLING_ERRORS) {
	                            cleanup();
	                            reject(new Error(`Got ${errors} errors while polling flow run ${flowRun.id} state - aborting`));
	                        }
	                        pollingFlowRun = false;
	                    }
	                }
	            }, 1000);
	            if (pusher) {
	                pusherChannel = pusher.subscribe(pusherChannelName);
	                pusherChannel.bind(pusherEventNameFlowRun, fetchFlowRun);
	            }
	        });
	    }
	    async subscribe(options) {
	        const id = await this.getId();
	        const channelKey = `${flows.FLOW_INSTANCE_CHANNEL_PREFIX}${id}`;
	        await this.client.subscribeToChannel(channelKey, options);
	    }
	    async unsubscribe() {
	        const id = await this.getId();
	        const channelKey = `${flows.FLOW_INSTANCE_CHANNEL_PREFIX}${id}`;
	        await this.client.unsubscribeFromChannel(channelKey);
	    }
	}
	exports.FlowInstanceAccessor = FlowInstanceAccessor;

	});

	unwrapExports(accessors$9);
	accessors$9.FlowInstanceAccessor;
	accessors$9.FlowInstancesAccessor;
	accessors$9.FlowAccessor;
	accessors$9.FlowsAccessor;

	var errors = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.buildUserFriendlyErrorMessage = exports.extractIntegrationAppErrorData = exports.getErrorFromData = exports.AccessDeniedError = exports.NotAuthenticatedError = exports.NotFoundError = exports.ConnectionError = exports.FlowRunError = exports.FlowConfigurationError = exports.BadRequestError = exports.InternalError = exports.IntegrationAppError = exports.ErrorData = exports.isIntegrationAppError = exports.ConnectionErrorKey = exports.BadRequestErrorKey = exports.ErrorType = void 0;
	var ErrorType;
	(function (ErrorType) {
	    ErrorType["BAD_REQUEST"] = "Bad Request";
	    ErrorType["CONNECTION"] = "Connection";
	    ErrorType["FLOW_CONFIGURATION"] = "Flow Configuration";
	    ErrorType["FLOW_RUN"] = "Flow Run";
	    ErrorType["INTERNAL"] = "Internal";
	})(ErrorType = exports.ErrorType || (exports.ErrorType = {}));
	var BadRequestErrorKey;
	(function (BadRequestErrorKey) {
	    BadRequestErrorKey["NOT_FOUND"] = "not_found";
	    BadRequestErrorKey["NOT_AUTHENTICATED"] = "not_authenticated";
	    BadRequestErrorKey["ACCESS_DENIED"] = "access_denied";
	    BadRequestErrorKey["ALREADY_EXISTS"] = "already_exists";
	})(BadRequestErrorKey = exports.BadRequestErrorKey || (exports.BadRequestErrorKey = {}));
	(function (ConnectionErrorKey) {
	    ConnectionErrorKey["CONNECTION_IS_DEFUNCT"] = "connection_is_defunct";
	    ConnectionErrorKey["ACCESS_TOKEN_EXPIRED"] = "access_token_expired";
	})(exports.ConnectionErrorKey || (exports.ConnectionErrorKey = {}));
	function isIntegrationAppError(error) {
	    return error && error.isIntegrationAppError;
	}
	exports.isIntegrationAppError = isIntegrationAppError;
	class ErrorData {
	    constructor(arg) {
	        if (arg instanceof Error) {
	            this.message = arg.message;
	            this.stack = arg.stack;
	            this.type = ErrorType.INTERNAL;
	        }
	        else if (typeof arg === 'string') {
	            this.message = arg;
	            this.type = ErrorType.INTERNAL;
	        }
	        else if (typeof arg === 'object' && arg !== null) {
	            Object.assign(this, arg);
	        }
	        else {
	            throw new Error('Invalid argument when creating BaseErrorData: ' + JSON.stringify(arg));
	        }
	    }
	}
	exports.ErrorData = ErrorData;
	class IntegrationAppError extends Error {
	    constructor(arg) {
	        const errorData = new ErrorData(arg);
	        super(errorData.message);
	        this.isIntegrationAppError = true;
	        this.data = errorData;
	        if (!this.data.type) {
	            this.data.type = ErrorType.INTERNAL;
	        }
	        if (typeof window !== 'undefined') {
	            this.message = buildUserFriendlyErrorMessage('Integration.app SDK Error', this.data);
	        }
	    }
	}
	exports.IntegrationAppError = IntegrationAppError;
	class InternalError extends IntegrationAppError {
	    constructor(arg) {
	        super(arg);
	        this.data.type = ErrorType.INTERNAL;
	    }
	}
	exports.InternalError = InternalError;
	class BadRequestError extends IntegrationAppError {
	    constructor(arg) {
	        super(arg);
	        this.data.type = ErrorType.BAD_REQUEST;
	    }
	}
	exports.BadRequestError = BadRequestError;
	class FlowConfigurationError extends BadRequestError {
	    constructor(arg) {
	        super(arg);
	        this.data.type = ErrorType.FLOW_CONFIGURATION;
	    }
	}
	exports.FlowConfigurationError = FlowConfigurationError;
	class FlowRunError extends IntegrationAppError {
	    constructor(arg) {
	        super(arg);
	        this.data.type = ErrorType.FLOW_RUN;
	    }
	}
	exports.FlowRunError = FlowRunError;
	class ConnectionError extends IntegrationAppError {
	    constructor(arg) {
	        super(arg);
	        this.data.type = ErrorType.CONNECTION;
	    }
	}
	exports.ConnectionError = ConnectionError;
	class NotFoundError extends BadRequestError {
	    constructor(arg) {
	        super(arg);
	        this.data.key = BadRequestErrorKey.NOT_FOUND;
	    }
	}
	exports.NotFoundError = NotFoundError;
	class NotAuthenticatedError extends BadRequestError {
	    constructor(arg) {
	        super(arg);
	        this.data.key = BadRequestErrorKey.NOT_AUTHENTICATED;
	    }
	}
	exports.NotAuthenticatedError = NotAuthenticatedError;
	class AccessDeniedError extends BadRequestError {
	    constructor(arg) {
	        super(arg);
	        this.data.key = BadRequestErrorKey.ACCESS_DENIED;
	    }
	}
	exports.AccessDeniedError = AccessDeniedError;
	function getErrorFromData(data) {
	    if (typeof data === 'object' &&
	        data !== null &&
	        Object.values(ErrorType).includes(data.type)) {
	        return new IntegrationAppError(data);
	    }
	    return null;
	}
	exports.getErrorFromData = getErrorFromData;
	function extractIntegrationAppErrorData(error) {
	    const data = error.isIntegrationAppError
	        ? error.data
	        : new ErrorData({
	            message: error.message,
	            type: ErrorType.INTERNAL,
	        });
	    if (!data.message) {
	        data.message = error.message;
	    }
	    if (!data.stack) {
	        data.stack = error.stack;
	    }
	    return data;
	}
	exports.extractIntegrationAppErrorData = extractIntegrationAppErrorData;
	function buildUserFriendlyErrorMessage(prefix, { type, message, docsLink }) {
	    return `${prefix}. \n Type: ${type} \n Message: "${message}" \n Docs: ${docsLink}`;
	}
	exports.buildUserFriendlyErrorMessage = buildUserFriendlyErrorMessage;

	});

	unwrapExports(errors);
	errors.buildUserFriendlyErrorMessage;
	errors.extractIntegrationAppErrorData;
	errors.getErrorFromData;
	errors.AccessDeniedError;
	errors.NotAuthenticatedError;
	errors.NotFoundError;
	errors.ConnectionError;
	errors.FlowRunError;
	errors.FlowConfigurationError;
	errors.BadRequestError;
	errors.InternalError;
	errors.IntegrationAppError;
	errors.ErrorData;
	errors.isIntegrationAppError;
	errors.ConnectionErrorKey;
	errors.BadRequestErrorKey;
	errors.ErrorType;

	var jwt = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isJWT = void 0;
	function isJWT(token) {
	    if (typeof token !== 'string')
	        return false;
	    const splittedToken = token.split('.');
	    if (splittedToken.length !== 3)
	        return false;
	    try {
	        JSON.parse(decodeBase64(splittedToken[0]));
	    }
	    catch (e) {
	        return false;
	    }
	    return true;
	}
	exports.isJWT = isJWT;
	function decodeBase64(s) {
	    const e = {}, L = s.length, w = String.fromCharCode;
	    let i, b = 0, c, x, l = 0, a, r = '';
	    const A = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	    for (i = 0; i < 64; i++) {
	        e[A.charAt(i)] = i;
	    }
	    for (x = 0; x < L; x++) {
	        c = e[s.charAt(x)];
	        b = (b << 6) + c;
	        l += 6;
	        while (l >= 8) {
	            ((a = (b >>> (l -= 8)) & 0xff) || x < L - 2) && (r += w(a));
	        }
	    }
	    return r;
	}

	});

	unwrapExports(jwt);
	jwt.isJWT;

	var accessors$8 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DataLinkTableInstanceAccessor = exports.DataLinkTableInstancesAccessor = exports.DataLinkTableAccessor = exports.DataLinkTablesAccessor = void 0;

	const query_string_1 = tslib_es6.__importDefault(queryString);

	class DataLinkTablesAccessor extends accessors$b.ElementListAccessor {
	    constructor(client) {
	        super(client, 'data-link-tables');
	    }
	}
	exports.DataLinkTablesAccessor = DataLinkTablesAccessor;
	class DataLinkTableAccessor extends accessors$b.ElementAccessor {
	    constructor(client, idOrKey) {
	        super({
	            client,
	            path: 'data-link-tables',
	            idOrKey,
	        });
	    }
	}
	exports.DataLinkTableAccessor = DataLinkTableAccessor;
	class DataLinkTableInstancesAccessor extends accessors$b.ElementInstanceListAccessor {
	    constructor(client) {
	        super(client, 'data-link-table-instances');
	    }
	}
	exports.DataLinkTableInstancesAccessor = DataLinkTableInstancesAccessor;
	class DataLinkTableInstanceAccessor extends accessors$b.ElementInstanceAccessor {
	    constructor(client, selector) {
	        super({
	            client,
	            instancePath: 'data-link-table-instance',
	            selector,
	        });
	        this.client = client;
	    }
	    async findLinks(query) {
	        const id = await this.getId();
	        return this.client.get('/data-links?' +
	            query_string_1.default.stringify({
	                ...query,
	                dataLinkTableInstanceId: id,
	            }));
	    }
	    async addLink(selector) {
	        const id = await this.getId();
	        return this.client.post('/data-links?' +
	            query_string_1.default.stringify({
	                ...selector,
	                dataLinkTableInstanceId: id,
	            }));
	    }
	    async removeLink(selector) {
	        const id = await this.getId();
	        return this.client.delete('/data-links?' +
	            query_string_1.default.stringify({
	                ...selector,
	                dataLinkTableInstanceId: id,
	            }));
	    }
	}
	exports.DataLinkTableInstanceAccessor = DataLinkTableInstanceAccessor;

	});

	unwrapExports(accessors$8);
	accessors$8.DataLinkTableInstanceAccessor;
	accessors$8.DataLinkTableInstancesAccessor;
	accessors$8.DataLinkTableAccessor;
	accessors$8.DataLinkTablesAccessor;

	var integrations = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.FindIntegrationsResponse = exports.FindIntegrationsQuery = exports.ConnectionMode = void 0;
	(function (ConnectionMode) {
	    ConnectionMode["POPUP"] = "popup";
	    ConnectionMode["IFRAME"] = "iframe";
	})(exports.ConnectionMode || (exports.ConnectionMode = {}));
	class FindIntegrationsQuery extends entityRepository.PaginationQuery {
	}
	exports.FindIntegrationsQuery = FindIntegrationsQuery;
	class FindIntegrationsResponse extends entityRepository.PaginationResponse {
	}
	exports.FindIntegrationsResponse = FindIntegrationsResponse;

	});

	unwrapExports(integrations);
	integrations.FindIntegrationsResponse;
	integrations.FindIntegrationsQuery;
	integrations.ConnectionMode;

	var accessors$7 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.IntegrationAccessor = exports.IntegrationsAccessor = void 0;




	const url_join_1 = tslib_es6.__importDefault(urlJoin);
	class IntegrationsAccessor {
	    constructor(client) {
	        this.client = client;
	    }
	    async find(query) {
	        return this.client.get('/integrations', query);
	    }
	}
	exports.IntegrationsAccessor = IntegrationsAccessor;
	class IntegrationAccessor extends accessors$b.ElementAccessor {
	    constructor(client, idOrKey) {
	        super({
	            client,
	            path: 'integrations',
	            idOrKey,
	        });
	        this.client = client;
	        this.idOrKey = idOrKey;
	    }
	    async getConnectorSpec() {
	        return this.client.get(`/integrations/${this.idOrKey}/connector-spec`);
	    }
	    async createConnection({ parameters }) {
	        const spec = await this.getConnectorSpec();
	        let iframeElement;
	        if (spec.connectionMode === integrations.ConnectionMode.IFRAME) {
	            iframeElement = createIframeElement();
	        }
	        return new Promise((resolve, reject) => {
	            const connectionUrl = (0, url_join_1.default)(this.client.apiUri, `oauth/new/${this.idOrKey}`, `?token=${this.client.token}&connectionParameters=${JSON.stringify(parameters)}`);
	            const urlObj = new URL(connectionUrl);
	            const requestId = (Math.random() + 1).toString(36).substring(0, 12);
	            const listenerFunc = async (event) => {
	                const message = event.data || {};
	                if (message.source == 'integration.app' &&
	                    message.requestId == requestId) {
	                    cleanup();
	                    if (message.type == 'newConnectionCreated') {
	                        resolve(message.connection);
	                    }
	                    else if (message.type == 'newConnectionCancel') {
	                        resolve(null);
	                    }
	                    else if (message.type == 'newConnectionFailure') {
	                        reject(new Error(message.error));
	                    }
	                }
	            };
	            let cancelCheckInterval;
	            function cleanup() {
	                clearInterval(cancelCheckInterval);
	                window.removeEventListener('message', listenerFunc);
	            }
	            try {
	                window.addEventListener('message', listenerFunc);
	                urlObj.searchParams.append('requestId', requestId);
	                if (iframeElement) {
	                    urlObj.searchParams.append('iframe', '1');
	                    iframeElement.src = urlObj.toString();
	                }
	                else {
	                    const height = Math.round(screen.height * 0.6);
	                    const width = Math.round(screen.width * 0.7);
	                    const top = Math.round(screen.height * 0.2);
	                    const left = Math.round(screen.height * 0.15);
	                    const popup = window.open(urlObj.toString(), null, `popup,width=${width},height=${height},left=${left},top=${top}`);
	                    setTimeout(() => {
	                        if (!popup) {
	                            cleanup();
	                            reject({
	                                message: 'Popup has been blocked',
	                            });
	                        }
	                    }, 1000);
	                    cancelCheckInterval = setInterval(() => {
	                        if (popup === null || popup === void 0 ? void 0 : popup.closed) {
	                            cleanup();
	                            resolve(null);
	                        }
	                    }, 1000);
	                }
	            }
	            catch (e) {
	                reject(e);
	            }
	        });
	    }
	    async openNewConnection() {
	        (0, iframe.showIframeLoader)();
	        const uri = this.client.getEmbedUri(`/integrations/${this.idOrKey}/connection/connect`);
	        return new Promise((resolve) => {
	            (0, iframe.openIframe)(uri, {
	                onClose: () => resolve(null),
	                onSuccess: (connection) => resolve(connection),
	            });
	        });
	    }
	    async connect() {
	        return this.openNewConnection();
	    }
	}
	exports.IntegrationAccessor = IntegrationAccessor;
	function createIframeElement() {
	    const iframeElement = document.createElement('iframe');
	    iframeElement.style.position = 'absolute';
	    iframeElement.style.top = '-100';
	    iframeElement.style.left = '-100';
	    iframeElement.style.width = '1';
	    iframeElement.style.height = '1';
	    iframeElement.style.border = 'none';
	    iframeElement.style.backgroundColor = 'transparent';
	    document.body.appendChild(iframeElement);
	    return iframeElement;
	}

	});

	unwrapExports(accessors$7);
	accessors$7.IntegrationAccessor;
	accessors$7.IntegrationsAccessor;

	var accessors$6 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.FieldMappingInstanceAccessor = exports.FieldMappingInstancesAccessor = exports.FieldMappingAccessor = exports.FieldMappingsAccessor = void 0;


	class FieldMappingsAccessor extends accessors$b.ElementListAccessor {
	    constructor(client) {
	        super(client, 'field-mappings');
	    }
	}
	exports.FieldMappingsAccessor = FieldMappingsAccessor;
	class FieldMappingAccessor extends accessors$b.ElementAccessor {
	    constructor(client, idOrKey) {
	        super({
	            client,
	            path: 'field-mappings',
	            idOrKey,
	        });
	    }
	}
	exports.FieldMappingAccessor = FieldMappingAccessor;
	class FieldMappingInstancesAccessor extends accessors$b.ElementInstanceListAccessor {
	    constructor(client) {
	        super(client, 'field-mapping-instances');
	    }
	}
	exports.FieldMappingInstancesAccessor = FieldMappingInstancesAccessor;
	class FieldMappingInstanceAccessor extends accessors$b.ElementInstanceAccessor {
	    constructor(client, selector) {
	        super({
	            client,
	            instancePath: 'field-mapping-instance',
	            selector,
	        });
	        this.client = client;
	    }
	    async setup() {
	        const id = await this.getId();
	        return this.client.post(`/field-mapping-instances/${id}/setup`);
	    }
	    async reset() {
	        const id = await this.getId();
	        return this.client.post(`/field-mapping-instances/${id}/reset`);
	    }
	    async openConfiguration(options) {
	        (0, iframe.showIframeLoader)();
	        const id = await this.getId();
	        const uri = this.client.getEmbedUri(`/field-mapping-instances/${id}/configuration`);
	        return (0, iframe.openIframe)(uri, {
	            onClose: options === null || options === void 0 ? void 0 : options.onClose,
	        });
	    }
	}
	exports.FieldMappingInstanceAccessor = FieldMappingInstanceAccessor;

	});

	unwrapExports(accessors$6);
	accessors$6.FieldMappingInstanceAccessor;
	accessors$6.FieldMappingInstancesAccessor;
	accessors$6.FieldMappingAccessor;
	accessors$6.FieldMappingsAccessor;

	var accessors$5 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DataSourceInstanceAccessor = exports.DataSourceInstancesAccessor = void 0;


	class DataSourceInstancesAccessor extends accessors$b.ElementInstanceListAccessor {
	    constructor(client) {
	        super(client, 'data-source-instances');
	    }
	}
	exports.DataSourceInstancesAccessor = DataSourceInstancesAccessor;
	class DataSourceInstanceAccessor extends accessors$b.ElementInstanceAccessor {
	    constructor(client, selector) {
	        super({
	            client,
	            instancePath: 'data-source-instance',
	            selector,
	        });
	        this.client = client;
	    }
	    async setup() {
	        const id = await this.getId();
	        await this.client.post(`/data-source-instances/${id}/setup`);
	    }
	    async openConfiguration(options) {
	        (0, iframe.showIframeLoader)();
	        const id = await this.getId();
	        const uri = this.client.getEmbedUri(`/data-source-instances/${id}/configuration`);
	        return (0, iframe.openIframe)(uri, {
	            onClose: options === null || options === void 0 ? void 0 : options.onClose,
	        });
	    }
	    async getCollection() {
	        const id = await this.getId();
	        return this.client.get(`/data-source-instances/${id}/collection`);
	    }
	    async getLocations(request) {
	        const id = await this.getId();
	        return this.client.get(`/data-source-instances/${id}/locations`, request);
	    }
	    async findRecords(request = {}) {
	        const baseUri = await this.getRecordsBaseUri();
	        return this.client.get(baseUri, request);
	    }
	    async createRecord(request) {
	        const baseUri = await this.getRecordsBaseUri();
	        return this.client.post(baseUri, request);
	    }
	    async updateRecord(request) {
	        const baseUri = await this.getRecordsBaseUri();
	        return this.client.patch(`${baseUri}/${request.id}`, request);
	    }
	    async deleteRecord(request) {
	        const baseUri = await this.getRecordsBaseUri();
	        return this.client.patch(`${baseUri}/${request.id}`, request);
	    }
	    async getRecordsBaseUri() {
	        const id = await this.getId();
	        return `/data-source-instances/${id}/records`;
	    }
	}
	exports.DataSourceInstanceAccessor = DataSourceInstanceAccessor;

	});

	unwrapExports(accessors$5);
	accessors$5.DataSourceInstanceAccessor;
	accessors$5.DataSourceInstancesAccessor;

	var accessors$4 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AppEventSubscriptionAccessor = exports.AppEventSubscriptionsAccessor = exports.AppEventTypeAccessor = exports.AppEventTypesAccessor = void 0;

	class AppEventTypesAccessor extends accessors$b.ElementListAccessor {
	    constructor(client) {
	        super(client, 'app-event-types');
	    }
	}
	exports.AppEventTypesAccessor = AppEventTypesAccessor;
	class AppEventTypeAccessor extends accessors$b.ElementAccessor {
	    constructor(client, idOrKey) {
	        super({
	            client,
	            path: 'app-event-types',
	            idOrKey,
	        });
	    }
	}
	exports.AppEventTypeAccessor = AppEventTypeAccessor;
	class AppEventSubscriptionsAccessor extends accessors$b.ElementInstanceListAccessor {
	    constructor(client) {
	        super(client, 'app-event-subscriptions');
	    }
	}
	exports.AppEventSubscriptionsAccessor = AppEventSubscriptionsAccessor;
	class AppEventSubscriptionAccessor extends accessors$b.ElementInstanceAccessor {
	    constructor(client, selector) {
	        super({
	            client,
	            instancePath: 'app-event-subscription',
	            selector,
	        });
	    }
	}
	exports.AppEventSubscriptionAccessor = AppEventSubscriptionAccessor;

	});

	unwrapExports(accessors$4);
	accessors$4.AppEventSubscriptionAccessor;
	accessors$4.AppEventSubscriptionsAccessor;
	accessors$4.AppEventTypeAccessor;
	accessors$4.AppEventTypesAccessor;

	var accessors$3 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AppDataCollectionInstanceAccessor = exports.AppDataCollectionInstancesAccessor = exports.AppDataCollectionAccessor = exports.AppDataCollectionsAccessor = void 0;

	class AppDataCollectionsAccessor extends accessors$b.ElementListAccessor {
	    constructor(client) {
	        super(client, 'app-data-collections');
	    }
	}
	exports.AppDataCollectionsAccessor = AppDataCollectionsAccessor;
	class AppDataCollectionAccessor extends accessors$b.ElementAccessor {
	    constructor(client, idOrKey) {
	        super({
	            client,
	            path: 'app-data-collections',
	            idOrKey,
	        });
	    }
	}
	exports.AppDataCollectionAccessor = AppDataCollectionAccessor;
	class AppDataCollectionInstancesAccessor extends accessors$b.ElementInstanceListAccessor {
	    constructor(client) {
	        super(client, 'app-data-collection-instances');
	    }
	}
	exports.AppDataCollectionInstancesAccessor = AppDataCollectionInstancesAccessor;
	class AppDataCollectionInstanceAccessor extends accessors$b.ElementInstanceAccessor {
	    constructor(client, selector) {
	        super({
	            client,
	            instancePath: 'app-data-collection-instance',
	            selector,
	        });
	    }
	}
	exports.AppDataCollectionInstanceAccessor = AppDataCollectionInstanceAccessor;

	});

	unwrapExports(accessors$3);
	accessors$3.AppDataCollectionInstanceAccessor;
	accessors$3.AppDataCollectionInstancesAccessor;
	accessors$3.AppDataCollectionAccessor;
	accessors$3.AppDataCollectionsAccessor;

	var accessors$2 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AppDataSchemaInstanceAccessor = exports.AppDataSchemaInstancesAccessor = exports.AppDataSchemaAccessor = exports.AppDataSchemasAccessor = void 0;

	class AppDataSchemasAccessor extends accessors$b.ElementListAccessor {
	    constructor(client) {
	        super(client, 'app-data-schemas');
	    }
	}
	exports.AppDataSchemasAccessor = AppDataSchemasAccessor;
	class AppDataSchemaAccessor extends accessors$b.ElementAccessor {
	    constructor(client, idOrKey) {
	        super({
	            client,
	            path: 'app-data-schemas',
	            idOrKey,
	        });
	    }
	}
	exports.AppDataSchemaAccessor = AppDataSchemaAccessor;
	class AppDataSchemaInstancesAccessor extends accessors$b.ElementInstanceListAccessor {
	    constructor(client) {
	        super(client, 'app-data-schema-instances');
	    }
	}
	exports.AppDataSchemaInstancesAccessor = AppDataSchemaInstancesAccessor;
	class AppDataSchemaInstanceAccessor extends accessors$b.ElementInstanceAccessor {
	    constructor(client, selector) {
	        super({
	            client,
	            instancePath: 'app-data-schema-instance',
	            selector,
	        });
	    }
	}
	exports.AppDataSchemaInstanceAccessor = AppDataSchemaInstanceAccessor;

	});

	unwrapExports(accessors$2);
	accessors$2.AppDataSchemaInstanceAccessor;
	accessors$2.AppDataSchemaInstancesAccessor;
	accessors$2.AppDataSchemaAccessor;
	accessors$2.AppDataSchemasAccessor;

	var accessors$1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SelfAccessor = void 0;
	class SelfAccessor {
	    constructor(client) {
	        this.client = client;
	    }
	    async get() {
	        return this.client.get('self');
	    }
	}
	exports.SelfAccessor = SelfAccessor;

	});

	unwrapExports(accessors$1);
	accessors$1.SelfAccessor;

	var accessors = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DataLocationAccessor = void 0;

	const query_string_1 = tslib_es6.__importDefault(queryString);
	class DataLocationAccessor {
	    constructor(client, selector) {
	        this.client = client;
	        this.selector = selector;
	    }
	    async get() {
	        return this.client.get(this.getPath());
	    }
	    async list() {
	        return this.client.get(this.getPath('list'));
	    }
	    getPath(subpath = '') {
	        return `/data-location${subpath ? `/${subpath}` : ''}?${query_string_1.default.stringify(this.selector)}`;
	    }
	}
	exports.DataLocationAccessor = DataLocationAccessor;

	});

	unwrapExports(accessors);
	accessors.DataLocationAccessor;

	var client = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.IntegrationAppClient = void 0;

	const pusher_js_1 = tslib_es6.__importDefault(pusher);
	const axios_1 = tslib_es6.__importDefault(axios);














	const DEFAULT_API_URI = 'https://engine-api.integration.app';
	const DEFAULT_UI_URI = 'https://ui.integration.app';
	class IntegrationAppClient {
	    constructor(options) {
	        this.pusherChannels = {};
	        this.init(options);
	    }
	    async get(uri, queryParams) {
	        if (queryParams) {
	            uri += `?${new URLSearchParams(queryParams).toString()}`;
	        }
	        return this.makeApiRequest('GET', { url: uri });
	    }
	    async post(uri, data) {
	        return this.makeApiRequest('POST', { url: uri, data });
	    }
	    async put(uri, data) {
	        return this.makeApiRequest('PUT', { url: uri, data });
	    }
	    async patch(uri, data) {
	        return this.makeApiRequest('PATCH', { url: uri, data });
	    }
	    async delete(uri) {
	        return this.makeApiRequest('DELETE', { url: uri });
	    }
	    get self() {
	        return new accessors$1.SelfAccessor(this);
	    }
	    get flows() {
	        return new accessors$9.FlowsAccessor(this);
	    }
	    flow(keyOrId) {
	        return new accessors$9.FlowAccessor(this, keyOrId);
	    }
	    get flowInstances() {
	        return new accessors$9.FlowInstancesAccessor(this);
	    }
	    flowInstance(selector) {
	        return new accessors$9.FlowInstanceAccessor(this, selector);
	    }
	    get dataSources() {
	        return new accessors$5.DataSourceInstancesAccessor(this);
	    }
	    dataSource(selector) {
	        return new accessors$5.DataSourceInstanceAccessor(this, selector);
	    }
	    get dataSourceInstances() {
	        return new accessors$5.DataSourceInstancesAccessor(this);
	    }
	    dataSourceInstance(selector) {
	        return new accessors$5.DataSourceInstanceAccessor(this, selector);
	    }
	    get fieldMappings() {
	        return new accessors$6.FieldMappingsAccessor(this);
	    }
	    fieldMapping(idOrKey) {
	        return new accessors$6.FieldMappingAccessor(this, idOrKey);
	    }
	    get fieldMappingInstances() {
	        return new accessors$6.FieldMappingInstancesAccessor(this);
	    }
	    fieldMappingInstance(selector) {
	        return new accessors$6.FieldMappingInstanceAccessor(this, selector);
	    }
	    get dataLinkTables() {
	        return new accessors$8.DataLinkTablesAccessor(this);
	    }
	    dataLinkTable(idOrKey) {
	        return new accessors$8.DataLinkTableAccessor(this, idOrKey);
	    }
	    get dataLinkTableInstances() {
	        return new accessors$8.DataLinkTableInstancesAccessor(this);
	    }
	    dataLinkTableInstance(selector) {
	        return new accessors$8.DataLinkTableInstanceAccessor(this, selector);
	    }
	    get integrations() {
	        return new accessors$7.IntegrationsAccessor(this);
	    }
	    integration(identifier) {
	        return new accessors$7.IntegrationAccessor(this, identifier);
	    }
	    get connections() {
	        return new accessors$a.ConnectionsAccessor(this);
	    }
	    connection(id) {
	        return new accessors$a.ConnectionAccessor(this, id);
	    }
	    dataLocation(selector) {
	        return new accessors.DataLocationAccessor(this, selector);
	    }
	    get appEventTypes() {
	        return new accessors$4.AppEventTypesAccessor(this);
	    }
	    appEventType(idOrKey) {
	        return new accessors$4.AppEventTypeAccessor(this, idOrKey);
	    }
	    get appEventSubscriptions() {
	        return new accessors$4.AppEventSubscriptionsAccessor(this);
	    }
	    appEventSubscription(selector) {
	        return new accessors$4.AppEventSubscriptionAccessor(this, selector);
	    }
	    get flowRuns() {
	        return new flowRuns.FlowRunsAccessor(this);
	    }
	    flowRun(id) {
	        return new flowRuns.FlowRunAccessor(this, id);
	    }
	    get appDataCollections() {
	        return new accessors$3.AppDataCollectionsAccessor(this);
	    }
	    appDataCollection(idOrKey) {
	        return new accessors$3.AppDataCollectionAccessor(this, idOrKey);
	    }
	    get appDataCollectionInstances() {
	        return new accessors$3.AppDataCollectionInstancesAccessor(this);
	    }
	    appDataCollectionInstance(selector) {
	        return new accessors$3.AppDataCollectionInstanceAccessor(this, selector);
	    }
	    get appDataSchemas() {
	        return new accessors$2.AppDataSchemasAccessor(this);
	    }
	    appDataSchema(idOrKey) {
	        return new accessors$2.AppDataSchemaAccessor(this, idOrKey);
	    }
	    get appDataSchemaInstances() {
	        return new accessors$2.AppDataSchemaInstancesAccessor(this);
	    }
	    appDataSchemaInstance(selector) {
	        return new accessors$3.AppDataCollectionInstanceAccessor(this, selector);
	    }
	    init(options) {
	        var _a;
	        const token = (_a = options.token) !== null && _a !== void 0 ? _a : options.accessToken;
	        if (token !== undefined && !(0, jwt.isJWT)(token))
	            throw new Error('Access token should be a valid JWT token');
	        this.apiUri = options.apiUri || DEFAULT_API_URI;
	        this.uiUri = options.uiUri || DEFAULT_UI_URI;
	        this.token = token;
	    }
	    async subscribeToChannel(channelKey, options) {
	        if (!this.pusherChannels[channelKey]) {
	            const pusher = await this.getPusherInstance();
	            const newChannel = pusher.subscribe(channelKey);
	            this.pusherChannels[channelKey] = newChannel;
	        }
	        const channel = this.pusherChannels[channelKey];
	        if (channel.subscribed) {
	            options.onSubscribe && options.onSubscribe();
	        }
	        else {
	            channel.bind('pusher:subscription_succeeded', () => options.onSubscribe && options.onSubscribe());
	        }
	        if (options.onUpdate) {
	            channel.bind('updated', options.onUpdate);
	        }
	    }
	    async unsubscribeFromChannel(channelKey) {
	        if (this.pusherChannels[channelKey]) {
	            const pusher = await this.getPusherInstance();
	            pusher.unsubscribe(channelKey);
	            delete this.pusherChannels[channelKey];
	        }
	    }
	    getEmbedUri(page, params) {
	        const embedUrl = new URL(`${this.uiUri}/embed/${page}`);
	        if (this.token) {
	            embedUrl.searchParams.set('token', this.token);
	        }
	        if (params) {
	            for (const [key, value] of Object.entries(params)) {
	                embedUrl.searchParams.set(key, value);
	            }
	        }
	        return embedUrl.href;
	    }
	    async getPusherInstance() {
	        if (!this.pusher) {
	            const { key, cluster } = await this.get('pusher/config');
	            this.pusher = new pusher_js_1.default(key, {
	                cluster: cluster,
	                authEndpoint: this.apiUri + '/pusher/auth',
	                auth: { headers: { Authorization: `Bearer ${this.token}` } },
	            });
	        }
	        return this.pusher;
	    }
	    async connectionRequest(connectionId, uri, data) {
	        return this.post(`connections/${connectionId}/execute-request`, {
	            key: uri,
	            payload: data,
	        });
	    }
	    handleRequestError(err) {
	        var _a, _b;
	        if (axios_1.default.isAxiosError(err) && ((_b = (_a = err.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.type)) {
	            console.error((0, errors.buildUserFriendlyErrorMessage)('Integration.app API Request Error', err.response.data));
	            throw (0, errors.getErrorFromData)(err.response.data);
	        }
	        throw err;
	    }
	    async makeApiRequest(method, params = {}) {
	        params.method = method;
	        params.baseURL = this.apiUri;
	        params.headers = {
	            ...(params.headers || {}),
	            Authorization: `Bearer ${this.token}`,
	        };
	        let response;
	        try {
	            response = await axios_1.default.request(params);
	        }
	        catch (err) {
	            this.handleRequestError(err);
	        }
	        return response.data;
	    }
	}
	exports.IntegrationAppClient = IntegrationAppClient;

	});

	unwrapExports(client);
	client.IntegrationAppClient;

	var bundleIndex = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	module.exports = new client.IntegrationAppClient({});

	});

	var bundleIndex$1 = unwrapExports(bundleIndex);

	return bundleIndex$1;

})));
//# sourceMappingURL=bundle.js.map
