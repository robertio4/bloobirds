"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSchemaFromValue = exports.isEmpty = exports.processCopy = exports.processValue = exports.getFormula = exports.isFormula = exports.DataBuilderFormulaType = void 0;
const errors_1 = require("../../errors");
const json_schema_1 = require("../../json-schema");
const schema_builder_1 = require("../../json-schema/schema-builder");
const locators_1 = require("../locators");
const case_1 = require("./case");
const concat_1 = require("./concat");
const copy_1 = require("./copy");
const extractDate_1 = require("./extractDate");
const extractTime_1 = require("./extractTime");
const findAppRecordId_1 = require("./findAppRecordId");
const findExternalRecordId_1 = require("./findExternalRecordId");
const first_name_1 = require("./first-name");
const iterate_1 = require("./iterate");
const last_name_1 = require("./last-name");
const lookup_1 = require("./lookup");
const map_1 = require("./map");
const plain_1 = require("./plain");
const record_1 = require("./record");
const var_1 = require("./var");
const tpl_1 = require("./tpl");
var DataBuilderFormulaType;
(function (DataBuilderFormulaType) {
    DataBuilderFormulaType["VAR"] = "var";
    DataBuilderFormulaType["COPY"] = "copy";
    DataBuilderFormulaType["REF"] = "ref";
    DataBuilderFormulaType["TPL"] = "tpl";
    DataBuilderFormulaType["RECORD"] = "record";
    DataBuilderFormulaType["LOOKUP"] = "lookup";
    DataBuilderFormulaType["PLAIN"] = "plain";
    DataBuilderFormulaType["MAP"] = "map";
    DataBuilderFormulaType["CONCAT"] = "concat";
    DataBuilderFormulaType["FIRST_NAME"] = "firstName";
    DataBuilderFormulaType["LAST_NAME"] = "lastName";
    DataBuilderFormulaType["ITERATE"] = "iterate";
    DataBuilderFormulaType["CASE"] = "case";
    DataBuilderFormulaType["EXTRACT_DATE"] = "extractDate";
    DataBuilderFormulaType["EXTRACT_TIME"] = "extractTime";
    DataBuilderFormulaType["FIND_EXTERNAL_RECORD_ID"] = "findExternalRecordId";
    DataBuilderFormulaType["FIND_APP_RECORD_ID"] = "findAppRecordId";
})(DataBuilderFormulaType = exports.DataBuilderFormulaType || (exports.DataBuilderFormulaType = {}));
const FORMULAS = {
    [DataBuilderFormulaType.VAR]: var_1.DataBuilderFormulaVar,
    [DataBuilderFormulaType.REF]: var_1.DataBuilderFormulaVar,
    [DataBuilderFormulaType.RECORD]: record_1.DataBuilderFormulaRecord,
    [DataBuilderFormulaType.TPL]: tpl_1.DataBuilderFormulaTpl,
    [DataBuilderFormulaType.LOOKUP]: lookup_1.DataBuilderFormulaLookup,
    [DataBuilderFormulaType.PLAIN]: plain_1.DataBuilderFormulaPlain,
    [DataBuilderFormulaType.MAP]: map_1.DataBuilderFormulaMap,
    [DataBuilderFormulaType.CONCAT]: concat_1.DataBuilderFormulaConcat,
    [DataBuilderFormulaType.FIRST_NAME]: first_name_1.DataBuilderFormulaFirstName,
    [DataBuilderFormulaType.LAST_NAME]: last_name_1.DataBuilderFormulaLastName,
    [DataBuilderFormulaType.ITERATE]: iterate_1.DataBuilderFormulaIterate,
    [DataBuilderFormulaType.CASE]: case_1.DataBuilderFormulaCase,
    [DataBuilderFormulaType.EXTRACT_DATE]: extractDate_1.DataBuilderFormulaExtractDate,
    [DataBuilderFormulaType.EXTRACT_TIME]: extractTime_1.DataBuilderFormulaExtractTime,
    [DataBuilderFormulaType.FIND_EXTERNAL_RECORD_ID]: findExternalRecordId_1.DataBuilderFormulaFindExternalRecordId,
    [DataBuilderFormulaType.FIND_APP_RECORD_ID]: findAppRecordId_1.DataBuilderFormulaFindAppRecordId,
    [DataBuilderFormulaType.COPY]: copy_1.DataBuilderFormulaCopy,
};
function isFormula(value) {
    return !!getFormula(value);
}
exports.isFormula = isFormula;
function getFormula(value) {
    if (typeof value === 'object' && value !== null) {
        if (Object.keys(value).length === 1) {
            const key = Object.keys(value)[0];
            if (key.startsWith('$')) {
                const formulaType = key.slice(1);
                const formulaValue = value[key];
                if (formulaType in FORMULAS) {
                    return new FORMULAS[formulaType](formulaValue);
                }
            }
        }
    }
    return undefined;
}
exports.getFormula = getFormula;
function processValue(value, context) {
    if (isFormula(value)) {
        const formula = getFormula(value);
        return formula.getValue(context);
    }
    else {
        if (typeof value === 'object') {
            if (Array.isArray(value)) {
                const result = [];
                for (const valueItem of value) {
                    const processedVal = processValue(valueItem, context);
                    if (processedVal !== undefined) {
                        result.push(processedVal);
                    }
                }
                return result.length > 0 ? result : undefined;
            }
            else if (value === null) {
                return value;
            }
            else {
                const result = {};
                for (const [key, val] of Object.entries(value)) {
                    const processedVal = processValue(val, context);
                    if (processedVal !== undefined) {
                        result[key] = processedVal;
                    }
                }
                if (Object.keys(result).length > 0) {
                    return result;
                }
                else {
                    return undefined;
                }
            }
        }
        else {
            return value;
        }
    }
}
exports.processValue = processValue;
function processCopy(data) {
    const copyLocators = (0, locators_1.getFormulaLocators)(DataBuilderFormulaType.COPY, data);
    for (const locator of copyLocators) {
        const value = (0, locators_1.getValueAtLocator)(data, locator);
        const formula = getFormula(value);
        const valueToCopy = (0, locators_1.getValueAtLocator)(data, formula.locator);
        const valueHasCopy = (0, locators_1.getFormulaLocators)(DataBuilderFormulaType.COPY, valueToCopy).length > 0;
        if (valueHasCopy) {
            throw new errors_1.FlowConfigurationError(`${locator} is copying ${formula.locator}, which contains a copy formula`);
        }
        (0, locators_1.setValueAtLocator)(data, locator, valueToCopy);
    }
}
exports.processCopy = processCopy;
function isEmpty(value) {
    return typeof value == 'undefined';
}
exports.isEmpty = isEmpty;
function getSchemaFromValue(value, variablesSchema, ignoreFormulas = false) {
    if (isFormula(value) && !ignoreFormulas) {
        return getFormula(value).getSchema(variablesSchema);
    }
    else {
        const type = (0, json_schema_1.schemaTypeFromValue)(value);
        switch (type) {
            case 'object':
                const properties = {};
                for (const [propKey, propValue] of Object.entries(value)) {
                    properties[propKey] = getSchemaFromValue(propValue, variablesSchema, ignoreFormulas);
                }
                return {
                    type: 'object',
                    properties,
                };
            case 'array':
                const schemas = [];
                for (const item of value) {
                    schemas.push(getSchemaFromValue(item, variablesSchema, ignoreFormulas));
                }
                return {
                    type: 'array',
                    items: (0, schema_builder_1.mergeSchemas)(schemas),
                };
            default:
                return { type: type };
        }
    }
}
exports.getSchemaFromValue = getSchemaFromValue;
//# sourceMappingURL=index.js.map