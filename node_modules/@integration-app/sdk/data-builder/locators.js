"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFormulaLocators = exports.stepsToLocator = exports.locatorToString = exports.locatorToSteps = exports.walkSchema = exports.getFullTitleForLocator = exports.getLocatorsFromSchema = exports.getLocatorsFromData = exports.getIconUriForLocator = exports.getFullNameForLocator = exports.getNameComponentsForLocator = exports.getNameForLocator = exports.makeSchemaForLocator = exports.extractFieldLocator = exports.setSchemaAtLocator = exports.excludeFieldsFromValue = exports.pickFieldsFromValue = exports.setValueAtLocator = exports.getValueAtLocator = exports.findValueLocators = exports.getSchemaByLocator = exports.locatorToField = exports.InvalidLocatorError = exports.DataLocatorStepCurrentArrayItem = exports.DataLocatorStepArrayItem = exports.DataLocatorStepObjectProperty = exports.DataLocatorStep = exports.DataLocatorStepType = void 0;
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const js_convert_case_1 = require("js-convert-case");
const errors_1 = require("../errors");
const formulas_1 = require("./formulas");
var DataLocatorStepType;
(function (DataLocatorStepType) {
    DataLocatorStepType["OBJECT_PROPERTY"] = "object_property";
    DataLocatorStepType["ARRAY_ITEM"] = "array_item";
    DataLocatorStepType["CURRENT_ARRAY_ITEM"] = "current_array_item";
})(DataLocatorStepType = exports.DataLocatorStepType || (exports.DataLocatorStepType = {}));
class DataLocatorStep {
}
exports.DataLocatorStep = DataLocatorStep;
class DataLocatorStepObjectProperty extends DataLocatorStep {
    constructor(propertyName) {
        super();
        this.propertyName = propertyName;
        this.type = DataLocatorStepType.OBJECT_PROPERTY;
    }
}
exports.DataLocatorStepObjectProperty = DataLocatorStepObjectProperty;
class DataLocatorStepArrayItem extends DataLocatorStep {
    constructor(index) {
        super();
        this.index = index;
        this.type = DataLocatorStepType.ARRAY_ITEM;
    }
}
exports.DataLocatorStepArrayItem = DataLocatorStepArrayItem;
class DataLocatorStepCurrentArrayItem extends DataLocatorStep {
    constructor() {
        super();
        this.type = DataLocatorStepType.CURRENT_ARRAY_ITEM;
    }
}
exports.DataLocatorStepCurrentArrayItem = DataLocatorStepCurrentArrayItem;
class InvalidLocatorError extends Error {
}
exports.InvalidLocatorError = InvalidLocatorError;
function locatorToField(locator) {
    if (typeof locator !== 'string')
        return undefined;
    return locator.replace(/^\$\./, '');
}
exports.locatorToField = locatorToField;
function getSchemaByLocator(schema, locator) {
    if (schema) {
        try {
            const schemaSteps = walkSchema(schema, locator);
            if (schemaSteps) {
                if (schemaSteps.length > 0) {
                    return schemaSteps[schemaSteps.length - 1].schema;
                }
                else {
                    return schema;
                }
            }
            else {
                return null;
            }
        }
        catch (e) {
            if (e instanceof InvalidLocatorError) {
                return null;
            }
            else {
                throw e;
            }
        }
    }
    else {
        return null;
    }
}
exports.getSchemaByLocator = getSchemaByLocator;
function findValueLocators(data, value) {
    function doFindValueLocator(data, value, locatorSoFar) {
        if (JSON.stringify(data) === JSON.stringify(value)) {
            return [locatorSoFar];
        }
        else {
            if (Array.isArray(data)) {
                const result = [];
                for (let i = 0; i < data.length; ++i) {
                    result.push(...doFindValueLocator(data[i], value, `${locatorSoFar}[${i}]`));
                }
                return result;
            }
            else if (typeof data === 'object' && data) {
                const result = [];
                for (const key in data) {
                    result.push(...doFindValueLocator(data[key], value, `${locatorSoFar}.${key}`));
                }
                return result;
            }
            else {
                return [];
            }
        }
    }
    return doFindValueLocator(data, value, '$');
}
exports.findValueLocators = findValueLocators;
function getValueAtLocator(data, locator) {
    let curValue = data;
    const locatorSteps = locatorToSteps(locator);
    for (let i = 0; i < locatorSteps.length; ++i) {
        const locatorStep = locatorSteps[i];
        switch (locatorStep.type) {
            case DataLocatorStepType.OBJECT_PROPERTY:
                const propStep = locatorStep;
                if (typeof curValue == 'object' &&
                    curValue &&
                    curValue[propStep.propertyName]) {
                    curValue = curValue[propStep.propertyName];
                }
                else {
                    return undefined;
                }
                break;
            case DataLocatorStepType.ARRAY_ITEM:
                const itemStep = locatorStep;
                if (Array.isArray(curValue) && curValue[itemStep.index]) {
                    curValue = curValue[itemStep.index];
                }
                else {
                    return undefined;
                }
                break;
            case DataLocatorStepType.CURRENT_ARRAY_ITEM:
                if (Array.isArray(curValue)) {
                    curValue = curValue[0];
                }
                else {
                    return undefined;
                }
                break;
            default:
                throw new Error(`Unknown locator step type: ${locatorStep.type}`);
        }
    }
    return curValue;
}
exports.getValueAtLocator = getValueAtLocator;
function setValueAtLocator(obj, locator, value) {
    const locatorSteps = locatorToSteps(locator);
    let result = obj;
    if (locatorSteps.length > 0) {
        let cursor = result;
        let setValue = (value) => {
            result = value;
        };
        for (let i = 0; i < locatorSteps.length; i++) {
            const locatorStep = locatorSteps[i];
            if (locatorStep instanceof DataLocatorStepArrayItem ||
                locatorStep instanceof DataLocatorStepCurrentArrayItem) {
                if (!Array.isArray(cursor)) {
                    cursor = [];
                    setValue(cursor);
                }
                const index = locatorStep instanceof DataLocatorStepArrayItem
                    ? locatorStep.index
                    : 0;
                setValue = ((cursor) => {
                    return (value) => {
                        if (value !== undefined) {
                            cursor[index] = value;
                        }
                        else {
                            cursor.splice(index, 1);
                        }
                    };
                })(cursor);
                cursor = cursor[index];
            }
            else if (locatorStep instanceof DataLocatorStepObjectProperty) {
                if (typeof cursor !== 'object' || cursor === null) {
                    cursor = {};
                    setValue(cursor);
                }
                setValue = ((cursor) => {
                    return (value) => {
                        if (value !== undefined) {
                            cursor[locatorStep.propertyName] = value;
                        }
                        else {
                            delete cursor[locatorStep.propertyName];
                        }
                    };
                })(cursor);
                cursor = cursor[locatorStep.propertyName];
            }
            else {
                throw new Error(`Unexpected locator step type in "setValueAtLocator": ${locatorStep}`);
            }
        }
        setValue(value);
        return result;
    }
    else {
        return value;
    }
}
exports.setValueAtLocator = setValueAtLocator;
function pickFieldsFromValue(value, fields) {
    let result;
    for (const field of fields) {
        const fieldValue = getValueAtLocator(value, field);
        if (!(0, formulas_1.isEmpty)(fieldValue)) {
            result = setValueAtLocator(result, field, fieldValue);
        }
    }
    return result;
}
exports.pickFieldsFromValue = pickFieldsFromValue;
function excludeFieldsFromValue(value, fields) {
    for (const field of fields) {
        setValueAtLocator(value, field, undefined);
    }
    return value;
}
exports.excludeFieldsFromValue = excludeFieldsFromValue;
function setSchemaAtLocator(schema, locator, schemaAtLocator) {
    var _a, _b, _c;
    const locatorSteps = locatorToSteps(locator);
    const result = schema !== null && schema !== void 0 ? schema : {};
    let curSchema = result;
    let curSchemaDataLocator = '$';
    for (const locatorStep of locatorSteps) {
        if (locatorStep.type == DataLocatorStepType.OBJECT_PROPERTY) {
            curSchema.type = 'object';
            const propertyName = locatorStep
                .propertyName;
            if (!((_a = curSchema.properties) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(propertyName))) {
                curSchema.properties = {
                    ...((_b = curSchema.properties) !== null && _b !== void 0 ? _b : {}),
                    [propertyName]: {},
                };
            }
            curSchema = curSchema.properties[propertyName];
            curSchemaDataLocator += `.properties.${propertyName}`;
        }
        else if (locatorStep.type == DataLocatorStepType.ARRAY_ITEM ||
            locatorStep.type == DataLocatorStepType.CURRENT_ARRAY_ITEM) {
            curSchema.type = 'array';
            curSchema.items = (_c = curSchema.items) !== null && _c !== void 0 ? _c : {};
            curSchema = curSchema.items;
            curSchemaDataLocator = `${curSchemaDataLocator}.items`;
        }
        else {
            throw new Error(`Unexpected locator step type: ${locatorStep.type}`);
        }
    }
    return setValueAtLocator(result, curSchemaDataLocator, schemaAtLocator);
}
exports.setSchemaAtLocator = setSchemaAtLocator;
function extractFieldLocator(locator) {
    const steps = locatorToSteps(locator);
    const fieldSteps = [];
    for (const step of steps) {
        if (step.type === DataLocatorStepType.OBJECT_PROPERTY &&
            step.propertyName.startsWith('$')) {
            break;
        }
        fieldSteps.push(step);
    }
    return stepsToLocator(fieldSteps);
}
exports.extractFieldLocator = extractFieldLocator;
function makeSchemaForLocator(locator, locatorSchema) {
    return setSchemaAtLocator(null, locator, locatorSchema);
}
exports.makeSchemaForLocator = makeSchemaForLocator;
function getNameForLocator(schema, locator) {
    locator = locatorToSteps(locator);
    const schemaSteps = walkSchema(schema, locator);
    if (schemaSteps) {
        const titleParts = schemaSteps.map((s) => s.title).filter((t) => !!t);
        return titleParts[titleParts.length - 1];
    }
    else {
        return null;
    }
}
exports.getNameForLocator = getNameForLocator;
function getNameComponentsForLocator(schema, locator) {
    locator = locatorToSteps(locator);
    const schemaSteps = walkSchema(schema, locator);
    return schemaSteps === null || schemaSteps === void 0 ? void 0 : schemaSteps.map((s) => s.title).filter((t) => !!t);
}
exports.getNameComponentsForLocator = getNameComponentsForLocator;
function getFullNameForLocator(schema, locator) {
    var _a;
    return (_a = getNameComponentsForLocator(schema, locator)) === null || _a === void 0 ? void 0 : _a.join(' > ');
}
exports.getFullNameForLocator = getFullNameForLocator;
function getIconUriForLocator(schema, locator) {
    locator = locatorToSteps(locator);
    const schemaSteps = walkSchema(schema, locator);
    return schemaSteps && schemaSteps.map((s) => s.iconUri).filter((t) => !!t)[0];
}
exports.getIconUriForLocator = getIconUriForLocator;
function getLocatorsFromData(data, parentLocator = '$') {
    if (data === null || data === undefined) {
        return [];
    }
    if (Array.isArray(data)) {
        return data.flatMap((item, idx) => getLocatorsFromData(item, `${parentLocator}[${idx}]`));
    }
    if (typeof data === 'object') {
        const locators = [];
        for (const [key, value] of Object.entries(data)) {
            locators.push(...getLocatorsFromData(value, `${parentLocator}.${key}`));
        }
        return locators;
    }
    return [parentLocator];
}
exports.getLocatorsFromData = getLocatorsFromData;
function getLocatorsFromSchema(schema, parentLocator = '$') {
    var _a;
    if (!schema || !schema.type) {
        return [];
    }
    if (schema.type === 'object') {
        const locators = [];
        for (const [key, value] of Object.entries((_a = schema.properties) !== null && _a !== void 0 ? _a : {})) {
            locators.push(...getLocatorsFromSchema(value, `${parentLocator}.${key}`));
        }
        return locators;
    }
    if (schema.type === 'array') {
        return getLocatorsFromSchema(schema.items, `${parentLocator}[0]`);
    }
    return [parentLocator];
}
exports.getLocatorsFromSchema = getLocatorsFromSchema;
exports.getFullTitleForLocator = getFullNameForLocator;
function walkSchema(schema, locator) {
    var _a, _b;
    locator = locatorToSteps(locator);
    const schemaSteps = [];
    let curSchema = schema;
    for (let idx = 0; idx < locator.length; ++idx) {
        const schemaStep = {};
        const step = locator[idx];
        let defaultTitle;
        if (!curSchema) {
            return null;
        }
        if (step.type == DataLocatorStepType.OBJECT_PROPERTY) {
            if (curSchema.type == 'object') {
                const objectPropertyStep = step;
                curSchema = (_a = curSchema.properties) === null || _a === void 0 ? void 0 : _a[objectPropertyStep.propertyName];
                defaultTitle = (0, js_convert_case_1.toHeaderCase)(objectPropertyStep.propertyName);
            }
            else {
                return null;
            }
        }
        else if (step.type == DataLocatorStepType.ARRAY_ITEM) {
            if (curSchema.type == 'array') {
                const arrayItemStep = step;
                curSchema = curSchema.items;
                defaultTitle = `Item #${arrayItemStep.index + 1}`;
            }
            else {
                return null;
            }
        }
        else if (step.type == DataLocatorStepType.CURRENT_ARRAY_ITEM) {
            if (curSchema.type == 'array') {
                curSchema = curSchema.items;
                defaultTitle = 'Current Item';
            }
            else {
                return null;
            }
        }
        if (!curSchema) {
            return null;
        }
        schemaStep.schema = Object.assign({}, curSchema);
        schemaStep.title = (_b = schemaStep.schema.title) !== null && _b !== void 0 ? _b : defaultTitle;
        schemaStep.iconUri = schemaStep.schema.iconUri;
        schemaSteps.push(schemaStep);
    }
    return schemaSteps;
}
exports.walkSchema = walkSchema;
function locatorToSteps(sourceLocator) {
    if (Array.isArray(sourceLocator))
        return sourceLocator;
    if (typeof sourceLocator !== 'string')
        throw new errors_1.BadRequestError(`Unexpected locator value: ${JSON.stringify(sourceLocator)}`);
    if (sourceLocator === '$')
        return [];
    if (!lodash_1.default.startsWith(sourceLocator, '$')) {
        sourceLocator = `$.${sourceLocator}`;
    }
    const locators = [];
    let cursorPosition = 1;
    while (cursorPosition < sourceLocator.length) {
        if (sourceLocator[cursorPosition] === '.') {
            const closingIndex = findNextPosition(sourceLocator, cursorPosition + 1, '[.');
            const part = unescape(sourceLocator.slice(cursorPosition + 1, closingIndex));
            if (!part) {
                throw new errors_1.BadRequestError('There should be a property name after a dot');
            }
            locators.push(part === '$current'
                ? new DataLocatorStepCurrentArrayItem()
                : new DataLocatorStepObjectProperty(part));
            cursorPosition = closingIndex;
        }
        else if (sourceLocator[cursorPosition] === '[') {
            const closingIndex = sourceLocator.indexOf(']', cursorPosition);
            if (closingIndex === -1) {
                throw new errors_1.BadRequestError(`Could not find a closing bracket for the bracket at position ${cursorPosition}. Locator: ${sourceLocator}`);
            }
            const arrayIndex = +sourceLocator.slice(cursorPosition + 1, closingIndex);
            if (isNaN(arrayIndex) || arrayIndex < 0) {
                throw new errors_1.BadRequestError(`Invalid index [${sourceLocator.slice(cursorPosition + 1, closingIndex)}]. Index should be a positive number`);
            }
            locators.push(new DataLocatorStepArrayItem(arrayIndex));
            cursorPosition = closingIndex + 1;
        }
        else {
            throw new errors_1.BadRequestError(`Unexpected symbol at position ${cursorPosition}. Locator: ${sourceLocator}`);
        }
    }
    return locators;
}
exports.locatorToSteps = locatorToSteps;
function locatorToString(locator) {
    if (typeof locator === 'object' && Array.isArray(locator)) {
        return stepsToLocator(locator);
    }
    else {
        return locator;
    }
}
exports.locatorToString = locatorToString;
function stepsToLocator(steps) {
    let locator = '$';
    (steps !== null && steps !== void 0 ? steps : []).forEach((step) => {
        switch (step.type) {
            case DataLocatorStepType.OBJECT_PROPERTY:
                locator += `.${escape(step.propertyName)}`;
                break;
            case DataLocatorStepType.ARRAY_ITEM:
                locator += `[${step.index}]`;
                break;
            case DataLocatorStepType.CURRENT_ARRAY_ITEM:
                locator += '.$current';
                break;
            default:
                throw new Error(`Unknown locator step type: ${step.type}`);
        }
    });
    return locator;
}
exports.stepsToLocator = stepsToLocator;
function getFormulaLocators(formulaType, data) {
    function doGetFormulaLocators(data, locator) {
        if (data && typeof data === 'object') {
            if (`$${formulaType}` in data && Object.keys(data).length === 1) {
                return [locator];
            }
            else if (Array.isArray(data)) {
                const locators = [];
                data.map((item, idx) => {
                    locators.push(...doGetFormulaLocators(item, `${locator}[${idx}]`));
                });
                return locators;
            }
            else {
                const locators = [];
                for (const [key, value] of Object.entries(data)) {
                    locators.push(...doGetFormulaLocators(value, `${locator}.${key}`));
                }
                return locators;
            }
        }
        else {
            return [];
        }
    }
    return doGetFormulaLocators(data, '$');
}
exports.getFormulaLocators = getFormulaLocators;
function findNextPosition(str, startPosition, symbols) {
    let escaped = false;
    for (let i = startPosition; i < str.length; i++) {
        if (str[i] === '\\') {
            escaped = !escaped;
            continue;
        }
        if (escaped) {
            escaped = false;
            continue;
        }
        if (symbols.includes(str[i])) {
            return i;
        }
    }
}
function escape(str) {
    return str.replace(/[\\\[\].]/g, '\\$&');
}
function unescape(str) {
    return str.replace(/\\(.)/g, '$1');
}
//# sourceMappingURL=locators.js.map