// src/index.ts
import fs4 from "fs";
import path2 from "path";
import { createFilter } from "vite";
import { interpolateName } from "loader-utils";

// src/utils.ts
import fs from "fs";
import { version } from "vite";
import { gte } from "semver";
import * as mrmime from "mrmime";
import escapeStringRegexp from "escape-string-regexp";

// src/vitools.ts
function svgToDataURL(content) {
  const stringContent = content.toString();
  if (stringContent.includes("<text") || stringContent.includes("<foreignObject")) {
    return `data:image/svg+xml;base64,${content.toString("base64")}`;
  } else {
    return "data:image/svg+xml," + stringContent.trim().replaceAll(/>\s+</g, "><").replaceAll('"', "'").replaceAll("%", "%25").replaceAll("#", "%23").replaceAll("<", "%3c").replaceAll(">", "%3e").replaceAll(/\s+/g, "%20");
  }
}

// src/utils.ts
function isObject(value) {
  return Object.prototype.toString.call(value) === "[object Object]";
}
var intermidiateFormats = ["es", "cjs"];
var finalFormats = ["umd", "iife"];
function checkFormats(formats) {
  const isIntermidiateFormat = formats.some((format) => intermidiateFormats.includes(format));
  const isFinalFormat = formats.some((format) => finalFormats.includes(format));
  return Number(isIntermidiateFormat) + Number(isFinalFormat) === 1;
}
var assetsContentMap = /* @__PURE__ */ new Map();
function getAssetContent(id) {
  let content = assetsContentMap.get(id);
  const pureId = id.split("?")[0];
  if (!content) {
    if (!fs.existsSync(pureId)) {
      console.warn(`[vite-plugin-lib-assets]: file not found ${id}`);
      content = null;
    } else {
      content = fs.readFileSync(pureId);
      assetsContentMap.set(id, content);
    }
  }
  return content;
}
var postfixRE = /[?#].*$/s;
function cleanUrl(url) {
  return url.replace(postfixRE, "");
}
function registerCustomMime() {
  mrmime.mimes["ico"] = "image/x-icon";
  mrmime.mimes["flac"] = "audio/flac";
  mrmime.mimes["eot"] = "application/vnd.ms-fontobject";
}
function getFileBase64(id, content) {
  const file = cleanUrl(id);
  if (gte(version, "5.0.0") && file.endsWith(".svg")) {
    return svgToDataURL(content);
  } else {
    const mimeType = mrmime.lookup(file) ?? "application/octet-stream";
    return `data:${mimeType};base64,${content.toString("base64")}`;
  }
}
function getCaptured(input, re) {
  const captures = [];
  let match;
  let remaining = input;
  while (match = re.exec(remaining)) {
    match[1] !== void 0 && captures.push(match[1]);
    remaining = remaining.slice(match.index + match[0].length);
  }
  return captures;
}
function replaceAll(source, searchValue, replaceValue) {
  const escaped = escapeStringRegexp(searchValue);
  const replaceRegExp = new RegExp(escaped, "g");
  return source.replace(replaceRegExp, replaceValue);
}

// src/constants.ts
var KNOWN_ASSET_TYPES = [
  // images
  "apng",
  "png",
  "jpe?g",
  "jfif",
  "pjpeg",
  "pjp",
  "gif",
  "svg",
  "ico",
  "webp",
  "avif",
  // media
  "mp4",
  "webm",
  "ogg",
  "mp3",
  "wav",
  "flac",
  "aac",
  "opus",
  // fonts
  "woff2?",
  "eot",
  "ttf",
  "otf",
  // other
  "webmanifest",
  "pdf",
  "txt"
];
var DEFAULT_ASSETS_RE = new RegExp(
  `\\.(${KNOWN_ASSET_TYPES.join("|")})(\\?.*)?$`
);
var CSS_LANGS_RE = /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/;
var cssUrlRE = /(?<=^|[^\w\-\u0080-\uFFFF])url\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/;
var cssImageSetRE = /(?<=image-set\()((?:[\w\-]{1,256}\([^)]*\)|[^)])*)(?=\))/;
var ASSETS_IMPORTER_RE = /\.(css|js|cjs|mjs)(?:$|\?)/;

// src/compiler.ts
import { createRequire } from "module";
function resolveCompiler(root) {
  const vueMeta = tryRequire("vue/package.json", root);
  const version2 = vueMeta ? vueMeta.version.split(".")[0] : "";
  const compiler = tryRequire("vue/compiler-sfc", root) || tryRequire("vue/compiler-sfc");
  if (!compiler) {
    throw new Error(
      "Failed to resolve vue/compiler-sfc.\nvite-plugin-vue-setup-name requires vue (>=2.7.0) to be present in the dependency tree."
    );
  }
  return { impl: compiler, version: version2 };
}
var _require = createRequire(import.meta.url);
function tryRequire(id, from) {
  try {
    return from ? _require(_require.resolve(id, { paths: [from] })) : _require(id);
  } catch (e) {
  }
}

// src/descriptorCache.ts
import fs2 from "fs";
function parseSFC(filename, source, { version: version2, impl: compiler }) {
  let result;
  if (version2 === "2") {
    let descriptor;
    let errors = [];
    try {
      descriptor = compiler.parse({ source, filename, sourceMap: false });
    } catch (e) {
      errors = [e];
      descriptor = compiler.parse({ source: "", filename });
    }
    result = { descriptor, errors };
  } else if (version2 === "3") {
    result = compiler.parse(source, { filename, sourceMap: false });
  } else {
    throw new Error("Unknown vue version");
  }
  return result;
}
function getDescriptor(filename, options, createIfNotFound = true) {
  if (createIfNotFound) {
    const { compiler } = options;
    const { descriptor, errors } = parseSFC(filename, fs2.readFileSync(filename, "utf-8"), compiler);
    if (errors.length)
      throw errors[0];
    return descriptor;
  }
}

// src/alias.ts
function matches(pattern, importee) {
  if (pattern instanceof RegExp)
    return pattern.test(importee);
  if (importee.length < pattern.length)
    return false;
  if (importee === pattern)
    return true;
  return importee.startsWith(`${pattern}/`);
}
async function resolve(context, alias, importees, importer) {
  const resolves = importees.map((importee) => {
    const matched = alias.find((alias2) => matches(alias2.find, importee));
    const updated = matched ? importee.replace(matched.find, matched.replacement) : importee;
    return context.resolve(updated, importer, { skipSelf: true }).then((resolved) => resolved !== null ? resolved.id : updated);
  });
  return Promise.all(resolves);
}

// src/processStyle/index.ts
import fs3 from "fs";
import path from "path";
import util from "util";
import { Buffer } from "buffer";
import { preprocessCSS } from "vite";
import escapeStringRegexp2 from "escape-string-regexp";

// src/processStyle/config.ts
async function ensureCssSourceMapConfig(config) {
  let css = config.css ?? {};
  let build = config.build ?? {};
  if ("transformer" in css && css.transformer === "lightningcss") {
    console.warn(
      "[vite-plugin-lib-assets]: The processing of style files using lightningcss is not yet supported by this plugin due to insufficient information. This might lead to incorrect handling of assets referenced in the @import files. https://github.com/laynezh/vite-plugin-lib-assets/issues/34#issuecomment-1826250269"
    );
    if (config.build.sourcemap === false)
      build = { ...build, sourcemap: true };
    if (!css.devSourcemap)
      css = { ...css, devSourcemap: true };
  } else {
    const { postcss = {} } = css;
    if (typeof postcss !== "string") {
      css = {
        ...css,
        postcss: {
          ...postcss,
          map: isObject(postcss.map) ? { ...postcss.map, inline: true } : { inline: true }
        }
      };
    } else {
      css = {
        ...css,
        postcss: {
          map: { inline: true }
        }
      };
    }
  }
  return { ...config, css, build };
}

// src/processStyle/utils.ts
function getAssetsInStyle(source) {
  const cssUrlAssets = getCaptured(source, cssUrlRE);
  const cssImageSetAssets = getCaptured(source, cssImageSetRE);
  const assets = [...cssUrlAssets, ...cssImageSetAssets];
  const pureAssets = assets.map(
    (asset) => asset.startsWith("'") || asset.startsWith('"') ? asset.slice(1, -1) : asset
  );
  const concernedAssets = pureAssets.filter(
    (asset) => !asset.startsWith("data:") && !/^(?:https?:)?\/\//.test(asset)
  );
  return concernedAssets;
}

// src/processStyle/index.ts
var postcssSourceMapReg = /\/\*# sourceMappingURL=data:application\/json;base64,([^*]+)\*\//mi;
function getSourceMapFromResult(result, config) {
  const css = config.css ?? {};
  if ("transformer" in css && css.transformer === "lightningcss") {
    if (typeof result.map === "string") {
      try {
        return JSON.parse(result.map);
      } catch (err) {
        return null;
      }
    }
    return result.map && "version" in result.map ? result.map : null;
  } else {
    const [_, sourceMapBase64] = result.code.match(postcssSourceMapReg) || ["", ""];
    try {
      const sourceMap = Buffer.from(sourceMapBase64.trim(), "base64").toString("utf8");
      return JSON.parse(sourceMap);
    } catch (err) {
      return null;
    }
  }
}
async function rebaseStyleUrls(moduleId, result, config) {
  const sourceMap = getSourceMapFromResult(result, config);
  if (sourceMap === null) {
    console.warn(
      "[vite-plugin-lib-assets]: Failed to obtain the sourcemap when handling the style file. This might lead to incorrect handling of assets referenced in the @import files. https://github.com/laynezh/vite-plugin-lib-assets/issues/34#issuecomment-1826250269"
    );
    return result;
  }
  if (sourceMap.sources.length < 2)
    return result;
  const moduleDir = path.dirname(moduleId);
  const { sources, sourcesContent = [] } = sourceMap;
  const replacements = await Promise.all(
    sources.map(async (source2, index) => {
      const escaped = escapeStringRegexp2(source2);
      const testRegExp = new RegExp(`${escaped}$`);
      if (testRegExp.test(moduleId))
        return [];
      if (source2.indexOf(config.root.slice(1)) === 0)
        source2 = `/${source2}`;
      const filepath = path.isAbsolute(source2) ? source2 : path.resolve(moduleDir, source2);
      const fileDir = path.dirname(filepath);
      let content = sourcesContent[index];
      if (content === null) {
        if (fs3.existsSync(filepath)) {
          content = await util.promisify(fs3.readFile)(filepath, "utf8");
        } else {
          console.warn(
            "[vite-plugin-lib-assets]: Failed to obtain the file content when handling the style file. This might lead to incorrect handling of assets referenced in the @import files. https://github.com/laynezh/vite-plugin-lib-assets/issues/34#issuecomment-1826250269"
          );
          return [];
        }
      }
      const assets = getAssetsInStyle(content);
      return assets.map((asset) => {
        const assetPath = path.resolve(fileDir, asset);
        const replacement = path.relative(moduleDir, assetPath);
        return { [asset]: replacement };
      });
    })
  );
  let source = result.code;
  let position = 0;
  replacements.flat().forEach((replacement) => {
    Object.keys(replacement).forEach((asset) => {
      const processed = source.slice(0, position);
      const left = source.slice(position);
      const assetIndex = left.indexOf(asset, position);
      const replaceValue = replacement[asset];
      source = processed + left.replace(asset, replaceValue);
      position = assetIndex + (replaceValue.length - asset.length);
    });
  });
  return { ...result, code: source };
}
async function processStyle(moduleId, code, config) {
  const needRebaseUrls = code.includes("@import");
  const processConfig = needRebaseUrls ? await ensureCssSourceMapConfig(config) : config;
  let result = await preprocessCSS(code, moduleId, processConfig);
  if (needRebaseUrls) {
    result = await rebaseStyleUrls(moduleId, result, config);
    result.code = result.code.replace(postcssSourceMapReg, "");
  }
  return result.code;
}

// src/index.ts
function VitePluginLibAssets(options = {}) {
  registerCustomMime();
  const {
    include = DEFAULT_ASSETS_RE,
    exclude,
    name = "[contenthash].[ext]",
    limit,
    outputPath,
    regExp,
    publicUrl = ""
  } = options;
  const publicDir = publicUrl.endsWith("/") ? publicUrl : `${publicUrl}/`;
  let isLibBuild = false;
  let assetsDir;
  let outDir;
  let alias = [];
  let viteConfig;
  const descriptorOptions = {
    compiler: null,
    // to be set in buildStart
    root: process.cwd()
  };
  const filter = createFilter(include, exclude);
  const cssLangFilter = createFilter(CSS_LANGS_RE);
  const assetsImporterFilter = createFilter(ASSETS_IMPORTER_RE);
  let transformSkipped = true;
  let emittedAssets;
  const assetCache = /* @__PURE__ */ new WeakMap();
  const assetsPathMap = /* @__PURE__ */ new Map();
  const base64AssetsPathMap = /* @__PURE__ */ new Map();
  const emitFile = (context, id, content) => {
    const [pureId, resourceQuery] = id.split("?");
    const loaderContext = {
      resourcePath: pureId,
      resourceQuery
    };
    const url = interpolateName(loaderContext, name, { content, regExp });
    let assetPath = url;
    const outputDir = outputPath || assetsDir;
    assetPath = typeof outputDir === "function" ? path2.posix.join(outputDir(url, pureId, resourceQuery), url) : path2.posix.join(outputDir, url);
    const filename = assetPath.replace(`?${resourceQuery}`, "");
    const fullname = path2.join(path2.isAbsolute(outDir) ? process.cwd() : "", outDir, assetPath);
    const cache = assetCache.get(viteConfig);
    if (!cache.has(filename)) {
      const emitted = {
        fileName: filename,
        name: fullname,
        source: content,
        type: "asset"
      };
      context.emitFile(emitted);
      cache.set(filename, emitted);
    }
    return assetPath;
  };
  const extractFromSource = async (context, id, content) => {
    let source = content;
    try {
      source = await processStyle(id, content, viteConfig);
    } catch (err) {
      console.warn(`[vite-plugin-lib-assets]: failed to preprocessCSS ${err}`);
    }
    const cssUrlAssets = getCaptured(source, cssUrlRE);
    const cssImageSetAssets = getCaptured(source, cssImageSetRE);
    const assets = [...cssUrlAssets, ...cssImageSetAssets];
    const pureAssets = assets.map(
      (asset) => asset.startsWith("'") || asset.startsWith('"') ? asset.slice(1, -1) : asset
    );
    const concernedAssets = pureAssets.filter(
      (asset) => !asset.startsWith("data:") && !/^(?:https?:)?\/\//.test(asset)
    );
    return resolve(context, alias, Array.from(new Set(concernedAssets)), id);
  };
  const extractFromFile = async (context, id) => {
    const content = getAssetContent(id);
    if (!content)
      return [];
    const [pureId] = id.split("?", 2);
    if (path2.extname(pureId) === ".vue") {
      if (!descriptorOptions.compiler)
        descriptorOptions.compiler = resolveCompiler(descriptorOptions.root);
      const descriptor = getDescriptor(pureId, descriptorOptions);
      if (descriptor === void 0)
        return [];
      const extractedAssetList = await Promise.all(
        descriptor.styles.map(
          (style) => extractFromSource(context, id, style.content)
        )
      );
      return extractedAssetList.flatMap((extractedAssets) => extractedAssets);
    }
    return extractFromSource(context, id, content.toString());
  };
  const processAssetsInStyle = (bundleSourceMap) => {
    const updatedSourceMap = { ...bundleSourceMap };
    Object.keys(updatedSourceMap).forEach((name2) => {
      let updated = updatedSourceMap[name2];
      base64AssetsPathMap.forEach((asset, base64) => {
        updated = replaceAll(updated, base64, publicUrl ? asset : `./${asset}`);
      });
      if (updatedSourceMap[name2] !== updated)
        updatedSourceMap[name2] = updated;
    });
    return updatedSourceMap;
  };
  const processAssetsInImporters = (bundleSourceMap) => {
    const updatedSourceMap = { ...bundleSourceMap };
    const assetsExtracted = Object.keys(updatedSourceMap).filter((id) => filter(id));
    Object.keys(updatedSourceMap).filter((name2) => assetsImporterFilter(name2)).forEach((name2) => {
      let updated = updatedSourceMap[name2];
      const fileDir = path2.dirname(name2);
      assetsExtracted.forEach(async (asset) => {
        const relativePath = path2.posix.relative(fileDir, asset);
        const relativeAsset = relativePath.startsWith(".") ? relativePath : `./${relativePath}`;
        const originalAsset = `./${asset}`;
        if (asset !== relativeAsset && updated.includes(originalAsset)) {
          updated = replaceAll(updated, `'${originalAsset}'`, `'${relativeAsset}'`);
          updated = replaceAll(updated, `"${originalAsset}"`, `"${relativeAsset}"`);
          updated = replaceAll(updated, `(${originalAsset})`, `(${relativeAsset})`);
        }
      });
      if (updatedSourceMap[name2] !== updated)
        updatedSourceMap[name2] = updated;
    });
    return updatedSourceMap;
  };
  return {
    name: "vite-plugin-lib-assets",
    apply: "build",
    enforce: "pre",
    buildEnd() {
      if (transformSkipped)
        emittedAssets.forEach((emitted) => this.emitFile(emitted));
      else
        emittedAssets = assetCache.get(viteConfig) ?? /* @__PURE__ */ new Map();
      assetCache.set(viteConfig, /* @__PURE__ */ new Map());
    },
    watchChange() {
      transformSkipped = true;
    },
    transform() {
      transformSkipped = false;
    },
    configResolved(config) {
      viteConfig = config;
      assetCache.set(config, /* @__PURE__ */ new Map());
      const { build, resolve: resolve2 } = config;
      isLibBuild = build.lib !== false;
      assetsDir = build.assetsDir;
      outDir = build.outDir;
      alias = resolve2.alias;
      if (build.lib !== false) {
        const { formats = ["es", "umd"] } = build.lib;
        const valid = checkFormats(formats);
        if (!valid && publicUrl) {
          console.warn(
            "[vite-plugin-lib-assets] The publicUrl configuration will be applied to all output formats."
          );
        }
      }
    },
    async resolveId(source, importer = "") {
      if (!isLibBuild)
        return null;
      const importerDir = importer.endsWith(path2.sep) ? importer : path2.dirname(importer);
      const id = path2.resolve(importerDir, source);
      if (cssLangFilter(id)) {
        const assetsFromCss = await extractFromFile(this, id);
        const validAssets = assetsFromCss.map((aid) => path2.resolve(path2.dirname(id), aid)).filter((id2) => filter(id2)).map((id2) => ({ id: id2, content: getAssetContent(id2) })).filter(({ content }) => limit && content ? content.byteLength > limit : true);
        validAssets.forEach(({ id: id2, content }) => {
          let assetPath = emitFile(this, id2, content);
          const base64 = getFileBase64(id2, content);
          if (publicUrl)
            assetPath = `${publicDir}${assetPath}`;
          base64AssetsPathMap.set(base64, assetPath);
        });
      }
      if (filter(id)) {
        const content = getAssetContent(id);
        if (!content)
          return null;
        if (limit && content.byteLength < limit)
          return null;
        const assetPath = emitFile(this, id, content);
        if (publicUrl) {
          assetsPathMap.set(id, assetPath);
          return id;
        }
        return {
          id: `./${assetPath}`,
          external: "relative"
        };
      }
    },
    load(id) {
      if (!isLibBuild)
        return null;
      const assetPath = assetsPathMap.get(id);
      if (assetPath)
        return `export default '${publicDir}${assetPath}'`;
    },
    async writeBundle(_, outputBundle) {
      const outputDir = path2.isAbsolute(outDir) ? outDir : path2.posix.join(process.cwd(), outDir);
      const bundleSourceMap = Object.keys(outputBundle).reduce((map, name2) => {
        const filePath = path2.posix.join(outputDir, name2);
        const source = fs4.readFileSync(filePath, "utf8");
        map[name2] = source;
        return map;
      }, {});
      const updatedSourceMap = processAssetsInStyle(bundleSourceMap);
      const processedSourceMap = processAssetsInImporters(updatedSourceMap);
      Object.keys(bundleSourceMap).filter((name2) => bundleSourceMap[name2] !== processedSourceMap[name2]).forEach((name2) => {
        const outputPath2 = path2.posix.join(outputDir, name2);
        const updated = processedSourceMap[name2];
        fs4.writeFileSync(outputPath2, updated);
        const bundle = outputBundle[name2];
        if (bundle.type === "chunk")
          bundle.code = updated;
        else if (name2.endsWith(".css"))
          bundle.source = updated;
      });
    }
  };
}
export {
  VitePluginLibAssets as default
};
