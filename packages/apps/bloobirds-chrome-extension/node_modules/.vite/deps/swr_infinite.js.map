{
  "version": 3,
  "sources": ["../../../../../../node_modules/swr/infinite/dist/index.esm.js"],
  "sourcesContent": ["import { useRef, useCallback } from 'react';\nimport useSWR from 'swr';\nimport { INFINITE_PREFIX, serialize, withMiddleware, SWRGlobalState, cache, createCacheHelper, isUndefined, useIsomorphicLayoutEffect, UNDEFINED, isFunction } from 'swr/_internal';\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';\n\nconst getFirstPageKey = (getKey)=>{\n    return serialize(getKey ? getKey(0, null) : null)[0];\n};\nconst unstable_serialize = (getKey)=>{\n    return INFINITE_PREFIX + getFirstPageKey(getKey);\n};\n\n// We have to several type castings here because `useSWRInfinite` is a special\n// const INFINITE_PREFIX = '$inf$'\nconst EMPTY_PROMISE = Promise.resolve();\n// export const unstable_serialize = (getKey: SWRInfiniteKeyLoader) => {\n//   return INFINITE_PREFIX + getFirstPageKey(getKey)\n// }\nconst infinite = (useSWRNext)=>(getKey, fn, config)=>{\n        const didMountRef = useRef(false);\n        const { cache: cache$1, initialSize = 1, revalidateAll = false, persistSize = false, revalidateFirstPage = true, revalidateOnMount = false, parallel = false } = config;\n        const [, , , PRELOAD] = SWRGlobalState.get(cache);\n        // The serialized key of the first page. This key will be used to store\n        // metadata of this SWR infinite hook.\n        let infiniteKey;\n        try {\n            infiniteKey = getFirstPageKey(getKey);\n            if (infiniteKey) infiniteKey = INFINITE_PREFIX + infiniteKey;\n        } catch (err) {\n        // Not ready yet.\n        }\n        const [get, set, subscribeCache] = createCacheHelper(cache$1, infiniteKey);\n        const getSnapshot = useCallback(()=>{\n            const size = isUndefined(get()._l) ? initialSize : get()._l;\n            return size;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            cache$1,\n            infiniteKey,\n            initialSize\n        ]);\n        useSyncExternalStore(useCallback((callback)=>{\n            if (infiniteKey) return subscribeCache(infiniteKey, ()=>{\n                callback();\n            });\n            return ()=>{};\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            cache$1,\n            infiniteKey\n        ]), getSnapshot, getSnapshot);\n        const resolvePageSize = useCallback(()=>{\n            const cachedPageSize = get()._l;\n            return isUndefined(cachedPageSize) ? initialSize : cachedPageSize;\n        // `cache` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            infiniteKey,\n            initialSize\n        ]);\n        // keep the last page size to restore it with the persistSize option\n        const lastPageSizeRef = useRef(resolvePageSize());\n        // When the page key changes, we reset the page size if it's not persisted\n        useIsomorphicLayoutEffect(()=>{\n            if (!didMountRef.current) {\n                didMountRef.current = true;\n                return;\n            }\n            if (infiniteKey) {\n                // If the key has been changed, we keep the current page size if persistSize is enabled\n                // Otherwise, we reset the page size to cached pageSize\n                set({\n                    _l: persistSize ? lastPageSizeRef.current : resolvePageSize()\n                });\n            }\n        // `initialSize` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            infiniteKey,\n            cache$1\n        ]);\n        // Needs to check didMountRef during mounting, not in the fetcher\n        const shouldRevalidateOnMount = revalidateOnMount && !didMountRef.current;\n        // Actual SWR hook to load all pages in one fetcher.\n        const swr = useSWRNext(infiniteKey, async (key)=>{\n            // get the revalidate context\n            const forceRevalidateAll = get()._i;\n            // return an array of page data\n            const data = [];\n            const pageSize = resolvePageSize();\n            const [getCache] = createCacheHelper(cache$1, key);\n            const cacheData = getCache().data;\n            const revalidators = [];\n            let previousPageData = null;\n            for(let i = 0; i < pageSize; ++i){\n                const [pageKey, pageArg] = serialize(getKey(i, parallel ? null : previousPageData));\n                if (!pageKey) {\n                    break;\n                }\n                const [getSWRCache, setSWRCache] = createCacheHelper(cache$1, pageKey);\n                // Get the cached page data.\n                let pageData = getSWRCache().data;\n                // should fetch (or revalidate) if:\n                // - `revalidateAll` is enabled\n                // - `mutate()` called\n                // - the cache is missing\n                // - it's the first page and it's not the initial render\n                // - `revalidateOnMount` is enabled and it's on mount\n                // - cache for that page has changed\n                const shouldFetchPage = revalidateAll || forceRevalidateAll || isUndefined(pageData) || revalidateFirstPage && !i && !isUndefined(cacheData) || shouldRevalidateOnMount || cacheData && !isUndefined(cacheData[i]) && !config.compare(cacheData[i], pageData);\n                if (fn && shouldFetchPage) {\n                    const revalidate = async ()=>{\n                        const hasPreloadedRequest = pageKey in PRELOAD;\n                        if (!hasPreloadedRequest) {\n                            pageData = await fn(pageArg);\n                        } else {\n                            const req = PRELOAD[pageKey];\n                            // delete the preload cache key before resolving it\n                            // in case there's an error\n                            delete PRELOAD[pageKey];\n                            // get the page data from the preload cache\n                            pageData = await req;\n                        }\n                        setSWRCache({\n                            data: pageData,\n                            _k: pageArg\n                        });\n                        data[i] = pageData;\n                    };\n                    if (parallel) {\n                        revalidators.push(revalidate);\n                    } else {\n                        await revalidate();\n                    }\n                } else {\n                    data[i] = pageData;\n                }\n                if (!parallel) {\n                    previousPageData = pageData;\n                }\n            }\n            // flush all revalidateions in parallel\n            if (parallel) {\n                await Promise.all(revalidators.map((r)=>r()));\n            }\n            // once we executed the data fetching based on the context, clear the context\n            set({\n                _i: UNDEFINED\n            });\n            // return the data\n            return data;\n        }, config);\n        const mutate = useCallback(// eslint-disable-next-line func-names\n        function(data, opts) {\n            // When passing as a boolean, it's explicitly used to disable/enable\n            // revalidation.\n            const options = typeof opts === 'boolean' ? {\n                revalidate: opts\n            } : opts || {};\n            // Default to true.\n            const shouldRevalidate = options.revalidate !== false;\n            // It is possible that the key is still falsy.\n            if (!infiniteKey) return EMPTY_PROMISE;\n            if (shouldRevalidate) {\n                if (!isUndefined(data)) {\n                    // We only revalidate the pages that are changed\n                    set({\n                        _i: false\n                    });\n                } else {\n                    // Calling `mutate()`, we revalidate all pages\n                    set({\n                        _i: true\n                    });\n                }\n            }\n            return arguments.length ? swr.mutate(data, {\n                ...options,\n                revalidate: shouldRevalidate\n            }) : swr.mutate();\n        }, // swr.mutate is always the same reference\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            infiniteKey,\n            cache$1\n        ]);\n        // Extend the SWR API\n        const setSize = useCallback((arg)=>{\n            // It is possible that the key is still falsy.\n            if (!infiniteKey) return EMPTY_PROMISE;\n            const [, changeSize] = createCacheHelper(cache$1, infiniteKey);\n            let size;\n            if (isFunction(arg)) {\n                size = arg(resolvePageSize());\n            } else if (typeof arg == 'number') {\n                size = arg;\n            }\n            if (typeof size != 'number') return EMPTY_PROMISE;\n            changeSize({\n                _l: size\n            });\n            lastPageSizeRef.current = size;\n            // Calculate the page data after the size change.\n            const data = [];\n            const [getInfiniteCache] = createCacheHelper(cache$1, infiniteKey);\n            let previousPageData = null;\n            for(let i = 0; i < size; ++i){\n                const [pageKey] = serialize(getKey(i, previousPageData));\n                const [getCache] = createCacheHelper(cache$1, pageKey);\n                // Get the cached page data.\n                const pageData = pageKey ? getCache().data : UNDEFINED;\n                // Call `mutate` with infinte cache data if we can't get it from the page cache.\n                if (isUndefined(pageData)) {\n                    return mutate(getInfiniteCache().data);\n                }\n                data.push(pageData);\n                previousPageData = pageData;\n            }\n            return mutate(data);\n        }, // exclude getKey from the dependencies, which isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            infiniteKey,\n            cache$1,\n            mutate,\n            resolvePageSize\n        ]);\n        // Use getter functions to avoid unnecessary re-renders caused by triggering\n        // all the getters of the returned swr object.\n        return {\n            size: resolvePageSize(),\n            setSize,\n            mutate,\n            get data () {\n                return swr.data;\n            },\n            get error () {\n                return swr.error;\n            },\n            get isValidating () {\n                return swr.isValidating;\n            },\n            get isLoading () {\n                return swr.isLoading;\n            }\n        };\n    };\nconst useSWRInfinite = withMiddleware(useSWR, infinite);\n\nexport { useSWRInfinite as default, infinite, unstable_serialize };\n"],
  "mappings": "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",
  "names": []
}
