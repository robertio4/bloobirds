{
  "version": 3,
  "sources": ["../../../../../../node_modules/@udecode/plate-normalizers/src/withNormalizeTypes.ts", "../../../../../../node_modules/@udecode/plate-normalizers/src/createNormalizeTypesPlugin.ts", "../../../../../../node_modules/lodash/isArray.js", "../../../../../../node_modules/lodash/castArray.js", "../../../../../../node_modules/@udecode/plate-normalizers/src/withRemoveEmptyNodes.ts", "../../../../../../node_modules/@udecode/plate-normalizers/src/createRemoveEmptyNodesPlugin.ts", "../../../../../../node_modules/@udecode/plate-link/src/utils/createLinkNode.ts", "../../../../../../node_modules/@udecode/plate-link/src/components/LaunchIcon.tsx", "../../../../../../node_modules/@udecode/plate-link/src/components/Link.tsx", "../../../../../../node_modules/@udecode/plate-link/src/components/LinkIcon.tsx", "../../../../../../node_modules/@udecode/plate-link/src/components/LinkOffIcon.tsx", "../../../../../../node_modules/@udecode/plate-link/src/components/ShortTextIcon.tsx", "../../../../../../node_modules/@udecode/plate-link/src/components/FloatingLink/floatingLinkStore.ts", "../../../../../../node_modules/@udecode/plate-link/src/utils/triggerFloatingLinkEdit.ts", "../../../../../../node_modules/@udecode/plate-link/src/components/FloatingLink/FloatingLinkEditButton.tsx", "../../../../../../node_modules/@udecode/plate-link/src/components/FloatingLink/FloatingLinkNewTabInput.tsx", "../../../../../../node_modules/@udecode/plate-link/src/components/FloatingLink/FloatingLinkTextInput.tsx", "../../../../../../node_modules/@udecode/plate-link/src/components/FloatingLink/FloatingLinkUrlInput.tsx", "../../../../../../node_modules/@udecode/plate-link/src/components/FloatingLink/OpenLinkButton.tsx", "../../../../../../node_modules/@udecode/plate-link/src/components/FloatingLink/UnlinkButton.tsx", "../../../../../../node_modules/rollup-plugin-node-globals/src/global.js", "../../../../../../node_modules/process-es6/browser.js", "../../../../../../node_modules/@floating-ui/core/dist/floating-ui.core.esm.js", "../../../../../../node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js", "../../../../../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js", "../../../../../../node_modules/@floating-ui/react-dom-interactions/dist/floating-ui.react-dom-interactions.esm.js", "../../../../../../node_modules/floating/dist/index.es.js", "../../../../../../node_modules/@udecode/plate-link/src/transforms/submitFloatingLink.ts", "../../../../../../node_modules/@udecode/plate-link/src/components/FloatingLink/useFloatingLinkEnter.ts", "../../../../../../node_modules/@udecode/plate-link/src/components/FloatingLink/useFloatingLinkEscape.ts", "../../../../../../node_modules/@udecode/plate-link/src/components/FloatingLink/useVirtualFloatingLink.ts", "../../../../../../node_modules/@udecode/plate-link/src/components/FloatingLink/useFloatingLinkEdit.ts", "../../../../../../node_modules/@udecode/plate-link/src/utils/triggerFloatingLinkInsert.ts", "../../../../../../node_modules/@udecode/plate-link/src/components/FloatingLink/useFloatingLinkInsert.ts", "../../../../../../node_modules/@udecode/plate-link/src/components/FloatingLink/FloatingLink.tsx", "../../../../../../node_modules/@udecode/plate-link/src/utils/triggerFloatingLink.ts", "../../../../../../node_modules/@udecode/plate-link/src/transforms/insertLink.ts", "../../../../../../node_modules/@udecode/plate-link/src/transforms/unwrapLink.ts", "../../../../../../node_modules/@udecode/plate-link/src/transforms/upsertLinkText.ts", "../../../../../../node_modules/@udecode/plate-link/src/transforms/wrapLink.ts", "../../../../../../node_modules/@udecode/plate-link/src/transforms/upsertLink.ts", "../../../../../../node_modules/@udecode/plate-link/src/withLink.ts", "../../../../../../node_modules/@udecode/plate-link/src/createLinkPlugin.ts"],
  "sourcesContent": ["import {\n  getNode,\n  insertElements,\n  isElement,\n  PlateEditor,\n  setElements,\n  TElement,\n  Value,\n  WithPlatePlugin,\n} from '@udecode/plate-core';\nimport { NormalizeTypesPlugin } from './createNormalizeTypesPlugin';\n\nexport const withNormalizeTypes = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>\n>(\n  editor: E,\n  { options: { rules, onError } }: WithPlatePlugin<NormalizeTypesPlugin, V, E>\n) => {\n  const { normalizeNode } = editor;\n\n  editor.normalizeNode = ([currentNode, currentPath]) => {\n    if (!currentPath.length) {\n      const endCurrentNormalizationPass = rules!.some(\n        ({ strictType, type, path }) => {\n          const node = getNode<TElement>(editor, path);\n\n          if (node) {\n            if (strictType && isElement(node) && node.type !== strictType) {\n              setElements(\n                editor,\n                { type: strictType },\n                {\n                  at: path,\n                }\n              );\n              return true;\n            }\n          } else {\n            try {\n              insertElements(\n                editor,\n                {\n                  type: strictType ?? type!,\n                  children: [{ text: '' }],\n                },\n                { at: path }\n              );\n              return true;\n            } catch (err) {\n              onError?.(err);\n            }\n          }\n\n          return false;\n        }\n      );\n\n      if (endCurrentNormalizationPass) {\n        return;\n      }\n    }\n\n    return normalizeNode([currentNode, currentPath]);\n  };\n\n  return editor;\n};\n", "import { createPluginFactory, ErrorHandler } from '@udecode/plate-core';\nimport { Path } from 'slate';\nimport { withNormalizeTypes } from './withNormalizeTypes';\n\ninterface Rule {\n  /**\n   * Force the type of the node at the given path\n   */\n  strictType?: string;\n  /**\n   * Type of the inserted node at the given path if `strictType` is not provided\n   */\n  type?: string;\n  /**\n   * Path where the rule applies\n   */\n  path: Path;\n}\n\nexport interface NormalizeTypesPlugin extends ErrorHandler {\n  /**\n   * Set of rules for the types.\n   * For each rule, provide a `path` and either `strictType` or `type`.\n   * If there is no node existing at `path`:\n   * insert a node with `strictType`.\n   * If there is a node existing at `path` but its type is not `strictType` or `type`:\n   * set the node type to `strictType` or `type`.\n   */\n  rules?: Rule[];\n}\n\nexport const KEY_NORMALIZE_TYPES = 'normalizeTypes';\n\n/**\n * @see {@link withNormalizeTypes}\n */\nexport const createNormalizeTypesPlugin = createPluginFactory<NormalizeTypesPlugin>(\n  {\n    key: KEY_NORMALIZE_TYPES,\n    withOverrides: withNormalizeTypes,\n    options: {\n      rules: [],\n    },\n  }\n);\n", "/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n", "var isArray = require('./isArray');\n\n/**\n * Casts `value` as an array if it's not one.\n *\n * @static\n * @memberOf _\n * @since 4.4.0\n * @category Lang\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast array.\n * @example\n *\n * _.castArray(1);\n * // => [1]\n *\n * _.castArray({ 'a': 1 });\n * // => [{ 'a': 1 }]\n *\n * _.castArray('abc');\n * // => ['abc']\n *\n * _.castArray(null);\n * // => [null]\n *\n * _.castArray(undefined);\n * // => [undefined]\n *\n * _.castArray();\n * // => []\n *\n * var array = [1, 2, 3];\n * console.log(_.castArray(array) === array);\n * // => true\n */\nfunction castArray() {\n  if (!arguments.length) {\n    return [];\n  }\n  var value = arguments[0];\n  return isArray(value) ? value : [value];\n}\n\nmodule.exports = castArray;\n", "import {\n  getNodeString,\n  isElement,\n  PlateEditor,\n  removeNodes,\n  Value,\n  WithPlatePlugin,\n} from '@udecode/plate-core';\nimport castArray from 'lodash/castArray';\nimport { RemoveEmptyNodesPlugin } from './createRemoveEmptyNodesPlugin';\n\n/**\n * Remove nodes with empty text.\n */\nexport const withRemoveEmptyNodes = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>\n>(\n  editor: E,\n  { options: { types: _types } }: WithPlatePlugin<RemoveEmptyNodesPlugin, V, E>\n) => {\n  const types = castArray(_types);\n\n  const { normalizeNode } = editor;\n\n  editor.normalizeNode = ([node, path]) => {\n    if (\n      isElement(node) &&\n      node.type &&\n      types.includes(node.type) &&\n      getNodeString(node) === ''\n    ) {\n      removeNodes(editor, { at: path });\n      return;\n    }\n\n    normalizeNode([node, path]);\n  };\n\n  return editor;\n};\n", "import { createPluginFactory } from '@udecode/plate-core';\nimport { withRemoveEmptyNodes } from './withRemoveEmptyNodes';\n\nexport interface RemoveEmptyNodesPlugin {\n  types?: string | string[];\n}\n\n/**\n * @see {@link withRemoveEmptyNodes}\n */\nexport const createRemoveEmptyNodesPlugin = createPluginFactory<RemoveEmptyNodesPlugin>(\n  {\n    key: 'removeEmptyNodes',\n    withOverrides: withRemoveEmptyNodes,\n  }\n);\n", "import { getPluginType, PlateEditor, TText, Value } from '@udecode/plate-core';\nimport { ELEMENT_LINK } from '../createLinkPlugin';\nimport { TLinkElement } from '../types';\n\nexport interface CreateLinkNodeOptions {\n  url: string;\n  text?: string;\n  target?: string;\n  children?: TText[];\n}\n\nexport const createLinkNode = <V extends Value>(\n  editor: PlateEditor<V>,\n  { url, text = '', target, children }: CreateLinkNodeOptions\n): TLinkElement => {\n  const type = getPluginType(editor, ELEMENT_LINK);\n\n  return {\n    type,\n    url,\n    target,\n    children: children ?? [{ text }],\n  };\n};\n", "import React, { SVGProps } from 'react';\n\nexport const LaunchIcon = (props: SVGProps<SVGSVGElement>) => (\n  <svg\n    viewBox=\"0 0 24 24\"\n    focusable=\"false\"\n    role=\"img\"\n    fill=\"currentColor\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    {...props}\n  >\n    <path fill=\"none\" d=\"M0 0h24v24H0z\" />\n    <path d=\"M19 19H5V5h7V3H5a2 2 0 00-2 2v14a2 2 0 002 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z\" />\n  </svg>\n);\n", "import {\n  createComponentAs,\n  createElementAs,\n  HTMLPropsAs,\n  PlateRenderElementProps,\n  useElementProps,\n  Value,\n} from '@udecode/plate-core';\nimport { TLinkElement } from '../types';\n\nexport type LinkRootProps = PlateRenderElementProps<Value, TLinkElement> &\n  HTMLPropsAs<'a'>;\n\nexport const useLink = (props: LinkRootProps): HTMLPropsAs<'a'> => {\n  const _props = useElementProps<TLinkElement, 'a'>({\n    ...props,\n    elementToAttributes: (element) => ({\n      href: element.url,\n      target: element.target,\n    }),\n  });\n\n  return {\n    ..._props,\n    // quick fix: hovering <a> with href loses the editor focus\n    onMouseOver: (e) => {\n      e.stopPropagation();\n    },\n  };\n};\n\nexport const LinkRoot = createComponentAs<LinkRootProps>((props) => {\n  const htmlProps = useLink(props);\n\n  return createElementAs('a', htmlProps);\n});\n\nexport const Link = {\n  Root: LinkRoot,\n};\n", "import React, { SVGProps } from 'react';\n\nexport const LinkIcon = (props: SVGProps<SVGSVGElement>) => (\n  <svg\n    viewBox=\"0 0 24 24\"\n    focusable=\"false\"\n    role=\"img\"\n    fill=\"currentColor\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    {...props}\n  >\n    <path fill=\"none\" d=\"M0 0h24v24H0z\" />\n    <path d=\"M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z\" />\n  </svg>\n);\n", "import React, { SVGProps } from 'react';\n\nexport const LinkOffIcon = (props: SVGProps<SVGSVGElement>) => (\n  <svg\n    viewBox=\"0 0 24 24\"\n    focusable=\"false\"\n    role=\"img\"\n    fill=\"currentColor\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    {...props}\n  >\n    <path fill=\"none\" d=\"M0 0h24v24H0V0z\" />\n    <path d=\"M17 7h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1 0 1.43-.98 2.63-2.31 2.98l1.46 1.46C20.88 15.61 22 13.95 22 12c0-2.76-2.24-5-5-5zm-1 4h-2.19l2 2H16zM2 4.27l3.11 3.11A4.991 4.991 0 002 12c0 2.76 2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1 0-1.59 1.21-2.9 2.76-3.07L8.73 11H8v2h2.73L13 15.27V17h1.73l4.01 4L20 19.74 3.27 3 2 4.27z\" />\n    <path fill=\"none\" d=\"M0 24V0\" />\n  </svg>\n);\n", "import React, { SVGProps } from 'react';\n\nexport const ShortTextIcon = (props: SVGProps<SVGSVGElement>) => (\n  <svg\n    viewBox=\"0 0 24 24\"\n    focusable=\"false\"\n    role=\"img\"\n    fill=\"currentColor\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    {...props}\n  >\n    <rect width={24} height={24} fill=\"none\" />\n    <path d=\"M4 9h16v2H4V9zm0 4h10v2H4v-2z\" />\n  </svg>\n);\n", "import { createStore } from '@udecode/plate-core';\n\nexport type FloatingLinkMode = '' | 'insert' | 'edit';\n\nexport const floatingLinkStore = createStore('floatingLink')({\n  openEditorId: null as null | string,\n  mouseDown: false,\n  updated: false,\n  url: '',\n  text: '',\n  newTab: false,\n  mode: '' as FloatingLinkMode,\n  isEditing: false,\n})\n  .extendActions((set) => ({\n    reset: () => {\n      set.url('');\n      set.text('');\n      set.newTab(false);\n      set.mode('');\n      set.isEditing(false);\n    },\n  }))\n  .extendActions((set) => ({\n    show: (mode: FloatingLinkMode, editorId: string) => {\n      set.mode(mode);\n      set.isEditing(false);\n      set.openEditorId(editorId);\n    },\n    hide: () => {\n      set.openEditorId(null);\n      set.reset();\n    },\n  }))\n  .extendSelectors((state) => ({\n    isOpen: (editorId: string) => state.openEditorId === editorId,\n  }));\n\nexport const floatingLinkActions = floatingLinkStore.set;\nexport const floatingLinkSelectors = floatingLinkStore.get;\nexport const useFloatingLinkSelectors = () => floatingLinkStore.use;\n", "import {\n  findNode,\n  getEditorString,\n  getPluginType,\n  PlateEditor,\n  Value,\n} from '@udecode/plate-core';\nimport { floatingLinkActions } from '../components/FloatingLink/floatingLinkStore';\nimport { ELEMENT_LINK } from '../createLinkPlugin';\nimport { TLinkElement } from '../types';\n\nexport const triggerFloatingLinkEdit = <V extends Value>(\n  editor: PlateEditor<V>\n) => {\n  const entry = findNode<TLinkElement>(editor, {\n    match: { type: getPluginType(editor, ELEMENT_LINK) },\n  });\n  if (!entry) return;\n\n  const [link, path] = entry;\n\n  let text = getEditorString(editor, path);\n\n  floatingLinkActions.url(link.url);\n\n  floatingLinkActions.newTab(link.target === undefined);\n\n  if (text === link.url) {\n    text = '';\n  }\n\n  floatingLinkActions.text(text);\n\n  floatingLinkActions.isEditing(true);\n\n  return true;\n};\n", "import { useCallback } from 'react';\nimport {\n  AsProps,\n  createComponentAs,\n  createElementAs,\n  HTMLPropsAs,\n  useEditorRef,\n} from '@udecode/plate-core';\nimport { triggerFloatingLinkEdit } from '../../utils/triggerFloatingLinkEdit';\n\nexport const useFloatingLinkEditButton = (\n  props: HTMLPropsAs<'button'>\n): HTMLPropsAs<'button'> => {\n  const editor = useEditorRef();\n\n  return {\n    onClick: useCallback(() => {\n      triggerFloatingLinkEdit(editor);\n    }, [editor]),\n    ...props,\n  };\n};\n\nexport const FloatingLinkEditButton = createComponentAs<AsProps<'button'>>(\n  (props) => {\n    const htmlProps = useFloatingLinkEditButton(props);\n\n    return createElementAs('button', htmlProps);\n  }\n);\n", "import {\n  ChangeEventHandler,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from 'react';\nimport {\n  AsProps,\n  createComponentAs,\n  createElementAs,\n  HTMLPropsAs,\n  mergeProps,\n  useComposedRef,\n} from '@udecode/plate-core';\nimport {\n  floatingLinkActions,\n  floatingLinkSelectors,\n  useFloatingLinkSelectors,\n} from './floatingLinkStore';\n\nexport const useFloatingLinkNewTabInput = (\n  props: HTMLPropsAs<'input'>\n): HTMLPropsAs<'input'> => {\n  const updated = useFloatingLinkSelectors().updated();\n  const ref = useRef<HTMLInputElement>(null);\n  const [checked, setChecked] = useState<boolean>(\n    floatingLinkSelectors.newTab()\n  );\n\n  useEffect(() => {\n    if (ref.current && updated) {\n      setTimeout(() => {\n        ref.current?.focus();\n      }, 0);\n    }\n  }, [updated]);\n\n  const onChange: ChangeEventHandler<HTMLInputElement> = useCallback((e) => {\n    setChecked(e.target.checked);\n    floatingLinkActions.newTab(e.target.checked);\n  }, []);\n\n  return mergeProps(\n    {\n      onChange,\n      checked,\n      type: 'checkbox',\n    },\n    { ...props, ref: useComposedRef<HTMLInputElement>(props.ref, ref) }\n  );\n};\n\nexport const FloatingLinkNewTabInput = createComponentAs<AsProps<'input'>>(\n  (props) => {\n    const htmlProps = useFloatingLinkNewTabInput(props);\n\n    return createElementAs('input', htmlProps);\n  }\n);\n", "import { ChangeEventHandler, useCallback } from 'react';\nimport {\n  AsProps,\n  createComponentAs,\n  createElementAs,\n  HTMLPropsAs,\n  mergeProps,\n} from '@udecode/plate-core';\nimport {\n  floatingLinkActions,\n  floatingLinkSelectors,\n} from './floatingLinkStore';\n\nexport const useFloatingLinkTextInput = (\n  props: HTMLPropsAs<'input'>\n): HTMLPropsAs<'input'> => {\n  const onChange: ChangeEventHandler<HTMLInputElement> = useCallback((e) => {\n    floatingLinkActions.text(e.target.value);\n  }, []);\n\n  return mergeProps(\n    {\n      onChange,\n      defaultValue: floatingLinkSelectors.text(),\n    },\n    props\n  );\n};\n\nexport const FloatingLinkTextInput = createComponentAs<AsProps<'input'>>(\n  (props) => {\n    const htmlProps = useFloatingLinkTextInput(props);\n\n    return createElementAs('input', htmlProps);\n  }\n);\n", "import { ChangeEventHandler, useCallback, useEffect, useRef } from 'react';\nimport {\n  AsProps,\n  createComponentAs,\n  createElementAs,\n  HTMLPropsAs,\n  mergeProps,\n  useComposedRef,\n} from '@udecode/plate-core';\nimport {\n  floatingLinkActions,\n  floatingLinkSelectors,\n  useFloatingLinkSelectors,\n} from './floatingLinkStore';\n\nexport const useFloatingLinkUrlInput = (\n  props: HTMLPropsAs<'input'>\n): HTMLPropsAs<'input'> => {\n  const updated = useFloatingLinkSelectors().updated();\n  const ref = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    if (ref.current && updated) {\n      setTimeout(() => {\n        ref.current?.focus();\n      }, 0);\n    }\n  }, [updated]);\n\n  const onChange: ChangeEventHandler<HTMLInputElement> = useCallback((e) => {\n    floatingLinkActions.url(e.target.value);\n  }, []);\n\n  return mergeProps(\n    {\n      onChange,\n      defaultValue: floatingLinkSelectors.url(),\n    },\n    { ...props, ref: useComposedRef<HTMLInputElement>(props.ref, ref) }\n  );\n};\n\nexport const FloatingLinkUrlInput = createComponentAs<AsProps<'input'>>(\n  (props) => {\n    const htmlProps = useFloatingLinkUrlInput(props);\n\n    return createElementAs('input', htmlProps);\n  }\n);\n", "import { useMemo } from 'react';\nimport {\n  AsProps,\n  createComponentAs,\n  createElementAs,\n  findNode,\n  getPluginType,\n  HTMLPropsAs,\n  useEditorRef,\n  usePlateSelection,\n} from '@udecode/plate-core';\nimport { ELEMENT_LINK } from '../../createLinkPlugin';\nimport { TLinkElement } from '../../types';\n\nexport const useOpenLinkButton = (\n  props: HTMLPropsAs<'a'>\n): HTMLPropsAs<'a'> => {\n  const editor = useEditorRef();\n  const selection = usePlateSelection();\n\n  const entry = useMemo(\n    () =>\n      findNode<TLinkElement>(editor, {\n        match: { type: getPluginType(editor, ELEMENT_LINK) },\n      }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [editor, selection]\n  );\n\n  if (!entry) {\n    return {};\n  }\n\n  const [link] = entry;\n\n  return {\n    'aria-label': 'Open link in a new tab',\n    target: '_blank',\n    href: link.url,\n    onMouseOver: (e) => {\n      e.stopPropagation();\n    },\n    ...props,\n  };\n};\n\nexport const OpenLinkButton = createComponentAs<AsProps<'a'>>((props) => {\n  const htmlProps = useOpenLinkButton(props);\n\n  return createElementAs('a', htmlProps);\n});\n", "import { useCallback } from 'react';\nimport { Button } from '@udecode/plate-button';\nimport {\n  AsProps,\n  createComponentAs,\n  createElementAs,\n  focusEditor,\n  HTMLPropsAs,\n  useEditorRef,\n} from '@udecode/plate-core';\nimport { unwrapLink } from '../../transforms/index';\n\nexport const useUnlinkButton = (\n  props: HTMLPropsAs<'button'>\n): HTMLPropsAs<'button'> => {\n  const editor = useEditorRef();\n\n  return {\n    onClick: useCallback(() => {\n      unwrapLink(editor);\n      focusEditor(editor, editor.selection!);\n    }, [editor]),\n    ...props,\n  };\n};\n\nexport const UnlinkButton = createComponentAs<AsProps<'button'>>((props) => {\n  const htmlProps = useUnlinkButton(props);\n\n  return createElementAs(Button, htmlProps);\n});\n", "export default (typeof global !== \"undefined\" ? global :\n            typeof self !== \"undefined\" ? self :\n            typeof window !== \"undefined\" ? window : {});\n", "// shim for using process in browser\n// based off https://github.com/defunctzombie/node-process/blob/master/browser.js\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\nvar cachedSetTimeout = defaultSetTimout;\nvar cachedClearTimeout = defaultClearTimeout;\nif (typeof global.setTimeout === 'function') {\n    cachedSetTimeout = setTimeout;\n}\nif (typeof global.clearTimeout === 'function') {\n    cachedClearTimeout = clearTimeout;\n}\n\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\nexport function nextTick(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n}\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nexport var title = 'browser';\nexport var platform = 'browser';\nexport var browser = true;\nexport var env = {};\nexport var argv = [];\nexport var version = ''; // empty string to avoid regexp issues\nexport var versions = {};\nexport var release = {};\nexport var config = {};\n\nfunction noop() {}\n\nexport var on = noop;\nexport var addListener = noop;\nexport var once = noop;\nexport var off = noop;\nexport var removeListener = noop;\nexport var removeAllListeners = noop;\nexport var emit = noop;\n\nexport function binding(name) {\n    throw new Error('process.binding is not supported');\n}\n\nexport function cwd () { return '/' }\nexport function chdir (dir) {\n    throw new Error('process.chdir is not supported');\n};\nexport function umask() { return 0; }\n\n// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js\nvar performance = global.performance || {}\nvar performanceNow =\n  performance.now        ||\n  performance.mozNow     ||\n  performance.msNow      ||\n  performance.oNow       ||\n  performance.webkitNow  ||\n  function(){ return (new Date()).getTime() }\n\n// generate timestamp or delta\n// see http://nodejs.org/api/process.html#process_process_hrtime\nexport function hrtime(previousTimestamp){\n  var clocktime = performanceNow.call(performance)*1e-3\n  var seconds = Math.floor(clocktime)\n  var nanoseconds = Math.floor((clocktime%1)*1e9)\n  if (previousTimestamp) {\n    seconds = seconds - previousTimestamp[0]\n    nanoseconds = nanoseconds - previousTimestamp[1]\n    if (nanoseconds<0) {\n      seconds--\n      nanoseconds += 1e9\n    }\n  }\n  return [seconds,nanoseconds]\n}\n\nvar startTime = new Date();\nexport function uptime() {\n  var currentTime = new Date();\n  var dif = currentTime - startTime;\n  return dif / 1000;\n}\n\nexport default {\n  nextTick: nextTick,\n  title: title,\n  browser: browser,\n  env: env,\n  argv: argv,\n  version: version,\n  versions: versions,\n  on: on,\n  addListener: addListener,\n  once: once,\n  off: off,\n  removeListener: removeListener,\n  removeAllListeners: removeAllListeners,\n  emit: emit,\n  binding: binding,\n  cwd: cwd,\n  chdir: chdir,\n  umask: umask,\n  hrtime: hrtime,\n  platform: platform,\n  release: release,\n  config: config,\n  uptime: uptime\n};\n", "function getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\n\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (platform == null) {\n      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));\n    }\n\n    if (middleware.filter(_ref => {\n      let {\n        name\n      } = _ref;\n      return name === 'autoPlacement' || name === 'flip';\n    }).length > 1) {\n      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement`', 'middleware detected. This will lead to an infinite loop. Ensure only', 'one of either has been passed to the `middleware` array.'].join(' '));\n    }\n  }\n\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n\n  for (let i = 0; i < middleware.length; i++) {\n    const {\n      name,\n      fn\n    } = middleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = { ...middlewareData,\n      [name]: { ...middlewareData[name],\n        ...data\n      }\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (resetCount > 50) {\n        console.warn(['Floating UI: The middleware lifecycle appears to be running in an', 'infinite loop. This is usually caused by a `reset` continually', 'being returned without a break condition.'].join(' '));\n      }\n    }\n\n    if (reset && resetCount <= 50) {\n      resetCount++;\n\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n\n      i = -1;\n      continue;\n    }\n  }\n\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(middlewareArguments, options) {\n  var _await$platform$isEle;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect: elementContext === 'floating' ? { ...rects.floating,\n      x,\n      y\n    } : rects.reference,\n    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n    strategy\n  }) : rects[elementContext]);\n  return {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n}\n\nconst min = Math.min;\nconst max = Math.max;\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n\n    if (element == null) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');\n      }\n\n      return {};\n    }\n\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const alignment = getAlignment(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n\n    if (clientSize === 0) {\n      clientSize = rects.floating[length];\n    }\n\n    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds\n\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max); // Make sure that arrow points at the reference\n\n    const alignmentPadding = alignment === 'start' ? paddingObject[minProp] : paddingObject[maxProp];\n    const shouldAddOffset = alignmentPadding > 0 && center !== offset && rects.reference[length] <= rects.floating[length];\n    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n\n    return true;\n  });\n}\n\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'autoPlacement',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;\n\n      const {\n        x,\n        y,\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        alignment = null,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;\n      const currentPlacement = placements[currentIndex];\n\n      if (currentPlacement == null) {\n        return {};\n      }\n\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))); // Make `computeCoords` start from the right place\n\n      if (placement !== currentPlacement) {\n        return {\n          x,\n          y,\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...((_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1]; // There are more placements to check\n\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n\n      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);\n      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {\n        let {\n          overflows\n        } = _ref;\n        return overflows.every(overflow => overflow <= 0);\n      })) == null ? void 0 : _placementsSortedByLe.placement;\n      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;\n\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'flip',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$flip;\n\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = side === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n        overflows.push(overflow[main], overflow[cross]);\n      }\n\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }]; // One or more sides is overflowing\n\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip2;\n\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        let resetPlacement = 'bottom';\n\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$map$so;\n\n              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n\n              if (placement) {\n                resetPlacement = placement;\n              }\n\n              break;\n            }\n\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (_temp) {\n  let {\n    strategy = 'referenceHidden',\n    ...detectOverflowOptions\n  } = _temp === void 0 ? {} : _temp;\n  return {\n    name: 'hide',\n\n    async fn(middlewareArguments) {\n      const {\n        rects\n      } = middlewareArguments;\n\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        default:\n          {\n            return {};\n          }\n      }\n    }\n\n  };\n};\n\nasync function convertValueToCoords(middlewareArguments, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = middlewareArguments;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const\n\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\n\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return {\n    name: 'offset',\n    options: value,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y\n      } = middlewareArguments;\n      const diffCoords = await convertValueToCoords(middlewareArguments, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'shift',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n\n      const limitedCoords = limiter.fn({ ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return { ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n\n  };\n};\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    options,\n\n    fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = middlewareArguments;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const mainAxis = getMainAxisFromPlacement(placement);\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = typeof offset === 'function' ? offset({ ...rects,\n        placement\n      }) : offset;\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;\n\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n\n  };\n};\n\n/**\n * Provides data to change the size of the floating element. For instance,\n * prevent it from overflowing its clipping boundary or match the width of the\n * reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'size',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        apply,\n        ...detectOverflowOptions\n      } = options;\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      let heightSide;\n      let widthSide;\n\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n\n      const xMin = max(overflow.left, 0);\n      const xMax = max(overflow.right, 0);\n      const yMin = max(overflow.top, 0);\n      const yMax = max(overflow.bottom, 0);\n      const dimensions = {\n        availableHeight: rects.floating.height - (['left', 'right'].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),\n        availableWidth: rects.floating.width - (['top', 'bottom'].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])\n      };\n      const prevDimensions = await platform.getDimensions(elements.floating);\n      apply == null ? void 0 : apply({ ...middlewareArguments,\n        ...dimensions\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n\n      if (prevDimensions.width !== nextDimensions.width || prevDimensions.height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'inline',\n    options,\n\n    async fn(middlewareArguments) {\n      var _await$platform$getCl;\n\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = middlewareArguments; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n\n      const {\n        padding = 2,\n        x,\n        y\n      } = options;\n      const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect: rects.reference,\n        offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n        strategy\n      }) : rects.reference);\n      const clientRects = (_await$platform$getCl = await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];\n      const paddingObject = getSideObjectFromPadding(padding);\n\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          var _clientRects$find;\n\n          // Find the first rect in which the point is fully inside\n          return (_clientRects$find = clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;\n        } // There are 2 or more connected rects\n\n\n        if (clientRects.length >= 2) {\n          if (getMainAxisFromPlacement(placement) === 'x') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n\n        return fallback;\n      }\n\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, rectToClientRect, shift, size };\n", "import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\n\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';\n}\n\nfunction getUAString() {\n  const uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n  }\n\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle$1(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || // @ts-ignore (TS 4.1 compat)\n  css.contain === 'paint' || ['transform', 'perspective'].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n  // • Always-visible scrollbar or not\n  // • Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;\n  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction isScaled(element) {\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)\n  isOffsetParentAnElement && isScaled(offsetParent), strategy === 'fixed');\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || ( // DOM Element detected\n    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n\n  );\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && !['html', 'body'].includes(getNodeName(currentNode))) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n\n  }\n\n  return { ...rect,\n    x: rect.x - scroll.scrollLeft + offsets.x,\n    y: rect.y - scroll.scrollTop + offsets.y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle$1(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n\n  if (['html', 'body', '#document'].includes(getNodeName(parentNode))) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here\n  updatedList.concat(getOverflowAncestors(target));\n}\n\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  return false;\n}\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\n\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n  if (clippingParent === 'viewport') {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingAncestors(element) {\n  const clippingAncestors = getOverflowAncestors(element);\n  const canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle$1(element).position);\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n\n\n  return clippingAncestors.filter(clippingAncestors => isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== 'body');\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\n\n\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const mainClippingAncestors = boundary === 'clippingAncestors' ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getElementRects: _ref => {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n      floating: { ...getDimensions(floating),\n        x: 0,\n        y: 0\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize: _ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestorResize = _ancestorResize && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n\n  if (elementResize) {\n    let initialUpdate = true;\n    observer = new ResizeObserver(() => {\n      if (!initialUpdate) {\n        update();\n      }\n\n      initialUpdate = false;\n    });\n    isElement(reference) && !animationFrame && observer.observe(reference);\n    observer.observe(floating);\n  }\n\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n\n  if (animationFrame) {\n    frameLoop();\n  }\n\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n\n  update();\n  return () => {\n    var _observer;\n\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\n\nconst computePosition = (reference, floating, options) => computePosition$1(reference, floating, {\n  platform,\n  ...options\n});\n\nexport { autoUpdate, computePosition, getOverflowAncestors };\n", "import { computePosition, arrow as arrow$1 } from '@floating-ui/dom';\nexport * from '@floating-ui/dom';\nimport * as React from 'react';\nimport { useLayoutEffect, useEffect } from 'react';\nimport * as ReactDOM from 'react-dom';\n\nvar index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (typeof a === 'function' && a.toString() === b.toString()) {\n    return true;\n  }\n\n  let length, i, keys;\n\n  if (a && b && typeof a == 'object') {\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    keys = Object.keys(a);\n    length = keys.length;\n\n    if (length !== Object.keys(b).length) {\n      return false;\n    }\n\n    for (i = length; i-- !== 0;) {\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {\n        return false;\n      }\n    }\n\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n\n      if (key === '_owner' && a.$$typeof) {\n        continue;\n      }\n\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return a !== a && b !== b;\n}\n\nfunction useLatestRef(value) {\n  const ref = React.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\nfunction useFloating(_temp) {\n  let {\n    middleware,\n    placement = 'bottom',\n    strategy = 'absolute',\n    whileElementsMounted\n  } = _temp === void 0 ? {} : _temp;\n  const reference = React.useRef(null);\n  const floating = React.useRef(null);\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const cleanupRef = React.useRef(null);\n  const [data, setData] = React.useState({\n    // Setting these to `null` will allow the consumer to determine if\n    // `computePosition()` has run yet\n    x: null,\n    y: null,\n    strategy,\n    placement,\n    middlewareData: {}\n  });\n  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);\n\n  if (!deepEqual(latestMiddleware == null ? void 0 : latestMiddleware.map(_ref => {\n    let {\n      options\n    } = _ref;\n    return options;\n  }), middleware == null ? void 0 : middleware.map(_ref2 => {\n    let {\n      options\n    } = _ref2;\n    return options;\n  }))) {\n    setLatestMiddleware(middleware);\n  }\n\n  const update = React.useCallback(() => {\n    if (!reference.current || !floating.current) {\n      return;\n    }\n\n    computePosition(reference.current, floating.current, {\n      middleware: latestMiddleware,\n      placement,\n      strategy\n    }).then(data => {\n      if (isMountedRef.current) {\n        ReactDOM.flushSync(() => {\n          setData(data);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy]);\n  index(() => {\n    // Skip first update\n    if (isMountedRef.current) {\n      update();\n    }\n  }, [update]);\n  const isMountedRef = React.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  const runElementMountCallback = React.useCallback(() => {\n    if (typeof cleanupRef.current === 'function') {\n      cleanupRef.current();\n      cleanupRef.current = null;\n    }\n\n    if (reference.current && floating.current) {\n      if (whileElementsMountedRef.current) {\n        const cleanupFn = whileElementsMountedRef.current(reference.current, floating.current, update);\n        cleanupRef.current = cleanupFn;\n      } else {\n        update();\n      }\n    }\n  }, [update, whileElementsMountedRef]);\n  const setReference = React.useCallback(node => {\n    reference.current = node;\n    runElementMountCallback();\n  }, [runElementMountCallback]);\n  const setFloating = React.useCallback(node => {\n    floating.current = node;\n    runElementMountCallback();\n  }, [runElementMountCallback]);\n  const refs = React.useMemo(() => ({\n    reference,\n    floating\n  }), []);\n  return React.useMemo(() => ({ ...data,\n    update,\n    refs,\n    reference: setReference,\n    floating: setFloating\n  }), [data, update, refs, setReference, setFloating]);\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\n\nconst arrow = options => {\n  const {\n    element,\n    padding\n  } = options;\n\n  function isRef(value) {\n    return Object.prototype.hasOwnProperty.call(value, 'current');\n  }\n\n  return {\n    name: 'arrow',\n    options,\n\n    fn(args) {\n      if (isRef(element)) {\n        if (element.current != null) {\n          return arrow$1({\n            element: element.current,\n            padding\n          }).fn(args);\n        }\n\n        return {};\n      } else if (element) {\n        return arrow$1({\n          element,\n          padding\n        }).fn(args);\n      }\n\n      return {};\n    }\n\n  };\n};\n\nexport { arrow, useFloating };\n", "import { useFloating as useFloating$1, getOverflowAncestors } from '@floating-ui/react-dom';\nexport * from '@floating-ui/react-dom';\nimport * as React from 'react';\nimport { useLayoutEffect, useEffect, useRef } from 'react';\nimport { createPortal } from 'react-dom';\nimport { hideOthers } from 'aria-hidden';\n\nvar index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n\nfunction createPubSub() {\n  const map = new Map();\n  return {\n    emit(event, data) {\n      var _map$get;\n\n      (_map$get = map.get(event)) == null ? void 0 : _map$get.forEach(handler => handler(data));\n    },\n\n    on(event, listener) {\n      map.set(event, [...(map.get(event) || []), listener]);\n    },\n\n    off(event, listener) {\n      map.set(event, (map.get(event) || []).filter(l => l !== listener));\n    }\n\n  };\n}\n\nlet serverHandoffComplete = false;\nlet count = 0;\n\nconst genId = () => \"floating-ui-\" + count++;\n\nfunction useFloatingId() {\n  const [id, setId] = React.useState(() => serverHandoffComplete ? genId() : undefined);\n  index(() => {\n    if (id == null) {\n      setId(genId());\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  React.useEffect(() => {\n    if (!serverHandoffComplete) {\n      serverHandoffComplete = true;\n    }\n  }, []);\n  return id;\n} // `toString()` prevents bundlers from trying to `import { useId } from 'react'`\n\n\nconst useReactId = React[/*#__PURE__*/'useId'.toString()];\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/useId\n */\n\nconst useId = useReactId != null ? useReactId : useFloatingId;\n\nconst FloatingNodeContext = /*#__PURE__*/React.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/React.createContext(null);\nconst useFloatingParentNodeId = () => {\n  var _React$useContext$id, _React$useContext;\n\n  return (_React$useContext$id = (_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) != null ? _React$useContext$id : null;\n};\nconst useFloatingTree = () => React.useContext(FloatingTreeContext);\n/**\n * Registers a node into the floating tree, returning its id.\n */\n\nconst useFloatingNodeId = () => {\n  const id = useId();\n  const tree = useFloatingTree();\n  const parentId = useFloatingParentNodeId();\n  index(() => {\n    const node = {\n      id,\n      parentId\n    };\n    tree == null ? void 0 : tree.addNode(node);\n    return () => {\n      tree == null ? void 0 : tree.removeNode(node);\n    };\n  }, [tree, id, parentId]);\n  return id;\n};\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */\n\nconst FloatingNode = _ref => {\n  let {\n    children,\n    id\n  } = _ref;\n  const parentId = useFloatingParentNodeId();\n  return /*#__PURE__*/React.createElement(FloatingNodeContext.Provider, {\n    value: React.useMemo(() => ({\n      id,\n      parentId\n    }), [id, parentId])\n  }, children);\n};\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM (i.e. portalled to a common node, rather than their\n * respective parent).\n * @see https://floating-ui.com/docs/FloatingTree\n */\n\nconst FloatingTree = _ref2 => {\n  let {\n    children\n  } = _ref2;\n  const nodesRef = React.useRef([]);\n  const addNode = React.useCallback(node => {\n    nodesRef.current = [...nodesRef.current, node];\n  }, []);\n  const removeNode = React.useCallback(node => {\n    nodesRef.current = nodesRef.current.filter(n => n !== node);\n  }, []);\n  const events = React.useState(() => createPubSub())[0];\n  return /*#__PURE__*/React.createElement(FloatingTreeContext.Provider, {\n    value: React.useMemo(() => ({\n      nodesRef,\n      addNode,\n      removeNode,\n      events\n    }), [nodesRef, addNode, removeNode, events])\n  }, children);\n};\n\nfunction getDocument(floating) {\n  var _floating$ownerDocume;\n\n  return (_floating$ownerDocume = floating == null ? void 0 : floating.ownerDocument) != null ? _floating$ownerDocume : document;\n}\n\nfunction getWindow(value) {\n  var _getDocument$defaultV;\n\n  return (_getDocument$defaultV = getDocument(value).defaultView) != null ? _getDocument$defaultV : window;\n}\n\nfunction isElement(value) {\n  return value ? value instanceof getWindow(value).Element : false;\n}\nfunction isHTMLElement(value) {\n  return value ? value instanceof getWindow(value).HTMLElement : false;\n}\n\nfunction useFloating(_temp) {\n  let {\n    open = false,\n    onOpenChange = () => {},\n    whileElementsMounted,\n    placement,\n    middleware,\n    strategy,\n    nodeId\n  } = _temp === void 0 ? {} : _temp;\n  const tree = useFloatingTree();\n  const domReferenceRef = React.useRef(null);\n  const dataRef = React.useRef({});\n  const events = React.useState(() => createPubSub())[0];\n  const floating = useFloating$1({\n    placement,\n    middleware,\n    strategy,\n    whileElementsMounted\n  });\n  const refs = React.useMemo(() => ({ ...floating.refs,\n    domReference: domReferenceRef\n  }), [floating.refs]);\n  const context = React.useMemo(() => ({ ...floating,\n    refs,\n    dataRef,\n    nodeId,\n    events,\n    open,\n    onOpenChange\n  }), [floating, nodeId, events, open, onOpenChange, refs]);\n  index(() => {\n    const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);\n\n    if (node) {\n      node.context = context;\n    }\n  });\n  const {\n    reference\n  } = floating;\n  const setReference = React.useCallback(node => {\n    if (isElement(node) || node === null) {\n      context.refs.domReference.current = node;\n    }\n\n    reference(node);\n  }, [reference, context.refs]);\n  return React.useMemo(() => ({ ...floating,\n    context,\n    refs,\n    reference: setReference\n  }), [floating, refs, context, setReference]);\n}\n\nfunction mergeProps(userProps, propsList, elementKey) {\n  const map = new Map();\n  return { ...(elementKey === 'floating' && {\n      tabIndex: -1\n    }),\n    ...userProps,\n    ...propsList.map(value => value ? value[elementKey] : null).concat(userProps).reduce((acc, props) => {\n      if (!props) {\n        return acc;\n      }\n\n      Object.entries(props).forEach(_ref => {\n        let [key, value] = _ref;\n\n        if (key.indexOf('on') === 0) {\n          if (!map.has(key)) {\n            map.set(key, []);\n          }\n\n          if (typeof value === 'function') {\n            var _map$get;\n\n            (_map$get = map.get(key)) == null ? void 0 : _map$get.push(value);\n          }\n\n          acc[key] = function () {\n            var _map$get2;\n\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.forEach(fn => fn(...args));\n          };\n        } else {\n          acc[key] = value;\n        }\n      });\n      return acc;\n    }, {})\n  };\n}\n\nconst useInteractions = function (propsList) {\n  if (propsList === void 0) {\n    propsList = [];\n  }\n\n  return {\n    getReferenceProps: userProps => mergeProps(userProps, propsList, 'reference'),\n    getFloatingProps: userProps => mergeProps(userProps, propsList, 'floating'),\n    getItemProps: userProps => mergeProps(userProps, propsList, 'item')\n  };\n};\n\nfunction getChildren(nodes, id) {\n  var _nodes$filter;\n\n  let allChildren = (_nodes$filter = nodes.filter(node => {\n    var _node$context;\n\n    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n  })) != null ? _nodes$filter : [];\n  let currentChildren = allChildren;\n\n  while (currentChildren.length) {\n    var _nodes$filter2;\n\n    currentChildren = (_nodes$filter2 = nodes.filter(node => {\n      var _currentChildren;\n\n      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some(n => {\n        var _node$context2;\n\n        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n      });\n    })) != null ? _nodes$filter2 : [];\n    allChildren = allChildren.concat(currentChildren);\n  }\n\n  return allChildren;\n}\n\nfunction isPointInPolygon(point, polygon) {\n  const [x, y] = point;\n  let isInside = false;\n  const length = polygon.length;\n\n  for (let i = 0, j = length - 1; i < length; j = i++) {\n    const [xi, yi] = polygon[i] || [0, 0];\n    const [xj, yj] = polygon[j] || [0, 0];\n    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n\n  return isInside;\n}\n\nfunction safePolygon(_temp) {\n  let {\n    restMs = 0,\n    buffer = 0.5,\n    debug = null\n  } = _temp === void 0 ? {} : _temp;\n  let timeoutId;\n  let polygonIsDestroyed = false;\n  return _ref => {\n    let {\n      x,\n      y,\n      placement,\n      refs,\n      onClose,\n      nodeId,\n      tree,\n      leave = false\n    } = _ref;\n    return function onPointerMove(event) {\n      var _refs$domReference$cu, _refs$floating$curren;\n\n      clearTimeout(timeoutId);\n\n      function close() {\n        clearTimeout(timeoutId);\n        onClose();\n      }\n\n      if (event.pointerType && event.pointerType !== 'mouse') {\n        return;\n      }\n\n      const {\n        clientX,\n        clientY\n      } = event;\n      const target = 'composedPath' in event ? event.composedPath()[0] : event.target;\n      const targetNode = target; // If the pointer is over the reference or floating element already, there\n      // is no need to run the logic.\n\n      if (event.type === 'pointermove' && (_refs$domReference$cu = refs.domReference.current) != null && _refs$domReference$cu.contains(targetNode)) {\n        return;\n      } // If any nested child is open, abort.\n\n\n      if (tree && getChildren(tree.nodesRef.current, nodeId).some(_ref2 => {\n        let {\n          context\n        } = _ref2;\n        return context == null ? void 0 : context.open;\n      })) {\n        return;\n      } // The cursor landed, so we destroy the polygon logic\n\n\n      if ((_refs$floating$curren = refs.floating.current) != null && _refs$floating$curren.contains(targetNode) && !leave) {\n        polygonIsDestroyed = true;\n        return;\n      }\n\n      if (!refs.domReference.current || !refs.floating.current || placement == null || x == null || y == null) {\n        return;\n      }\n\n      const refRect = refs.domReference.current.getBoundingClientRect();\n      const rect = refs.floating.current.getBoundingClientRect();\n      const side = placement.split('-')[0];\n      const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2; // If the pointer is leaving from the opposite side, the \"buffer\" logic\n      // creates a point where the floating element remains open, but should be\n      // ignored.\n      // A constant of 1 handles floating point rounding errors.\n\n      if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {\n        return close();\n      } // Ignore when the cursor is within the rectangular trough between the\n      // two elements. Since the triangle is created from the cursor point,\n      // which can start beyond the ref element's edge, traversing back and\n      // forth from the ref to the floating element can cause it to close. This\n      // ensures it always remains open in that case.\n\n\n      switch (side) {\n        case 'top':\n          if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= refRect.top + 1) {\n            return;\n          }\n\n          break;\n\n        case 'bottom':\n          if (clientX >= rect.left && clientX <= rect.right && clientY >= refRect.bottom - 1 && clientY <= rect.bottom) {\n            return;\n          }\n\n          break;\n\n        case 'left':\n          if (clientX >= rect.left && clientX <= refRect.left + 1 && clientY >= rect.top && clientY <= rect.bottom) {\n            return;\n          }\n\n          break;\n\n        case 'right':\n          if (clientX >= refRect.right - 1 && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {\n            return;\n          }\n\n          break;\n      }\n\n      if (polygonIsDestroyed) {\n        return close();\n      }\n\n      function getPolygon(_ref3) {\n        let [x, y] = _ref3;\n        const isFloatingWider = rect.width > refRect.width;\n        const isFloatingTaller = rect.height > refRect.height;\n\n        switch (side) {\n          case 'top':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n\n          case 'bottom':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n\n          case 'left':\n            {\n              const cursorPointOne = [x + buffer + 1, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x + buffer + 1, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];\n              return [...commonPoints, cursorPointOne, cursorPointTwo];\n            }\n\n          case 'right':\n            {\n              const cursorPointOne = [x - buffer, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x - buffer, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n        }\n      }\n\n      const poly = getPolygon([x, y]);\n\n      if (process.env.NODE_ENV !== \"production\") {\n        debug == null ? void 0 : debug(poly.slice(0, 4).join(', '));\n      }\n\n      if (!isPointInPolygon([clientX, clientY], poly)) {\n        close();\n      } else if (restMs) {\n        timeoutId = setTimeout(onClose, restMs);\n      }\n    };\n  };\n}\n\nconst DEFAULT_ID = 'floating-ui-root';\nconst useFloatingPortalNode = function (_temp) {\n  let {\n    id = DEFAULT_ID,\n    enabled = true\n  } = _temp === void 0 ? {} : _temp;\n  const [portalEl, setPortalEl] = React.useState(null);\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n\n    const rootNode = document.getElementById(id);\n\n    if (rootNode) {\n      setPortalEl(rootNode);\n    } else {\n      const newPortalEl = document.createElement('div');\n      newPortalEl.id = id;\n      setPortalEl(newPortalEl);\n\n      if (!document.body.contains(newPortalEl)) {\n        document.body.appendChild(newPortalEl);\n      }\n    }\n  }, [id, enabled]);\n  return portalEl;\n};\n/**\n * Portals your floating element outside of the main app node.\n * @see https://floating-ui.com/docs/FloatingPortal\n */\n\nconst FloatingPortal = _ref => {\n  let {\n    children,\n    id = DEFAULT_ID,\n    root = null\n  } = _ref;\n  const portalNode = useFloatingPortalNode({\n    id,\n    enabled: !root\n  });\n\n  if (root) {\n    return /*#__PURE__*/createPortal(children, root);\n  }\n\n  if (portalNode) {\n    return /*#__PURE__*/createPortal(children, portalNode);\n  }\n\n  return null;\n};\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nconst identifier = 'data-floating-ui-scroll-lock';\n// Avoid Chrome DevTools blue warning\nfunction getPlatform() {\n  const uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.platform) {\n    return uaData.platform;\n  }\n\n  return navigator.platform;\n}\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */\n\nconst FloatingOverlay = /*#__PURE__*/React.forwardRef(function FloatingOverlay(_ref, ref) {\n  let {\n    lockScroll = false,\n    ...rest\n  } = _ref;\n  index(() => {\n    var _window$visualViewpor, _window$visualViewpor2, _window$visualViewpor3, _window$visualViewpor4;\n\n    if (!lockScroll) {\n      return;\n    }\n\n    const alreadyLocked = document.body.hasAttribute(identifier);\n\n    if (alreadyLocked) {\n      return;\n    }\n\n    document.body.setAttribute(identifier, ''); // RTL <body> scrollbar\n\n    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n    const paddingProp = scrollbarX ? 'paddingLeft' : 'paddingRight';\n    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth; // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n    // technique has fewer side effects.\n\n    if (!/iP(hone|ad|od)|iOS/.test(getPlatform())) {\n      Object.assign(document.body.style, {\n        overflow: 'hidden',\n        [paddingProp]: scrollbarWidth + \"px\"\n      });\n      return () => {\n        document.body.removeAttribute(identifier);\n        Object.assign(document.body.style, {\n          overflow: '',\n          [paddingProp]: ''\n        });\n      };\n    } // iOS 12 does not support `visuaViewport`.\n\n\n    const offsetLeft = (_window$visualViewpor = (_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetLeft) != null ? _window$visualViewpor : 0;\n    const offsetTop = (_window$visualViewpor3 = (_window$visualViewpor4 = window.visualViewport) == null ? void 0 : _window$visualViewpor4.offsetTop) != null ? _window$visualViewpor3 : 0;\n    const scrollX = window.pageXOffset;\n    const scrollY = window.pageYOffset;\n    Object.assign(document.body.style, {\n      position: 'fixed',\n      overflow: 'hidden',\n      top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n      left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n      right: '0',\n      [paddingProp]: scrollbarWidth + \"px\"\n    });\n    return () => {\n      Object.assign(document.body.style, {\n        position: '',\n        overflow: '',\n        top: '',\n        left: '',\n        right: '',\n        [paddingProp]: ''\n      });\n      document.body.removeAttribute(identifier);\n      window.scrollTo(scrollX, scrollY);\n    };\n  }, [lockScroll]);\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    ref: ref\n  }, rest, {\n    style: {\n      position: 'fixed',\n      overflow: 'auto',\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      ...rest.style\n    }\n  }));\n});\n\n/**\n * Find the real active element. Traverses into shadowRoots.\n */\nfunction activeElement(doc) {\n  let activeElement = doc.activeElement;\n\n  while (((_activeElement = activeElement) == null ? void 0 : (_activeElement$shadow = _activeElement.shadowRoot) == null ? void 0 : _activeElement$shadow.activeElement) != null) {\n    var _activeElement, _activeElement$shadow;\n\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n\n  return activeElement;\n}\n\nfunction getAncestors(nodes, id) {\n  var _nodes$find;\n\n  let allAncestors = [];\n  let currentParentId = (_nodes$find = nodes.find(node => node.id === id)) == null ? void 0 : _nodes$find.parentId;\n\n  while (currentParentId) {\n    const currentNode = nodes.find(node => node.id === currentParentId);\n    currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n\n    if (currentNode) {\n      allAncestors = allAncestors.concat(currentNode);\n    }\n  }\n\n  return allAncestors;\n}\n\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nfunction isTypeableElement(element) {\n  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);\n}\n\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\n\nfunction useLatestRef(value) {\n  const ref = useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\nfunction focus(el) {\n  // `pointerDown` clicks occur before `focus`, so the button will steal the\n  // focus unless we wait a frame.\n  requestAnimationFrame(() => {\n    el == null ? void 0 : el.focus();\n  });\n}\n\nconst SELECTOR = 'select:not([disabled]),a[href],button:not([disabled]),[tabindex],' + 'iframe,object,embed,area[href],audio[controls],video[controls],' + TYPEABLE_SELECTOR;\nconst FocusGuard = /*#__PURE__*/React.forwardRef(function FocusGuard(props, ref) {\n  return /*#__PURE__*/React.createElement(\"span\", _extends({}, props, {\n    ref: ref,\n    tabIndex: 0,\n    style: {\n      position: 'fixed',\n      opacity: '0',\n      pointerEvents: 'none',\n      outline: '0'\n    }\n  }));\n});\n\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */\nfunction FloatingFocusManager(_ref) {\n  let {\n    context: {\n      refs,\n      nodeId,\n      onOpenChange,\n      dataRef,\n      events\n    },\n    children,\n    order = ['content'],\n    endGuard = true,\n    preventTabbing = false,\n    initialFocus = 0,\n    returnFocus = true,\n    modal = true\n  } = _ref;\n  const orderRef = useLatestRef(order);\n  const onOpenChangeRef = useLatestRef(onOpenChange);\n  const tree = useFloatingTree();\n  const getTabbableElements = React.useCallback(() => {\n    return orderRef.current.map(type => {\n      if (type === 'reference') {\n        return refs.domReference.current;\n      }\n\n      if (refs.floating.current && type === 'floating') {\n        return refs.floating.current;\n      }\n\n      if (type === 'content') {\n        var _refs$floating$curren, _refs$floating$curren2;\n\n        return Array.from((_refs$floating$curren = (_refs$floating$curren2 = refs.floating.current) == null ? void 0 : _refs$floating$curren2.querySelectorAll(SELECTOR)) != null ? _refs$floating$curren : []);\n      }\n\n      return null;\n    }).flat().filter(el => {\n      if (el === refs.floating.current || el === refs.domReference.current) {\n        return true;\n      }\n\n      if (isHTMLElement(el)) {\n        var _el$getAttribute;\n\n        const tabIndex = (_el$getAttribute = el.getAttribute('tabindex')) != null ? _el$getAttribute : '0';\n        return tabIndex[0].trim() !== '-';\n      }\n    });\n  }, [orderRef, refs]);\n  React.useEffect(() => {\n    if (!modal) {\n      return;\n    } // If the floating element has no focusable elements inside it, fallback\n    // to focusing the floating element and preventing tab navigation\n\n\n    const noTabbableContentElements = getTabbableElements().filter(el => el !== refs.floating.current && el !== refs.domReference.current).length === 0;\n\n    function onKeyDown(event) {\n      if (event.key === 'Tab') {\n        if (preventTabbing || noTabbableContentElements) {\n          stopEvent(event);\n        }\n\n        const els = getTabbableElements();\n        const target = 'composedPath' in event ? event.composedPath()[0] : // TS thinks `event` is of type never as it assumes all browsers\n        // support composedPath, but browsers without shadow dom don't\n        event.target;\n\n        if (orderRef.current[0] === 'reference' && target === refs.domReference.current) {\n          stopEvent(event);\n\n          if (event.shiftKey) {\n            focus(els[els.length - 1]);\n          } else {\n            focus(els[1]);\n          }\n        }\n\n        if (orderRef.current[1] === 'floating' && target === refs.floating.current && event.shiftKey) {\n          stopEvent(event);\n          focus(els[0]);\n        }\n      }\n    }\n\n    const doc = getDocument(refs.floating.current);\n    doc.addEventListener('keydown', onKeyDown);\n    return () => {\n      doc.removeEventListener('keydown', onKeyDown);\n    };\n  }, [preventTabbing, modal, getTabbableElements, orderRef, refs]);\n  React.useEffect(() => {\n    function onFocusOut(event) {\n      var _refs$floating$curren3, _getAncestors;\n\n      const relatedTarget = event.relatedTarget;\n      const focusMovedOutsideFloating = !((_refs$floating$curren3 = refs.floating.current) != null && _refs$floating$curren3.contains(relatedTarget));\n      const focusMovedOutsideReference = isElement(refs.domReference.current) && !refs.domReference.current.contains(relatedTarget);\n      const isChildOpen = tree && getChildren(tree.nodesRef.current, nodeId).length > 0;\n      const isParentRelated = tree && event.currentTarget === refs.domReference.current && ((_getAncestors = getAncestors(tree.nodesRef.current, nodeId)) == null ? void 0 : _getAncestors.some(node => {\n        var _node$context, _node$context$refs$fl;\n\n        return (_node$context = node.context) == null ? void 0 : (_node$context$refs$fl = _node$context.refs.floating.current) == null ? void 0 : _node$context$refs$fl.contains(relatedTarget);\n      }));\n\n      if (focusMovedOutsideFloating && focusMovedOutsideReference && !isChildOpen && !isParentRelated) {\n        onOpenChangeRef.current(false);\n      }\n    }\n\n    const floating = refs.floating.current;\n    const reference = refs.domReference.current;\n\n    if (floating && isHTMLElement(reference)) {\n      !modal && floating.addEventListener('focusout', onFocusOut);\n      !modal && reference.addEventListener('focusout', onFocusOut);\n      let cleanup;\n\n      if (modal) {\n        if (orderRef.current.includes('reference')) {\n          cleanup = hideOthers([reference, floating]);\n        } else {\n          cleanup = hideOthers(floating);\n        }\n      }\n\n      return () => {\n        !modal && floating.removeEventListener('focusout', onFocusOut);\n        !modal && reference.removeEventListener('focusout', onFocusOut);\n        cleanup == null ? void 0 : cleanup();\n      };\n    }\n  }, [nodeId, tree, modal, onOpenChangeRef, orderRef, dataRef, getTabbableElements, refs]);\n  React.useEffect(() => {\n    if (preventTabbing) {\n      return;\n    }\n\n    let returnFocusValue = returnFocus;\n    const floating = refs.floating.current;\n    const previouslyFocusedElement = activeElement(getDocument(floating));\n\n    if (typeof initialFocus === 'number') {\n      var _getTabbableElements$;\n\n      focus((_getTabbableElements$ = getTabbableElements()[initialFocus]) != null ? _getTabbableElements$ : floating);\n    } else if (isHTMLElement(initialFocus == null ? void 0 : initialFocus.current)) {\n      var _initialFocus$current;\n\n      focus((_initialFocus$current = initialFocus.current) != null ? _initialFocus$current : floating);\n    } // Dismissing via outside `pointerdown` should always ignore `returnFocus`\n    // to prevent unwanted scrolling. The `esc` key will continue to focus the\n    // reference.\n\n\n    function onDismiss() {\n      returnFocusValue = false;\n    }\n\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n\n      if (returnFocusValue && isHTMLElement(previouslyFocusedElement)) {\n        focus(previouslyFocusedElement);\n      }\n    };\n  }, [preventTabbing, getTabbableElements, initialFocus, returnFocus, refs, events]);\n\n  const isTypeableCombobox = () => {\n    var _refs$domReference$cu;\n\n    return ((_refs$domReference$cu = refs.domReference.current) == null ? void 0 : _refs$domReference$cu.getAttribute('role')) === 'combobox' && isTypeableElement(refs.domReference.current);\n  };\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, modal && /*#__PURE__*/React.createElement(FocusGuard, {\n    onFocus: event => {\n      if (isTypeableCombobox()) {\n        return;\n      }\n\n      stopEvent(event);\n      const els = getTabbableElements();\n\n      if (order[0] === 'reference') {\n        focus(els[0]);\n      } else {\n        focus(els[els.length - 1]);\n      }\n    }\n  }), /*#__PURE__*/React.cloneElement(children, order.includes('floating') ? {\n    tabIndex: 0\n  } : {}), modal && endGuard && /*#__PURE__*/React.createElement(FocusGuard, {\n    onFocus: event => {\n      if (isTypeableCombobox()) {\n        return;\n      }\n\n      stopEvent(event);\n      focus(getTabbableElements()[0]);\n    }\n  }));\n}\n\nfunction usePrevious(value) {\n  const ref = useRef();\n  index(() => {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n\nfunction getDelay(value, prop, pointerType) {\n  if (pointerType && pointerType !== 'mouse') {\n    return 0;\n  }\n\n  if (typeof value === 'number') {\n    return value;\n  }\n\n  return value == null ? void 0 : value[prop];\n}\n\n/**\n * Adds hover event listeners that change the open state, like CSS :hover.\n * @see https://floating-ui.com/docs/useHover\n */\nconst useHover = function (context, _temp) {\n  let {\n    enabled = true,\n    delay = 0,\n    handleClose = null,\n    mouseOnly = false,\n    restMs = 0\n  } = _temp === void 0 ? {} : _temp;\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    events,\n    refs\n  } = context;\n  const tree = useFloatingTree();\n  const parentId = useFloatingParentNodeId();\n  const onOpenChangeRef = useLatestRef(onOpenChange);\n  const handleCloseRef = useLatestRef(handleClose);\n  const previousOpen = usePrevious(open);\n  const pointerTypeRef = React.useRef();\n  const timeoutRef = React.useRef();\n  const handlerRef = React.useRef();\n  const restTimeoutRef = React.useRef();\n  const blockMouseMoveRef = React.useRef(true);\n  const performedPointerEventsMutationRef = React.useRef(false);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    function onDismiss() {\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n      blockMouseMoveRef.current = true;\n    }\n\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n    };\n  }, [enabled, events, refs]);\n  React.useEffect(() => {\n    if (!enabled || !handleCloseRef.current) {\n      return;\n    }\n\n    function onLeave() {\n      var _dataRef$current$open;\n\n      if ((_dataRef$current$open = dataRef.current.openEvent) != null && _dataRef$current$open.type.includes('mouse')) {\n        onOpenChangeRef.current(false);\n      }\n    }\n\n    const html = getDocument(refs.floating.current).documentElement;\n    html.addEventListener('mouseleave', onLeave);\n    return () => {\n      html.removeEventListener('mouseleave', onLeave);\n    };\n  }, [refs, onOpenChangeRef, enabled, handleCloseRef, dataRef]);\n  const closeWithDelay = React.useCallback(function (runElseBranch) {\n    if (runElseBranch === void 0) {\n      runElseBranch = true;\n    }\n\n    const closeDelay = getDelay(delay, 'close', pointerTypeRef.current);\n\n    if (closeDelay && !handlerRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = setTimeout(() => onOpenChangeRef.current(false), closeDelay);\n    } else if (runElseBranch) {\n      clearTimeout(timeoutRef.current);\n      onOpenChangeRef.current(false);\n    }\n  }, [delay, onOpenChangeRef]);\n  const cleanupPointerMoveHandler = React.useCallback(() => {\n    if (handlerRef.current) {\n      getDocument(refs.floating.current).removeEventListener('pointermove', handlerRef.current);\n      handlerRef.current = undefined;\n    }\n  }, [refs]);\n  const clearPointerEvents = React.useCallback(() => {\n    getDocument(refs.floating.current).body.style.pointerEvents = '';\n    performedPointerEventsMutationRef.current = false;\n  }, [refs]); // Registering the mouse events on the reference directly to bypass React's\n  // delegation system. If the cursor was on a disabled element and then entered\n  // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    function onMouseEnter(event) {\n      clearTimeout(timeoutRef.current);\n      blockMouseMoveRef.current = false;\n\n      if (open || mouseOnly && pointerTypeRef.current !== 'mouse' || restMs > 0 && getDelay(delay, 'open') === 0) {\n        return;\n      }\n\n      dataRef.current.openEvent = event;\n      const openDelay = getDelay(delay, 'open', pointerTypeRef.current);\n\n      if (openDelay) {\n        timeoutRef.current = setTimeout(() => {\n          onOpenChangeRef.current(true);\n        }, openDelay);\n      } else {\n        onOpenChangeRef.current(true);\n      }\n    }\n\n    function onMouseLeave(event) {\n      var _dataRef$current$open2, _dataRef$current$open3;\n\n      if (((_dataRef$current$open2 = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open2.type) === 'click' || ((_dataRef$current$open3 = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open3.type) === 'pointerdown') {\n        return;\n      }\n\n      const doc = getDocument(refs.floating.current);\n      clearTimeout(restTimeoutRef.current);\n\n      if (handleCloseRef.current) {\n        clearTimeout(timeoutRef.current);\n        handlerRef.current && doc.removeEventListener('pointermove', handlerRef.current);\n        handlerRef.current = handleCloseRef.current({ ...context,\n          tree,\n          x: event.clientX,\n          y: event.clientY,\n\n          onClose() {\n            cleanupPointerMoveHandler();\n            closeWithDelay();\n          }\n\n        });\n        doc.addEventListener('pointermove', handlerRef.current);\n        return;\n      }\n\n      closeWithDelay();\n    } // Ensure the floating element closes after scrolling even if the pointer\n    // did not move.\n    // https://github.com/floating-ui/floating-ui/discussions/1692\n\n\n    function onScrollMouseLeave(event) {\n      handleCloseRef.current == null ? void 0 : handleCloseRef.current({ ...context,\n        tree,\n        x: event.clientX,\n        y: event.clientY,\n        leave: true,\n\n        onClose() {\n          cleanupPointerMoveHandler();\n          closeWithDelay();\n        }\n\n      })(event);\n    }\n\n    const floating = refs.floating.current;\n    const reference = refs.domReference.current;\n\n    if (isElement(reference)) {\n      open && reference.addEventListener('mouseleave', onScrollMouseLeave);\n      floating == null ? void 0 : floating.addEventListener('mouseleave', onScrollMouseLeave);\n      reference.addEventListener('mousemove', onMouseEnter, {\n        once: true\n      });\n      reference.addEventListener('mouseenter', onMouseEnter);\n      reference.addEventListener('mouseleave', onMouseLeave);\n      return () => {\n        open && reference.removeEventListener('mouseleave', onScrollMouseLeave);\n        floating == null ? void 0 : floating.removeEventListener('mouseleave', onScrollMouseLeave);\n        reference.removeEventListener('mousemove', onMouseEnter);\n        reference.removeEventListener('mouseenter', onMouseEnter);\n        reference.removeEventListener('mouseleave', onMouseLeave);\n      };\n    }\n  }, [enabled, closeWithDelay, context, delay, handleCloseRef, dataRef, mouseOnly, onOpenChangeRef, open, tree, restMs, cleanupPointerMoveHandler, refs]); // Block pointer-events of every element other than the reference and floating\n  // while the floating element is open and has a `handleClose` handler. Also\n  // handles nested floating elements.\n  // https://github.com/floating-ui/floating-ui/issues/1722\n\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n\n    if (open && handleCloseRef.current) {\n      getDocument(refs.floating.current).body.style.pointerEvents = 'none';\n      performedPointerEventsMutationRef.current = true;\n      const reference = refs.domReference.current;\n      const floating = refs.floating.current;\n\n      if (isHTMLElement(reference) && floating) {\n        var _tree$nodesRef$curren, _tree$nodesRef$curren2;\n\n        const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.refs.floating.current;\n\n        if (parentFloating) {\n          parentFloating.style.pointerEvents = '';\n        }\n\n        reference.style.pointerEvents = 'auto';\n        floating.style.pointerEvents = 'auto';\n        return () => {\n          reference.style.pointerEvents = '';\n          floating.style.pointerEvents = '';\n        };\n      }\n    }\n  }, [enabled, open, parentId, refs, tree, handleCloseRef, dataRef]);\n  index(() => {\n    if (previousOpen && !open) {\n      pointerTypeRef.current = undefined;\n      cleanupPointerMoveHandler();\n      clearPointerEvents();\n    }\n  });\n  React.useEffect(() => {\n    return () => {\n      cleanupPointerMoveHandler();\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n\n      if (performedPointerEventsMutationRef.current) {\n        clearPointerEvents();\n      }\n    };\n  }, [cleanupPointerMoveHandler, clearPointerEvents]);\n\n  if (!enabled) {\n    return {};\n  }\n\n  function setPointerRef(event) {\n    pointerTypeRef.current = event.pointerType;\n  }\n\n  return {\n    reference: {\n      onPointerDown: setPointerRef,\n      onPointerEnter: setPointerRef,\n\n      onMouseMove() {\n        if (open || restMs === 0) {\n          return;\n        }\n\n        clearTimeout(restTimeoutRef.current);\n        restTimeoutRef.current = setTimeout(() => {\n          if (!blockMouseMoveRef.current) {\n            onOpenChange(true);\n          }\n        }, restMs);\n      }\n\n    },\n    floating: {\n      onMouseEnter() {\n        clearTimeout(timeoutRef.current);\n      },\n\n      onMouseLeave() {\n        closeWithDelay(false);\n      }\n\n    }\n  };\n};\n\nconst FloatingDelayGroupContext = /*#__PURE__*/React.createContext({\n  delay: 1000,\n  initialDelay: 1000,\n  currentId: null,\n  setCurrentId: () => {},\n  setState: () => {}\n});\nconst useDelayGroupContext = () => React.useContext(FloatingDelayGroupContext);\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\n\nconst FloatingDelayGroup = _ref => {\n  let {\n    children,\n    delay\n  } = _ref;\n  const [state, setState] = React.useState({\n    delay,\n    initialDelay: delay,\n    currentId: null\n  });\n  const setCurrentId = React.useCallback(currentId => {\n    setState(state => ({ ...state,\n      currentId\n    }));\n  }, []);\n  return /*#__PURE__*/React.createElement(FloatingDelayGroupContext.Provider, {\n    value: React.useMemo(() => ({ ...state,\n      setState,\n      setCurrentId\n    }), [state, setState, setCurrentId])\n  }, children);\n};\nconst useDelayGroup = (_ref2, _ref3) => {\n  let {\n    open,\n    onOpenChange\n  } = _ref2;\n  let {\n    id\n  } = _ref3;\n  const {\n    currentId,\n    initialDelay,\n    setState\n  } = useDelayGroupContext();\n  const onOpenChangeRef = useLatestRef(onOpenChange);\n  React.useEffect(() => {\n    if (currentId && onOpenChangeRef.current) {\n      setState(state => ({ ...state,\n        delay: {\n          open: 1,\n          close: getDelay(initialDelay, 'close')\n        }\n      }));\n\n      if (currentId !== id) {\n        onOpenChangeRef.current(false);\n      }\n    }\n  }, [id, onOpenChangeRef, setState, currentId, initialDelay]);\n  React.useEffect(() => {\n    if (!open && currentId === id && onOpenChangeRef.current) {\n      onOpenChangeRef.current(false);\n      setState(state => ({ ...state,\n        delay: initialDelay,\n        currentId: null\n      }));\n    }\n  }, [open, setState, currentId, id, onOpenChangeRef, initialDelay]);\n};\n\n/**\n * Adds relevant screen reader props for a given element `role`.\n * @see https://floating-ui.com/docs/useRole\n */\nconst useRole = function (_ref, _temp) {\n  let {\n    open\n  } = _ref;\n  let {\n    enabled = true,\n    role = 'dialog'\n  } = _temp === void 0 ? {} : _temp;\n  const rootId = useId();\n  const referenceId = useId();\n  const floatingProps = {\n    id: rootId,\n    role\n  };\n\n  if (!enabled) {\n    return {};\n  }\n\n  if (role === 'tooltip') {\n    return {\n      reference: {\n        'aria-describedby': open ? rootId : undefined\n      },\n      floating: floatingProps\n    };\n  }\n\n  return {\n    reference: {\n      'aria-expanded': open ? 'true' : 'false',\n      'aria-haspopup': role,\n      'aria-controls': open ? rootId : undefined,\n      ...(role === 'listbox' && {\n        role: 'combobox'\n      }),\n      ...(role === 'menu' && {\n        id: referenceId\n      })\n    },\n    floating: { ...floatingProps,\n      ...(role === 'menu' && {\n        'aria-labelledby': referenceId\n      })\n    }\n  };\n};\n\n/**\n * Adds click event listeners that change the open state.\n * @see https://floating-ui.com/docs/useClick\n */\nconst useClick = function (_ref, _temp) {\n  let {\n    open,\n    onOpenChange,\n    dataRef,\n    refs\n  } = _ref;\n  let {\n    enabled = true,\n    pointerDown = false,\n    toggle = true,\n    ignoreMouse = false\n  } = _temp === void 0 ? {} : _temp;\n  const pointerTypeRef = React.useRef();\n\n  function isButton() {\n    var _refs$domReference$cu;\n\n    return ((_refs$domReference$cu = refs.domReference.current) == null ? void 0 : _refs$domReference$cu.tagName) === 'BUTTON';\n  }\n\n  function isSpaceIgnored() {\n    return isTypeableElement(refs.domReference.current);\n  }\n\n  if (!enabled) {\n    return {};\n  }\n\n  return {\n    reference: {\n      onPointerDown(event) {\n        // Ignore all buttons except for the \"main\" button.\n        // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n        if (event.button !== 0) {\n          return;\n        }\n\n        pointerTypeRef.current = event.pointerType;\n\n        if (pointerTypeRef.current === 'mouse' && ignoreMouse) {\n          return;\n        }\n\n        if (!pointerDown) {\n          return;\n        }\n\n        if (open) {\n          if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'pointerdown' : true)) {\n            onOpenChange(false);\n          }\n        } else {\n          onOpenChange(true);\n        }\n\n        dataRef.current.openEvent = event.nativeEvent;\n      },\n\n      onClick(event) {\n        if (pointerDown && pointerTypeRef.current) {\n          pointerTypeRef.current = undefined;\n          return;\n        }\n\n        if (pointerTypeRef.current === 'mouse' && ignoreMouse) {\n          return;\n        }\n\n        if (open) {\n          if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'click' : true)) {\n            onOpenChange(false);\n          }\n        } else {\n          onOpenChange(true);\n        }\n\n        dataRef.current.openEvent = event.nativeEvent;\n      },\n\n      onKeyDown(event) {\n        pointerTypeRef.current = undefined;\n\n        if (isButton()) {\n          return;\n        }\n\n        if (event.key === ' ' && !isSpaceIgnored()) {\n          // Prvent scrolling\n          event.preventDefault();\n        }\n\n        if (event.key === 'Enter') {\n          if (open) {\n            if (toggle) {\n              onOpenChange(false);\n            }\n          } else {\n            onOpenChange(true);\n          }\n        }\n      },\n\n      onKeyUp(event) {\n        if (isButton() || isSpaceIgnored()) {\n          return;\n        }\n\n        if (event.key === ' ') {\n          if (open) {\n            if (toggle) {\n              onOpenChange(false);\n            }\n          } else {\n            onOpenChange(true);\n          }\n        }\n      }\n\n    }\n  };\n};\n\n/**\n * Check whether the event.target is within the provided node. Uses event.composedPath if available for custom element support.\n *\n * @param event The event whose target/composedPath to check\n * @param node The node to check against\n * @returns Whether the event.target/composedPath is within the node.\n */\nfunction isEventTargetWithin(event, node) {\n  if (node == null) {\n    return false;\n  }\n\n  if ('composedPath' in event) {\n    return event.composedPath().includes(node);\n  } // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n\n\n  const e = event;\n  return e.target != null && node.contains(e.target);\n}\n\n/**\n * Adds listeners that dismiss (close) the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */\nconst useDismiss = function (_ref, _temp) {\n  let {\n    open,\n    onOpenChange,\n    refs,\n    events,\n    nodeId\n  } = _ref;\n  let {\n    enabled = true,\n    escapeKey = true,\n    outsidePointerDown = true,\n    referencePointerDown = false,\n    ancestorScroll = false,\n    bubbles = true\n  } = _temp === void 0 ? {} : _temp;\n  const tree = useFloatingTree();\n  const onOpenChangeRef = useLatestRef(onOpenChange);\n  const isFocusInsideFloating = React.useCallback(() => {\n    var _refs$floating$curren;\n\n    return (_refs$floating$curren = refs.floating.current) == null ? void 0 : _refs$floating$curren.contains(activeElement(getDocument(refs.floating.current)));\n  }, [refs]);\n  React.useEffect(() => {\n    if (!open || !enabled) {\n      return;\n    }\n\n    function onKeyDown(event) {\n      if (event.key === 'Escape') {\n        if (!bubbles && !isFocusInsideFloating()) {\n          return;\n        }\n\n        events.emit('dismiss');\n        onOpenChangeRef.current(false);\n\n        if (isHTMLElement(refs.domReference.current)) {\n          refs.domReference.current.focus();\n        }\n      }\n    }\n\n    function onPointerDown(event) {\n      const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n        var _node$context;\n\n        return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.refs.floating.current);\n      });\n\n      if (isEventTargetWithin(event, refs.floating.current) || isEventTargetWithin(event, refs.domReference.current) || targetIsInsideChildren) {\n        return;\n      }\n\n      if (!bubbles && !isFocusInsideFloating()) {\n        return;\n      }\n\n      events.emit('dismiss');\n      onOpenChangeRef.current(false);\n    }\n\n    function onScroll() {\n      onOpenChangeRef.current(false);\n    }\n\n    const doc = getDocument(refs.floating.current);\n    escapeKey && doc.addEventListener('keydown', onKeyDown); // Use `mousedown` instead of `pointerdown` as it acts more like a click\n    // on touch devices than a `touchstart` (which can result in accidental\n    // dismissals too easily.)\n\n    outsidePointerDown && doc.addEventListener('mousedown', onPointerDown);\n    const ancestors = (ancestorScroll ? [...(isElement(refs.reference.current) ? getOverflowAncestors(refs.reference.current) : []), ...(isElement(refs.floating.current) ? getOverflowAncestors(refs.floating.current) : [])] : []).filter(ancestor => {\n      var _doc$defaultView;\n\n      return (// Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n        ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport)\n      );\n    });\n    ancestors.forEach(ancestor => ancestor.addEventListener('scroll', onScroll, {\n      passive: true\n    }));\n    return () => {\n      escapeKey && doc.removeEventListener('keydown', onKeyDown);\n      outsidePointerDown && doc.removeEventListener('mousedown', onPointerDown);\n      ancestors.forEach(ancestor => ancestor.removeEventListener('scroll', onScroll));\n    };\n  }, [escapeKey, outsidePointerDown, events, tree, nodeId, open, onOpenChangeRef, ancestorScroll, enabled, bubbles, isFocusInsideFloating, refs]);\n\n  if (!enabled) {\n    return {};\n  }\n\n  return {\n    reference: {\n      onPointerDown() {\n        if (referencePointerDown) {\n          events.emit('dismiss');\n          onOpenChange(false);\n        }\n      }\n\n    }\n  };\n};\n\n/**\n * Adds focus event listeners that change the open state, like CSS :focus.\n * @see https://floating-ui.com/docs/useFocus\n */\nconst useFocus = function (_ref, _temp) {\n  let {\n    open,\n    onOpenChange,\n    dataRef,\n    refs,\n    events\n  } = _ref;\n  let {\n    enabled = true,\n    keyboardOnly = true\n  } = _temp === void 0 ? {} : _temp;\n  const pointerTypeRef = React.useRef('');\n  const blockFocusRef = React.useRef(false);\n  React.useEffect(() => {\n    var _doc$defaultView;\n\n    if (!enabled) {\n      return;\n    }\n\n    const doc = getDocument(refs.floating.current);\n    const win = (_doc$defaultView = doc.defaultView) != null ? _doc$defaultView : window;\n\n    function onBlur() {\n      if (pointerTypeRef.current && refs.domReference.current === activeElement(doc)) {\n        blockFocusRef.current = !open;\n      }\n    }\n\n    function onFocus() {\n      setTimeout(() => {\n        blockFocusRef.current = false;\n        pointerTypeRef.current = '';\n      });\n    }\n\n    win.addEventListener('focus', onFocus);\n    win.addEventListener('blur', onBlur);\n    return () => {\n      win.removeEventListener('focus', onFocus);\n      win.removeEventListener('blur', onBlur);\n    };\n  }, [refs, open, enabled]);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    function onDismiss() {\n      blockFocusRef.current = true;\n    }\n\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n    };\n  }, [events, enabled]);\n\n  if (!enabled) {\n    return {};\n  }\n\n  return {\n    reference: {\n      onPointerDown(_ref2) {\n        let {\n          pointerType\n        } = _ref2;\n        pointerTypeRef.current = pointerType;\n        blockFocusRef.current = !!(pointerType && keyboardOnly);\n      },\n\n      onFocus(event) {\n        var _dataRef$current$open, _refs$domReference$cu, _dataRef$current$open2;\n\n        if (blockFocusRef.current) {\n          return;\n        } // Dismiss with click should ignore the subsequent `focus` trigger, but\n        // only if the click originated inside the reference element.\n\n\n        if (event.type === 'focus' && ((_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type) === 'mousedown' && (_refs$domReference$cu = refs.domReference.current) != null && _refs$domReference$cu.contains((_dataRef$current$open2 = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open2.target)) {\n          return;\n        }\n\n        dataRef.current.openEvent = event.nativeEvent;\n        onOpenChange(true);\n      },\n\n      onBlur(event) {\n        var _refs$floating$curren, _refs$domReference$cu2;\n\n        const target = event.relatedTarget; // When focusing the reference element (e.g. regular click), then\n        // clicking into the floating element, prevent it from hiding.\n        // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n\n        if ((_refs$floating$curren = refs.floating.current) != null && _refs$floating$curren.contains(target) || (_refs$domReference$cu2 = refs.domReference.current) != null && _refs$domReference$cu2.contains(target)) {\n          return;\n        }\n\n        blockFocusRef.current = false;\n        onOpenChange(false);\n      }\n\n    }\n  };\n};\n\nconst ARROW_UP = 'ArrowUp';\nconst ARROW_DOWN = 'ArrowDown';\nconst ARROW_LEFT = 'ArrowLeft';\nconst ARROW_RIGHT = 'ArrowRight';\n\nfunction isIndexOutOfBounds(listRef, index) {\n  return index < 0 || index >= listRef.current.length;\n}\n\nfunction findNonDisabledIndex(listRef, _temp) {\n  let {\n    startingIndex = -1,\n    decrement = false,\n    disabledIndices\n  } = _temp === void 0 ? {} : _temp;\n  const list = listRef.current;\n  let index = startingIndex;\n\n  do {\n    var _list$index, _list$index2;\n\n    index = index + (decrement ? -1 : 1);\n  } while (index >= 0 && index <= list.length - 1 && (disabledIndices ? disabledIndices.includes(index) : list[index] == null || ((_list$index = list[index]) == null ? void 0 : _list$index.hasAttribute('disabled')) || ((_list$index2 = list[index]) == null ? void 0 : _list$index2.getAttribute('aria-disabled')) === 'true'));\n\n  return index;\n}\n\nfunction doSwitch(orientation, vertical, horizontal) {\n  switch (orientation) {\n    case 'vertical':\n      return vertical;\n\n    case 'horizontal':\n      return horizontal;\n\n    default:\n      return vertical || horizontal;\n  }\n}\n\nfunction isMainOrientationKey(key, orientation) {\n  const vertical = key === ARROW_UP || key === ARROW_DOWN;\n  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal);\n}\n\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n  const vertical = key === ARROW_DOWN;\n  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key == ' ' || key === '';\n}\n\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  const horizontal = key === ARROW_DOWN;\n  return doSwitch(orientation, vertical, horizontal);\n}\n\nfunction isCrossOrientationCloseKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n  const horizontal = key === ARROW_UP;\n  return doSwitch(orientation, vertical, horizontal);\n}\n\nfunction getMinIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    disabledIndices\n  });\n}\n\nfunction getMaxIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    decrement: true,\n    startingIndex: listRef.current.length,\n    disabledIndices\n  });\n}\n\n/**\n * Adds focus-managed indexed navigation via arrow keys to a list of items\n * within the floating element.\n * @see https://floating-ui.com/docs/useListNavigation\n */\nconst useListNavigation = function (_ref, _temp2) {\n  let {\n    open,\n    onOpenChange,\n    refs\n  } = _ref;\n  let {\n    listRef,\n    activeIndex,\n    onNavigate,\n    enabled = true,\n    selectedIndex = null,\n    allowEscape = false,\n    loop = false,\n    nested = false,\n    rtl = false,\n    virtual = false,\n    focusItemOnOpen = 'auto',\n    focusItemOnHover = true,\n    openOnArrowKeyDown = true,\n    disabledIndices = openOnArrowKeyDown ? undefined : [],\n    orientation = 'vertical'\n  } = _temp2 === void 0 ? {\n    listRef: {\n      current: []\n    },\n    activeIndex: null,\n    onNavigate: () => {}\n  } : _temp2;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (allowEscape) {\n      if (!loop) {\n        console.warn(['Floating UI: `useListNavigation` looping must be enabled to allow', 'escaping.'].join(' '));\n      }\n\n      if (!virtual) {\n        console.warn(['Floating UI: `useListNavigation` must be virtual to allow', 'escaping.'].join(' '));\n      }\n    }\n  }\n\n  const parentId = useFloatingParentNodeId();\n  const tree = useFloatingTree();\n  const previousOpen = usePrevious(open);\n  const focusItemOnOpenRef = React.useRef(focusItemOnOpen);\n  const indexRef = React.useRef(selectedIndex != null ? selectedIndex : -1);\n  const keyRef = React.useRef(null);\n  const previousOnNavigateRef = useLatestRef(usePrevious(onNavigate));\n  const onNavigateRef = useLatestRef(onNavigate);\n  const disabledIndicesRef = useLatestRef(disabledIndices);\n  const blockPointerLeaveRef = React.useRef(false);\n  const frameRef = React.useRef(-1);\n  const [activeId, setActiveId] = React.useState();\n  const focusItem = React.useCallback((listRef, indexRef) => {\n    // `pointerDown` clicks occur before `focus`, so the button will steal the\n    // focus unless we wait a frame.\n    frameRef.current = requestAnimationFrame(() => {\n      if (virtual) {\n        var _listRef$current$inde;\n\n        setActiveId((_listRef$current$inde = listRef.current[indexRef.current]) == null ? void 0 : _listRef$current$inde.id);\n      } else {\n        var _listRef$current$inde2;\n\n        (_listRef$current$inde2 = listRef.current[indexRef.current]) == null ? void 0 : _listRef$current$inde2.focus({\n          preventScroll: true\n        });\n      }\n    });\n  }, [virtual]); // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n  // element. Also, reset `activeIndex` upon closing the floating element.\n\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n\n    if (!previousOpen && open && focusItemOnOpenRef.current && selectedIndex != null) {\n      onNavigateRef.current(selectedIndex);\n    } // Unset `activeIndex`. Since the user can specify `onNavigate`\n    // conditionally (onNavigate: open ? setActiveIndex : setSelectedIndex)\n    // we store and call the previous function\n\n\n    if (previousOpen && !open) {\n      cancelAnimationFrame(frameRef.current);\n      indexRef.current = -1;\n      previousOnNavigateRef.current == null ? void 0 : previousOnNavigateRef.current(null);\n    }\n  }, [open, previousOpen, selectedIndex, listRef, onNavigateRef, previousOnNavigateRef, focusItem, enabled]); // Sync `activeIndex` to be the focused item while the floating element is\n  // open.\n\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n\n    if (open) {\n      if (activeIndex == null) {\n        if (selectedIndex != null) {\n          return;\n        } // Reset while the floating element was open (e.g. the list changed).\n\n\n        if (previousOpen) {\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n        } // Initial sync\n\n\n        if (!previousOpen && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n          indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n          onNavigateRef.current(indexRef.current);\n          focusItem(listRef, indexRef);\n        }\n      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n        indexRef.current = activeIndex;\n        focusItem(listRef, indexRef);\n      }\n    }\n  }, [open, previousOpen, activeIndex, selectedIndex, nested, listRef, onNavigateRef, focusItem, enabled, allowEscape, orientation, rtl, virtual, disabledIndicesRef]); // Return focus to the reference element when `selectedIndex` is a number and\n  // the floating element closes.\n\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n\n    if (!open && previousOpen && selectedIndex != null && isHTMLElement(refs.domReference.current)) {\n      refs.domReference.current.focus();\n    }\n  }, [refs, selectedIndex, open, previousOpen, enabled]); // Ensure the parent floating element has focus when a nested child closes\n  // to allow arrow key navigation to work after the pointer leaves the child.\n\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n\n    if (!open && previousOpen) {\n      var _tree$nodesRef$curren, _tree$nodesRef$curren2;\n\n      const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.refs.floating.current;\n\n      if (parentFloating && !parentFloating.contains(activeElement(getDocument(parentFloating)))) {\n        parentFloating.focus({\n          preventScroll: true\n        });\n      }\n    }\n  }, [enabled, open, previousOpen, tree, parentId]);\n  index(() => {\n    keyRef.current = null;\n  });\n\n  function onKeyDown(event) {\n    blockPointerLeaveRef.current = true;\n\n    if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n      stopEvent(event);\n      onOpenChange(false);\n\n      if (isHTMLElement(refs.domReference.current)) {\n        refs.domReference.current.focus();\n      }\n\n      return;\n    }\n\n    const currentIndex = indexRef.current;\n    const minIndex = getMinIndex(listRef, disabledIndices);\n    const maxIndex = getMaxIndex(listRef, disabledIndices);\n\n    if (event.key === 'Home') {\n      indexRef.current = minIndex;\n      onNavigate(indexRef.current);\n    }\n\n    if (event.key === 'End') {\n      indexRef.current = maxIndex;\n      onNavigate(indexRef.current);\n    }\n\n    if (isMainOrientationKey(event.key, orientation)) {\n      stopEvent(event); // Reset the index if no item is focused.\n\n      if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {\n        indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n        onNavigate(indexRef.current);\n        return;\n      }\n\n      if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n        if (loop) {\n          indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n            startingIndex: currentIndex,\n            disabledIndices\n          });\n        } else {\n          indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n            startingIndex: currentIndex,\n            disabledIndices\n          }));\n        }\n      } else {\n        if (loop) {\n          indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n            startingIndex: currentIndex,\n            decrement: true,\n            disabledIndices\n          });\n        } else {\n          indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n            startingIndex: currentIndex,\n            decrement: true,\n            disabledIndices\n          }));\n        }\n      }\n\n      if (isIndexOutOfBounds(listRef, indexRef.current)) {\n        onNavigate(null);\n      } else {\n        onNavigate(indexRef.current);\n      }\n    }\n  }\n\n  if (!enabled) {\n    return {};\n  }\n\n  return {\n    reference: { ...(virtual && open && activeIndex != null && {\n        'aria-activedescendant': activeId\n      }),\n\n      onKeyDown(event) {\n        blockPointerLeaveRef.current = true;\n\n        if (virtual && open) {\n          return onKeyDown(event);\n        }\n\n        const isNavigationKey = event.key.indexOf('Arrow') === 0 || event.key === 'Enter' || event.key === ' ' || event.key === '';\n\n        if (isNavigationKey) {\n          keyRef.current = event.key;\n        }\n\n        if (nested) {\n          if (isCrossOrientationOpenKey(event.key, orientation, rtl)) {\n            stopEvent(event);\n\n            if (open) {\n              indexRef.current = getMinIndex(listRef, disabledIndices);\n              onNavigate(indexRef.current);\n            } else {\n              onOpenChange(true);\n            }\n          }\n\n          return;\n        }\n\n        if (isMainOrientationKey(event.key, orientation)) {\n          if (selectedIndex != null) {\n            indexRef.current = selectedIndex;\n          }\n\n          stopEvent(event);\n\n          if (!open && openOnArrowKeyDown) {\n            onOpenChange(true);\n          } else {\n            onKeyDown(event);\n          }\n\n          if (open) {\n            onNavigate(indexRef.current);\n          }\n        }\n      }\n\n    },\n    floating: {\n      'aria-orientation': orientation === 'both' ? undefined : orientation,\n      ...(virtual && activeIndex != null && {\n        'aria-activedescendant': activeId\n      }),\n      onKeyDown,\n\n      onPointerMove() {\n        blockPointerLeaveRef.current = false;\n      }\n\n    },\n    item: {\n      onFocus(_ref2) {\n        let {\n          currentTarget\n        } = _ref2;\n        const index = listRef.current.indexOf(currentTarget);\n\n        if (index !== -1) {\n          onNavigate(index);\n        }\n      },\n\n      onClick: _ref3 => {\n        let {\n          currentTarget\n        } = _ref3;\n        return currentTarget.focus({\n          preventScroll: true\n        });\n      },\n      // Safari\n      ...(focusItemOnHover && {\n        onMouseMove(_ref4) {\n          let {\n            currentTarget\n          } = _ref4;\n          const target = currentTarget;\n\n          if (target) {\n            const index = listRef.current.indexOf(target);\n\n            if (index !== -1) {\n              onNavigate(index);\n            }\n          }\n        },\n\n        onMouseLeave() {\n          if (!blockPointerLeaveRef.current) {\n            indexRef.current = -1;\n            focusItem(listRef, indexRef);\n            onNavigateRef.current(null);\n\n            if (!virtual) {\n              var _refs$floating$curren;\n\n              (_refs$floating$curren = refs.floating.current) == null ? void 0 : _refs$floating$curren.focus({\n                preventScroll: true\n              });\n            }\n          }\n        }\n\n      })\n    }\n  };\n};\n\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */\nconst useTypeahead = function (_ref, _temp) {\n  var _ref2;\n\n  let {\n    open,\n    dataRef\n  } = _ref;\n  let {\n    listRef,\n    activeIndex,\n    onMatch = () => {},\n    enabled = true,\n    findMatch = null,\n    resetMs = 1000,\n    ignoreKeys = [],\n    selectedIndex = null\n  } = _temp === void 0 ? {\n    listRef: {\n      current: []\n    },\n    activeIndex: null\n  } : _temp;\n  const timeoutIdRef = React.useRef();\n  const stringRef = React.useRef('');\n  const prevIndexRef = React.useRef((_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1);\n  const matchIndexRef = React.useRef(null);\n  index(() => {\n    if (open) {\n      clearTimeout(timeoutIdRef.current);\n      matchIndexRef.current = null;\n      stringRef.current = '';\n    }\n  }, [open]);\n  index(() => {\n    // Sync arrow key navigation but not typeahead navigation\n    if (open && stringRef.current === '') {\n      var _ref3;\n\n      prevIndexRef.current = (_ref3 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref3 : -1;\n    }\n  }, [open, selectedIndex, activeIndex]);\n\n  function onKeyDown(event) {\n    if (!event.currentTarget.contains(activeElement(getDocument(event.currentTarget)))) {\n      return;\n    }\n\n    if (stringRef.current.length > 0 && stringRef.current[0] !== ' ') {\n      dataRef.current.typing = true;\n\n      if (event.key === ' ') {\n        stopEvent(event);\n      }\n    }\n\n    const listContent = listRef.current;\n\n    if (listContent == null || ['Home', 'End', 'Escape', 'Enter', 'Tab', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ...ignoreKeys].includes(event.key)) {\n      return;\n    } // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n    // allow it in this case, too.\n\n\n    const allowRapidSuccessionOfFirstLetter = listContent.every(text => {\n      var _text$, _text$2;\n\n      return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n    }); // Allows the user to cycle through items that start with the same letter\n    // in rapid succession\n\n    if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n      stringRef.current = '';\n      prevIndexRef.current = matchIndexRef.current;\n    }\n\n    stringRef.current += event.key;\n    clearTimeout(timeoutIdRef.current);\n    timeoutIdRef.current = setTimeout(() => {\n      stringRef.current = '';\n      prevIndexRef.current = matchIndexRef.current;\n      dataRef.current.typing = false;\n    }, resetMs);\n    const prevIndex = prevIndexRef.current;\n    const orderedList = [...listContent.slice((prevIndex != null ? prevIndex : 0) + 1), ...listContent.slice(0, (prevIndex != null ? prevIndex : 0) + 1)];\n    const str = findMatch ? findMatch(orderedList, stringRef.current) : orderedList.find(text => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(stringRef.current)) === 0);\n    const index = str ? listContent.indexOf(str) : -1;\n\n    if (index !== -1) {\n      onMatch(index);\n      matchIndexRef.current = index;\n    }\n  }\n\n  if (!enabled) {\n    return {};\n  }\n\n  return {\n    reference: {\n      onKeyDown\n    },\n    floating: {\n      onKeyDown\n    }\n  };\n};\n\nexport { FloatingDelayGroup, FloatingFocusManager, FloatingNode, FloatingOverlay, FloatingPortal, FloatingTree, safePolygon, useClick, useDelayGroup, useDelayGroupContext, useDismiss, useFloating, useFloatingNodeId, useFloatingParentNodeId, useFloatingPortalNode, useFloatingTree, useFocus, useHover, useId, useInteractions, useListNavigation, useRole, useTypeahead };\n", "import { useFloating, offset, flip, shift, autoUpdate, useInteractions } from '@floating-ui/react-dom-interactions';\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, safePolygon, shift, size, useClick, useDelayGroup, useDelayGroupContext, useDismiss, useFloating, useFloatingNodeId, useFloatingParentNodeId, useFloatingPortalNode, useFloatingTree, useFocus, useHover, useId, useInteractions, useListNavigation, useRole, useTypeahead } from '@floating-ui/react-dom-interactions';\nimport React, { cloneElement, useRef, useState, useLayoutEffect } from 'react';\nimport { createElementAs, usePlateEditorState, isCollapsed, toDOMRange } from '@udecode/plate-core';\nimport { useReadOnly, useSelected } from 'slate-react';\n\nconst getDefaultBoundingClientRect = () => ({\n  width: 0,\n  height: 0,\n  x: 0,\n  y: 0,\n  top: -9999,\n  left: -9999,\n  right: 9999,\n  bottom: 9999\n});\nconst createVirtualElement = () => ({\n  getBoundingClientRect: getDefaultBoundingClientRect\n});\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n/**\n * Popover displayed over children, rendering `content`\n */\nconst Popover = ({\n  floatingOptions,\n  children,\n  content,\n  ...props\n}) => {\n  const {\n    x,\n    y,\n    reference,\n    floating,\n    strategy\n  } = useFloating({\n    middleware: [offset(12), flip({\n      padding: 96\n    }), shift()],\n    whileElementsMounted: autoUpdate,\n    ...floatingOptions\n  });\n  const {\n    getReferenceProps\n  } = useInteractions();\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/cloneElement(children, getReferenceProps({\n    ref: reference,\n    ...children.props\n  })), (floatingOptions === null || floatingOptions === void 0 ? void 0 : floatingOptions.open) && createElementAs('div', {\n    ref: floating,\n    style: {\n      position: strategy,\n      top: y !== null && y !== void 0 ? y : 0,\n      left: x !== null && x !== void 0 ? x : 0,\n      zIndex: 1\n    },\n    contentEditable: false,\n    children: content,\n    ...props\n  }));\n};\n\n/**\n * Popover displayed over an element if:\n * - not read-only\n * - element selected\n */\n\nconst ElementPopover = ({\n  floatingOptions = {},\n  ...props\n}) => {\n  const readOnly = useReadOnly();\n  const selected = useSelected();\n  const editor = usePlateEditorState();\n  return /*#__PURE__*/React.createElement(Popover, _extends({\n    floatingOptions: {\n      open: !readOnly && selected && isCollapsed(editor.selection),\n      ...floatingOptions\n    }\n  }, props));\n};\n\n/**\n * Get bounding client rect by slate range\n */\n\nconst getRangeBoundingClientRect = (editor, at) => {\n  if (!at) return getDefaultBoundingClientRect();\n  const domRange = toDOMRange(editor, at);\n  if (!domRange) return getDefaultBoundingClientRect();\n  return domRange.getBoundingClientRect();\n};\n\n/**\n * Get bounding client rect of the window selection\n */\n\nconst getSelectionBoundingClientRect = () => {\n  const domSelection = window.getSelection();\n\n  if (!domSelection || domSelection.rangeCount < 1) {\n    return getDefaultBoundingClientRect();\n  }\n\n  const domRange = domSelection.getRangeAt(0);\n  return domRange.getBoundingClientRect();\n};\n\n/**\n * `useFloating` with a controlled virtual element. Used to follow cursor position.\n *\n * Default options:\n * - `whileElementsMounted: autoUpdate`\n *\n * Additional options:\n * - `getBoundingClientRect` to get the bounding client rect.\n * - `hidden` to hide the floating element\n *\n * Additional returns:\n * - `style` to apply to the floating element\n * - `virtualElementRef`\n *\n * @see useFloating\n * @see https://floating-ui.com/docs/react-dom#virtual-element\n */\nconst useVirtualFloating = ({\n  getBoundingClientRect = getSelectionBoundingClientRect,\n  ...floatingOptions\n}) => {\n  const virtualElementRef = useRef(createVirtualElement());\n  const [visible, setVisible] = useState(true);\n  const floatingResult = useFloating({\n    // update on scroll and resize\n    whileElementsMounted: autoUpdate,\n    ...floatingOptions\n  });\n  const {\n    reference,\n    middlewareData,\n    strategy,\n    x,\n    y,\n    update\n  } = floatingResult;\n  useLayoutEffect(() => {\n    virtualElementRef.current.getBoundingClientRect = getBoundingClientRect;\n  }, [getBoundingClientRect, update]);\n  useLayoutEffect(() => {\n    reference(virtualElementRef.current);\n  }, [reference]);\n  useLayoutEffect(() => {\n    if (!(middlewareData !== null && middlewareData !== void 0 && middlewareData.hide)) return;\n    const {\n      referenceHidden\n    } = middlewareData.hide;\n    setVisible(!referenceHidden);\n  }, [middlewareData.hide]);\n  return { ...floatingResult,\n    virtualElementRef,\n    style: {\n      position: strategy,\n      top: y !== null && y !== void 0 ? y : 0,\n      left: x !== null && x !== void 0 ? x : 0,\n      display: floatingOptions.open === false ? 'none' : undefined,\n      visibility: !visible ? 'hidden' : undefined\n    }\n  };\n};\n\nexport { ElementPopover, Popover, createVirtualElement, getDefaultBoundingClientRect, getRangeBoundingClientRect, getSelectionBoundingClientRect, useVirtualFloating };\n//# sourceMappingURL=index.es.js.map\n", "import {\n  focusEditor,\n  getPluginOptions,\n  PlateEditor,\n  Value,\n} from '@udecode/plate-core';\nimport {\n  floatingLinkActions,\n  floatingLinkSelectors,\n} from '../components/FloatingLink/floatingLinkStore';\nimport { ELEMENT_LINK, LinkPlugin } from '../createLinkPlugin';\nimport { upsertLink } from './index';\n\n/**\n * Insert link if url is valid.\n * Text is url if empty.\n * Close floating link.\n * Focus editor.\n */\nexport const submitFloatingLink = <V extends Value>(editor: PlateEditor<V>) => {\n  if (!editor.selection) return;\n\n  const { isUrl, forceSubmit } = getPluginOptions<LinkPlugin, V>(\n    editor,\n    ELEMENT_LINK\n  );\n\n  const url = floatingLinkSelectors.url();\n  const isValid = isUrl?.(url) || forceSubmit;\n  if (!isValid) return;\n\n  const text = floatingLinkSelectors.text();\n  const target = floatingLinkSelectors.newTab() ? undefined : '_self';\n\n  floatingLinkActions.hide();\n\n  upsertLink(editor, {\n    url,\n    text,\n    target,\n    isUrl: (_url) => (forceSubmit || !isUrl ? true : isUrl(_url)),\n  });\n\n  setTimeout(() => {\n    focusEditor(editor, editor.selection!);\n  }, 0);\n\n  return true;\n};\n", "import { useEditorRef, useHotkeys } from '@udecode/plate-core';\nimport { submitFloatingLink } from '../../transforms/submitFloatingLink';\nimport { useFloatingLinkSelectors } from './floatingLinkStore';\n\nexport const useFloatingLinkEnter = () => {\n  const editor = useEditorRef();\n\n  const open = useFloatingLinkSelectors().isOpen(editor.id);\n\n  useHotkeys(\n    '*',\n    (e) => {\n      if (e.key !== 'Enter') return;\n\n      if (submitFloatingLink(editor)) {\n        e.preventDefault();\n      }\n    },\n    {\n      enabled: open,\n      enableOnFormTags: ['INPUT'],\n    },\n    []\n  );\n};\n", "import { focusEditor, useEditorRef, useHotkeys } from '@udecode/plate-core';\nimport {\n  floatingLinkActions,\n  floatingLinkSelectors,\n  useFloatingLinkSelectors,\n} from './floatingLinkStore';\n\nexport const useFloatingLinkEscape = () => {\n  const editor = useEditorRef();\n\n  const open = useFloatingLinkSelectors().isOpen(editor.id);\n\n  useHotkeys(\n    'escape',\n    (e) => {\n      if (!floatingLinkSelectors.mode()) return;\n\n      e.preventDefault();\n\n      if (\n        floatingLinkSelectors.mode() === 'edit' &&\n        floatingLinkSelectors.isEditing()\n      ) {\n        floatingLinkActions.show('edit', editor.id);\n        focusEditor(editor, editor.selection!);\n        return;\n      }\n\n      if (floatingLinkSelectors.mode() === 'insert') {\n        focusEditor(editor, editor.selection!);\n      }\n\n      floatingLinkActions.hide();\n    },\n    {\n      enabled: open,\n      enableOnFormTags: ['INPUT'],\n      enableOnContentEditable: true,\n    },\n    []\n  );\n};\n", "import {\n  flip,\n  offset,\n  useVirtualFloating,\n  UseVirtualFloatingOptions,\n} from '@udecode/plate-floating';\nimport { floatingLinkActions } from './floatingLinkStore';\n\nexport const useVirtualFloatingLink = ({\n  editorId,\n  ...floatingOptions\n}: { editorId: string } & UseVirtualFloatingOptions) => {\n  return useVirtualFloating({\n    placement: 'bottom-start',\n    onOpenChange: (open) =>\n      floatingLinkActions.openEditorId(open ? editorId : null),\n    middleware: [\n      offset(12),\n      flip({\n        padding: 96,\n      }),\n    ],\n    ...floatingOptions,\n  });\n};\n", "import { useCallback, useEffect } from 'react';\nimport {\n  getAboveNode,\n  getEndPoint,\n  getPluginOptions,\n  getPluginType,\n  getStartPoint,\n  HTMLPropsAs,\n  someNode,\n  useComposedRef,\n  useEditorRef,\n  useHotkeys,\n  usePlateSelectors,\n} from '@udecode/plate-core';\nimport {\n  getDefaultBoundingClientRect,\n  getRangeBoundingClientRect,\n} from '@udecode/plate-floating';\nimport { ELEMENT_LINK, LinkPlugin } from '../../createLinkPlugin';\nimport { triggerFloatingLinkEdit } from '../../utils/triggerFloatingLinkEdit';\nimport { FloatingLinkProps } from './FloatingLink';\nimport {\n  floatingLinkActions,\n  floatingLinkSelectors,\n  useFloatingLinkSelectors,\n} from './floatingLinkStore';\nimport { useFloatingLinkEnter } from './useFloatingLinkEnter';\nimport { useFloatingLinkEscape } from './useFloatingLinkEscape';\nimport { useVirtualFloatingLink } from './useVirtualFloatingLink';\n\nexport const useFloatingLinkEdit = ({\n  floatingOptions,\n  ...props\n}: FloatingLinkProps): HTMLPropsAs<'div'> => {\n  const editor = useEditorRef();\n  const keyEditor = usePlateSelectors().keyEditor();\n  const mode = useFloatingLinkSelectors().mode();\n  const open = useFloatingLinkSelectors().isOpen(editor.id);\n\n  const { triggerFloatingLinkHotkeys } = getPluginOptions<LinkPlugin>(\n    editor,\n    ELEMENT_LINK\n  );\n\n  const getBoundingClientRect = useCallback(() => {\n    const entry = getAboveNode(editor, {\n      match: { type: getPluginType(editor, ELEMENT_LINK) },\n    });\n\n    if (entry) {\n      const [, path] = entry;\n      return getRangeBoundingClientRect(editor, {\n        anchor: getStartPoint(editor, path),\n        focus: getEndPoint(editor, path),\n      });\n    }\n\n    return getDefaultBoundingClientRect();\n  }, [editor]);\n\n  const isOpen = open && mode === 'edit';\n\n  const { update, style, floating } = useVirtualFloatingLink({\n    editorId: editor.id,\n    open: isOpen,\n    getBoundingClientRect,\n    ...floatingOptions,\n  });\n\n  useEffect(() => {\n    if (\n      editor.selection &&\n      someNode(editor, {\n        match: { type: getPluginType(editor, ELEMENT_LINK) },\n      })\n    ) {\n      floatingLinkActions.show('edit', editor.id);\n      update();\n      return;\n    }\n\n    if (floatingLinkSelectors.mode() === 'edit') {\n      floatingLinkActions.hide();\n    }\n  }, [editor, keyEditor, update]);\n\n  useHotkeys(\n    triggerFloatingLinkHotkeys!,\n    (e) => {\n      if (\n        floatingLinkSelectors.mode() === 'edit' &&\n        triggerFloatingLinkEdit(editor)\n      ) {\n        e.preventDefault();\n      }\n    },\n    {\n      enableOnContentEditable: true,\n    },\n    []\n  );\n\n  useFloatingLinkEnter();\n\n  useFloatingLinkEscape();\n\n  return {\n    style: {\n      ...style,\n      zIndex: 1,\n    },\n    ...props,\n    ref: useComposedRef<HTMLElement | null>(props.ref, floating),\n  };\n};\n", "import {\n  getEditorString,\n  getPluginType,\n  isRangeAcrossBlocks,\n  PlateEditor,\n  someNode,\n  Value,\n} from '@udecode/plate-core';\nimport {\n  floatingLinkActions,\n  floatingLinkSelectors,\n} from '../components/FloatingLink/floatingLinkStore';\nimport { ELEMENT_LINK } from '../createLinkPlugin';\n\n/**\n * Trigger floating link.\n *\n * Do not trigger when:\n * - selection is across blocks\n * - selection has more than one leaf node\n * - lowest selection is not text\n * - selection has a link node\n */\nexport const triggerFloatingLinkInsert = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    focused,\n  }: {\n    focused?: boolean;\n  } = {}\n) => {\n  if (floatingLinkSelectors.mode()) return;\n\n  if (!focused) return;\n\n  if (isRangeAcrossBlocks(editor, { at: editor.selection })) return;\n\n  const hasLink = someNode(editor, {\n    match: { type: getPluginType(editor, ELEMENT_LINK) },\n  });\n  if (hasLink) return;\n\n  floatingLinkActions.text(getEditorString(editor, editor.selection));\n  floatingLinkActions.show('insert', editor.id);\n\n  return true;\n};\n", "import { useEffect } from 'react';\nimport {\n  focusEditor,\n  getPluginOptions,\n  HTMLPropsAs,\n  useComposedRef,\n  useEditorRef,\n  useHotkeys,\n  useOnClickOutside,\n} from '@udecode/plate-core';\nimport { getSelectionBoundingClientRect } from '@udecode/plate-floating';\nimport { useFocused } from 'slate-react';\nimport { ELEMENT_LINK, LinkPlugin } from '../../createLinkPlugin';\nimport { triggerFloatingLinkInsert } from '../../utils/triggerFloatingLinkInsert';\nimport { FloatingLinkProps } from './FloatingLink';\nimport {\n  floatingLinkActions,\n  floatingLinkSelectors,\n  useFloatingLinkSelectors,\n} from './floatingLinkStore';\nimport { useFloatingLinkEscape } from './useFloatingLinkEscape';\nimport { useVirtualFloatingLink } from './useVirtualFloatingLink';\n\nexport const useFloatingLinkInsert = ({\n  floatingOptions,\n  ...props\n}: FloatingLinkProps): HTMLPropsAs<'div'> => {\n  const editor = useEditorRef();\n  const focused = useFocused();\n  const mode = useFloatingLinkSelectors().mode();\n  const open = useFloatingLinkSelectors().isOpen(editor.id);\n\n  const { triggerFloatingLinkHotkeys } = getPluginOptions<LinkPlugin>(\n    editor,\n    ELEMENT_LINK\n  );\n\n  useHotkeys(\n    triggerFloatingLinkHotkeys!,\n    (e) => {\n      if (triggerFloatingLinkInsert(editor, { focused })) {\n        e.preventDefault();\n      }\n    },\n    {\n      enableOnContentEditable: true,\n    },\n    [focused]\n  );\n\n  const ref = useOnClickOutside(\n    () => {\n      if (floatingLinkSelectors.mode() === 'insert') {\n        floatingLinkActions.hide();\n        focusEditor(editor, editor.selection!);\n      }\n    },\n    {\n      disabled: !open,\n    }\n  );\n\n  const { update, style, floating } = useVirtualFloatingLink({\n    editorId: editor.id,\n    open: open && mode === 'insert',\n    getBoundingClientRect: getSelectionBoundingClientRect,\n    whileElementsMounted: () => {},\n    ...floatingOptions,\n  });\n\n  // wait for update before focusing input\n  useEffect(() => {\n    if (open) {\n      update();\n      floatingLinkActions.updated(true);\n    } else {\n      floatingLinkActions.updated(false);\n    }\n  }, [open, update]);\n\n  useFloatingLinkEscape();\n\n  return {\n    style: {\n      ...style,\n      zIndex: 1,\n    },\n    ...props,\n    ref: useComposedRef<HTMLElement | null>(props.ref, floating, ref),\n  };\n};\n", "import {\n  createComponentAs,\n  createElementAs,\n  HTMLPropsAs,\n} from '@udecode/plate-core';\nimport { UseVirtualFloatingOptions } from '@udecode/plate-floating';\nimport { FloatingLinkEditButton } from './FloatingLinkEditButton';\nimport { FloatingLinkNewTabInput } from './FloatingLinkNewTabInput';\nimport { FloatingLinkTextInput } from './FloatingLinkTextInput';\nimport { FloatingLinkUrlInput } from './FloatingLinkUrlInput';\nimport { OpenLinkButton } from './OpenLinkButton';\nimport { UnlinkButton } from './UnlinkButton';\nimport { useFloatingLinkEdit } from './useFloatingLinkEdit';\nimport { useFloatingLinkInsert } from './useFloatingLinkInsert';\n\nexport type FloatingLinkProps = HTMLPropsAs<'div'> & {\n  floatingOptions?: UseVirtualFloatingOptions;\n};\n\nexport const FloatingLinkEditRoot = createComponentAs<FloatingLinkProps>(\n  (props) => {\n    const htmlProps = useFloatingLinkEdit(props);\n\n    if (htmlProps.style?.display === 'none') {\n      return null;\n    }\n\n    return createElementAs('div', htmlProps);\n  }\n);\n\nexport const FloatingLinkInsertRoot = createComponentAs<FloatingLinkProps>(\n  (props) => {\n    const htmlProps = useFloatingLinkInsert(props);\n\n    if (htmlProps.style?.display === 'none') {\n      return null;\n    }\n\n    return createElementAs('div', htmlProps);\n  }\n);\n\nexport const FloatingLink = {\n  EditRoot: FloatingLinkEditRoot,\n  InsertRoot: FloatingLinkInsertRoot,\n  UrlInput: FloatingLinkUrlInput,\n  TextInput: FloatingLinkTextInput,\n  NewTabInput: FloatingLinkNewTabInput,\n  EditButton: FloatingLinkEditButton,\n  UnlinkButton,\n  OpenLinkButton,\n};\n", "import { PlateEditor, Value } from '@udecode/plate-core';\nimport { floatingLinkSelectors } from '../components/index';\nimport { triggerFloatingLinkEdit } from './triggerFloatingLinkEdit';\nimport { triggerFloatingLinkInsert } from './triggerFloatingLinkInsert';\n\nexport const triggerFloatingLink = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    focused,\n  }: {\n    focused?: boolean;\n  } = {}\n) => {\n  if (floatingLinkSelectors.mode() === 'edit') {\n    triggerFloatingLinkEdit(editor);\n    return;\n  }\n\n  triggerFloatingLinkInsert(editor, {\n    focused,\n  });\n};\n", "import {\n  insertNodes,\n  InsertNodesOptions,\n  PlateEditor,\n  TText,\n  Value,\n} from '@udecode/plate-core';\nimport { TLinkElement } from '../types';\nimport { createLinkNode, CreateLinkNodeOptions } from '../utils/index';\n\n/**\n * Insert a link node.\n */\nexport const insertLink = <V extends Value>(\n  editor: PlateEditor<V>,\n  createLinkNodeOptions: CreateLinkNodeOptions,\n  options?: InsertNodesOptions<V>\n) => {\n  insertNodes<TLinkElement | TText>(\n    editor,\n    [createLinkNode(editor, createLinkNodeOptions)],\n    options as any\n  );\n};\n", "import {\n  getAboveNode,\n  getPluginType,\n  isElement,\n  PlateEditor,\n  splitNodes,\n  unwrapNodes,\n  UnwrapNodesOptions,\n  Value,\n  withoutNormalizing,\n} from '@udecode/plate-core';\nimport { ELEMENT_LINK } from '../createLinkPlugin';\n\n/**\n * Unwrap link node.\n */\nexport const unwrapLink = <V extends Value>(\n  editor: PlateEditor<V>,\n  options?: UnwrapNodesOptions & {\n    split?: boolean;\n  }\n) => {\n  return withoutNormalizing(editor, () => {\n    if (options?.split) {\n      const linkAboveAnchor = getAboveNode(editor, {\n        at: editor.selection?.anchor,\n        match: { type: getPluginType(editor, ELEMENT_LINK) },\n      });\n\n      // anchor in link\n      if (linkAboveAnchor) {\n        splitNodes(editor, {\n          at: editor.selection?.anchor,\n          match: (n) =>\n            isElement(n) && n.type === getPluginType(editor, ELEMENT_LINK),\n        });\n        unwrapLink(editor, {\n          at: editor.selection?.anchor,\n        });\n        return true;\n      }\n      const linkAboveFocus = getAboveNode(editor, {\n        at: editor.selection?.focus,\n        match: { type: getPluginType(editor, ELEMENT_LINK) },\n      });\n\n      // focus in link\n      if (linkAboveFocus) {\n        splitNodes(editor, {\n          at: editor.selection?.focus,\n          match: (n) =>\n            isElement(n) && n.type === getPluginType(editor, ELEMENT_LINK),\n        });\n        unwrapLink(editor, {\n          at: editor.selection?.focus,\n        });\n        return true;\n      }\n    }\n\n    unwrapNodes(editor, {\n      match: { type: getPluginType(editor, ELEMENT_LINK) },\n      ...options,\n    });\n  });\n};\n", "import {\n  getAboveNode,\n  getEditorString,\n  getPluginType,\n  PlateEditor,\n  replaceNodeChildren,\n  TText,\n  Value,\n} from '@udecode/plate-core';\nimport { ELEMENT_LINK } from '../createLinkPlugin';\nimport { TLinkElement } from '../types';\nimport { UpsertLinkOptions } from './upsertLink';\n\n/**\n * If the text is different than the link above text, replace link children by a new text.\n * The new text has the same marks than the first text replaced.\n */\nexport const upsertLinkText = <V extends Value>(\n  editor: PlateEditor<V>,\n  { text }: UpsertLinkOptions<V>\n) => {\n  const newLink = getAboveNode<TLinkElement>(editor, {\n    match: { type: getPluginType(editor, ELEMENT_LINK) },\n  });\n\n  if (newLink) {\n    const [newLinkNode, newLinkPath] = newLink;\n\n    if (text?.length && text !== getEditorString(editor, newLinkPath)) {\n      const firstText = newLinkNode.children[0];\n\n      // remove link children\n      replaceNodeChildren<TText>(editor, {\n        at: newLinkPath,\n        nodes: { ...firstText, text },\n        insertOptions: {\n          select: true,\n        },\n      });\n    }\n  }\n};\n", "import {\n  getPluginType,\n  PlateEditor,\n  Value,\n  wrapNodes,\n  WrapNodesOptions,\n} from '@udecode/plate-core';\nimport { ELEMENT_LINK } from '../createLinkPlugin';\nimport { TLinkElement } from '../types';\n\nexport interface WrapLinkOptions<V extends Value = Value>\n  extends WrapNodesOptions<V> {\n  url: string;\n  target?: string;\n}\n\n/**\n * Wrap a link node with split.\n */\nexport const wrapLink = <V extends Value>(\n  editor: PlateEditor<V>,\n  { url, target, ...options }: WrapLinkOptions<V>\n) => {\n  wrapNodes<TLinkElement, Value>(\n    editor,\n    {\n      type: getPluginType(editor, ELEMENT_LINK),\n      url,\n      target,\n      children: [],\n    },\n    { split: true, ...options } as any\n  );\n};\n", "import {\n  findNode,\n  getAboveNode,\n  getEditorString,\n  getNodeLeaf,\n  getNodeProps,\n  getPluginOptions,\n  getPluginType,\n  InsertNodesOptions,\n  isDefined,\n  isExpanded,\n  PlateEditor,\n  removeNodes,\n  setNodes,\n  UnwrapNodesOptions,\n  Value,\n  WrapNodesOptions,\n} from '@udecode/plate-core';\nimport { ELEMENT_LINK, LinkPlugin } from '../createLinkPlugin';\nimport { TLinkElement } from '../types';\nimport { CreateLinkNodeOptions } from '../utils/index';\nimport { insertLink } from './insertLink';\nimport { unwrapLink } from './unwrapLink';\nimport { upsertLinkText } from './upsertLinkText';\nimport { wrapLink } from './wrapLink';\n\nexport type UpsertLinkOptions<\n  V extends Value = Value\n> = CreateLinkNodeOptions & {\n  /**\n   * If true, insert text when selection is in url.\n   */\n  insertTextInLink?: boolean;\n  insertNodesOptions?: InsertNodesOptions<V>;\n  unwrapNodesOptions?: UnwrapNodesOptions<V>;\n  wrapNodesOptions?: WrapNodesOptions<V>;\n  isUrl?: (url: string) => boolean;\n};\n\n/**\n * If selection in a link or is not url:\n * - insert text with url, exit\n * If selection is expanded or `update` in a link:\n * - remove link node, get link text\n * Then:\n * - insert link node\n */\nexport const upsertLink = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    url,\n    text,\n    target,\n    insertTextInLink,\n    insertNodesOptions,\n    isUrl = getPluginOptions<LinkPlugin, V>(editor, ELEMENT_LINK).isUrl,\n  }: UpsertLinkOptions<V>\n) => {\n  const at = editor.selection;\n\n  if (!at) return;\n\n  const linkAbove = getAboveNode<TLinkElement>(editor, {\n    at,\n    match: { type: getPluginType(editor, ELEMENT_LINK) },\n  });\n\n  // anchor and focus in link -> insert text\n  if (insertTextInLink && linkAbove) {\n    // we don't want to insert marks in links\n    editor.insertText(url);\n    return true;\n  }\n\n  if (!isUrl?.(url)) return;\n\n  if (isDefined(text) && !text.length) {\n    text = url;\n  }\n\n  // edit the link url and/or target\n  if (linkAbove) {\n    if (url !== linkAbove[0]?.url || target !== linkAbove[0]?.target) {\n      setNodes<TLinkElement>(\n        editor,\n        { url, target },\n        {\n          at: linkAbove[1],\n        }\n      );\n    }\n\n    upsertLinkText(editor, { url, text, target });\n\n    return true;\n  }\n\n  // selection contains at one edge edge or between the edges\n  const linkEntry = findNode<TLinkElement>(editor, {\n    at,\n    match: { type: getPluginType(editor, ELEMENT_LINK) },\n  });\n\n  const [linkNode, linkPath] = linkEntry ?? [];\n\n  let shouldReplaceText = false;\n\n  if (linkPath && text?.length) {\n    const linkText = getEditorString(editor, linkPath);\n\n    if (text !== linkText) {\n      shouldReplaceText = true;\n    }\n  }\n\n  if (isExpanded(at)) {\n    // anchor and focus in link\n    if (linkAbove) {\n      unwrapLink(editor, {\n        at: linkAbove[1],\n      });\n    } else {\n      unwrapLink(editor, {\n        split: true,\n      });\n    }\n\n    wrapLink(editor, {\n      url,\n      target,\n    });\n\n    upsertLinkText(editor, { url, target, text });\n\n    return true;\n  }\n\n  if (shouldReplaceText) {\n    removeNodes(editor, {\n      at: linkPath,\n    });\n  }\n\n  const props = getNodeProps(linkNode ?? ({} as any));\n\n  const path = editor.selection?.focus.path;\n  if (!path) return;\n\n  // link text should have the focused leaf marks\n  const leaf = getNodeLeaf(editor, path);\n\n  // if text is empty, text is url\n  if (!text?.length) {\n    text = url;\n  }\n\n  insertLink(\n    editor,\n    {\n      ...props,\n      url,\n      target,\n      children: [\n        {\n          ...leaf,\n          text,\n        },\n      ],\n    },\n    insertNodesOptions\n  );\n  return true;\n};\n", "import {\n  collapseSelection,\n  getAboveNode,\n  getEditorString,\n  getNextNodeStartPoint,\n  getPluginType,\n  getPreviousNodeEndPoint,\n  getRangeBefore,\n  getRangeFromBlockStart,\n  insertNodes,\n  isCollapsed,\n  isEndPoint,\n  isStartPoint,\n  mockPlugin,\n  PlateEditor,\n  select,\n  someNode,\n  Value,\n  withoutNormalizing,\n  WithPlatePlugin,\n} from '@udecode/plate-core';\nimport { withRemoveEmptyNodes } from '@udecode/plate-normalizers';\nimport { Path, Point, Range } from 'slate';\nimport { upsertLink } from './transforms/index';\nimport { ELEMENT_LINK, LinkPlugin } from './createLinkPlugin';\n\n/**\n * Insert space after a url to wrap a link.\n * Lookup from the block start to the cursor to check if there is an url.\n * If not found, lookup before the cursor for a space character to check the url.\n *\n * On insert data:\n * Paste a string inside a link element will edit its children text but not its url.\n *\n */\n\nexport const withLink = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>\n>(\n  editor: E,\n  {\n    type,\n    options: { isUrl, getUrlHref, rangeBeforeOptions },\n  }: WithPlatePlugin<LinkPlugin, V, E>\n) => {\n  const { insertData, insertText, apply, normalizeNode, insertBreak } = editor;\n\n  const wrapLink = () => {\n    withoutNormalizing(editor, () => {\n      const selection = editor.selection!;\n\n      // get the range from first space before the cursor\n      let beforeWordRange = getRangeBefore(\n        editor,\n        selection,\n        rangeBeforeOptions\n      );\n\n      // if no space found before, get the range from block start\n      if (!beforeWordRange) {\n        beforeWordRange = getRangeFromBlockStart(editor);\n      }\n\n      // if no word found before the cursor, exit\n      if (!beforeWordRange) return;\n\n      const hasLink = someNode(editor, {\n        at: beforeWordRange,\n        match: { type: getPluginType(editor, ELEMENT_LINK) },\n      });\n\n      // if word before the cursor has a link, exit\n      if (hasLink) return;\n\n      let beforeWordText = getEditorString(editor, beforeWordRange);\n      beforeWordText = getUrlHref?.(beforeWordText) ?? beforeWordText;\n\n      // if word before is not an url, exit\n      if (!isUrl!(beforeWordText)) return;\n\n      // select the word to wrap link\n      select(editor, beforeWordRange);\n\n      // wrap link\n      upsertLink(editor, {\n        url: beforeWordText,\n      });\n\n      // collapse selection\n      collapseSelection(editor, { edge: 'end' });\n    });\n  };\n\n  editor.insertBreak = () => {\n    if (!isCollapsed(editor.selection)) return insertBreak();\n    wrapLink();\n    insertBreak();\n  };\n\n  editor.insertText = (text) => {\n    if (text === ' ' && isCollapsed(editor.selection)) {\n      wrapLink();\n    }\n\n    insertText(text);\n  };\n\n  editor.insertData = (data: DataTransfer) => {\n    const text = data.getData('text/plain');\n    const textHref = getUrlHref?.(text);\n\n    if (text) {\n      const inserted = upsertLink(editor, {\n        url: textHref || text,\n        insertTextInLink: true,\n      });\n      if (inserted) return;\n    }\n\n    insertData(data);\n  };\n\n  // TODO: plugin\n  editor.apply = (operation) => {\n    if (operation.type === 'set_selection') {\n      const range = operation.newProperties as Range | null;\n\n      if (range && range.focus && range.anchor && isCollapsed(range)) {\n        const entry = getAboveNode(editor, {\n          at: range,\n          match: { type: getPluginType(editor, ELEMENT_LINK) },\n        });\n\n        if (entry) {\n          const [, path] = entry;\n\n          let newPoint: Point | undefined;\n\n          if (isStartPoint(editor, range.focus, path)) {\n            newPoint = getPreviousNodeEndPoint(editor, path);\n          }\n\n          if (isEndPoint(editor, range.focus, path)) {\n            newPoint = getNextNodeStartPoint(editor, path);\n          }\n\n          if (newPoint) {\n            operation.newProperties = {\n              anchor: newPoint,\n              focus: newPoint,\n            };\n          }\n        }\n      }\n    }\n\n    apply(operation);\n  };\n\n  // TODO: plugin\n  editor.normalizeNode = ([node, path]) => {\n    if (node.type === getPluginType(editor, ELEMENT_LINK)) {\n      const range = editor.selection as Range | null;\n\n      if (range && isCollapsed(range)) {\n        if (isEndPoint(editor, range.focus, path)) {\n          const nextPoint = getNextNodeStartPoint(editor, path);\n\n          // select next text node if any\n          if (nextPoint) {\n            select(editor, nextPoint);\n          } else {\n            // insert text node then select\n            const nextPath = Path.next(path);\n            insertNodes(editor, { text: '' } as any, { at: nextPath });\n            select(editor, nextPath);\n          }\n        }\n      }\n    }\n\n    normalizeNode([node, path]);\n  };\n\n  editor = withRemoveEmptyNodes<V, E>(\n    editor,\n    mockPlugin<{}, V, E>({\n      options: { types: type },\n    })\n  );\n\n  return editor;\n};\n", "import {\n  createPluginFactory,\n  isUrl as isUrlProtocol,\n  RangeBeforeOptions,\n} from '@udecode/plate-core';\nimport { withLink } from './withLink';\n\nexport const ELEMENT_LINK = 'a';\n\nexport interface LinkPlugin {\n  forceSubmit?: boolean;\n\n  /**\n   * Allow custom config for rangeBeforeOptions.\n   * @example default\n   * {\n   *   matchString: ' ',\n   *   skipInvalid: true,\n   *   afterMatch: true,\n   * }\n   */\n  rangeBeforeOptions?: RangeBeforeOptions;\n\n  /**\n   * Hotkeys to trigger floating link.\n   * @default 'meta+k, ctrl+k'\n   */\n  triggerFloatingLinkHotkeys?: string | string[];\n\n  /**\n   * Callback to validate an url.\n   * @default isUrl\n   */\n  isUrl?: (text: string) => boolean;\n\n  /**\n   * Callback to optionally get the href for a url\n   * @returns href: an optional link to be used that is different from the text content (example https://google.com for google.com)\n   */\n  getUrlHref?: (url: string) => string | undefined;\n\n  /**\n   * On keyboard shortcut or toolbar mousedown, get the link url by calling this promise. The\n   * default behavior is to use the browser's native `prompt`.\n   */\n  getLinkUrl?: (prevUrl: string | null) => Promise<string | null>;\n}\n\n/**\n * Enables support for hyperlinks.\n */\nexport const createLinkPlugin = createPluginFactory<LinkPlugin>({\n  key: ELEMENT_LINK,\n  isElement: true,\n  isInline: true,\n  props: ({ element }) => ({\n    nodeProps: { href: element?.url, target: element?.target },\n  }),\n  withOverrides: withLink,\n  options: {\n    isUrl: isUrlProtocol,\n    rangeBeforeOptions: {\n      matchString: ' ',\n      skipInvalid: true,\n      afterMatch: true,\n    },\n    triggerFloatingLinkHotkeys: 'meta+k, ctrl+k',\n  },\n  then: (editor, { type }) => ({\n    deserializeHtml: {\n      rules: [\n        {\n          validNodeName: 'A',\n        },\n      ],\n      getNode: (el) => ({\n        type,\n        url: el.getAttribute('href'),\n        target: el.getAttribute('target') || '_blank',\n      }),\n    },\n  }),\n});\n"],
  "mappings": "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",
  "names": ["withNormalizeTypes", "editor", "options", "rules", "onError", "normalizeNode", "currentNode", "currentPath", "length", "endCurrentNormalizationPass", "some", "strictType", "type", "path", "node", "getNode", "isElement", "setElements", "at", "insertElements", "children", "text", "err", "KEY_NORMALIZE_TYPES", "createNormalizeTypesPlugin", "createPluginFactory", "key", "withOverrides", "isArray", "withRemoveEmptyNodes", "types", "_types", "castArray", "includes", "getNodeString", "removeNodes", "createRemoveEmptyNodesPlugin", "createLinkNode", "editor", "url", "text", "target", "children", "type", "getPluginType", "ELEMENT_LINK", "LaunchIcon", "props", "React", "useLink", "_props", "useElementProps", "elementToAttributes", "element", "href", "onMouseOver", "e", "stopPropagation", "LinkRoot", "createComponentAs", "htmlProps", "createElementAs", "Link", "Root", "LinkIcon", "LinkOffIcon", "ShortTextIcon", "floatingLinkStore", "createStore", "openEditorId", "mouseDown", "updated", "newTab", "mode", "isEditing", "extendActions", "set", "reset", "show", "editorId", "hide", "extendSelectors", "state", "isOpen", "floatingLinkActions", "floatingLinkSelectors", "get", "useFloatingLinkSelectors", "use", "triggerFloatingLinkEdit", "entry", "findNode", "match", "link", "path", "getEditorString", "undefined", "useFloatingLinkEditButton", "useEditorRef", "onClick", "useCallback", "FloatingLinkEditButton", "useFloatingLinkNewTabInput", "ref", "useRef", "checked", "setChecked", "useState", "useEffect", "current", "setTimeout", "focus", "onChange", "mergeProps", "useComposedRef", "FloatingLinkNewTabInput", "useFloatingLinkTextInput", "value", "defaultValue", "FloatingLinkTextInput", "useFloatingLinkUrlInput", "FloatingLinkUrlInput", "useOpenLinkButton", "selection", "usePlateSelection", "useMemo", "OpenLinkButton", "useUnlinkButton", "unwrapLink", "focusEditor", "UnlinkButton", "Button", "global", "platform", "computePosition", "config", "side", "placement", "overflow", "getWindow", "isElement", "window", "clippingAncestors", "index", "useFloating", "data", "node", "getDefaultBoundingClientRect", "width", "height", "x", "y", "top", "left", "right", "bottom", "createVirtualElement", "getBoundingClientRect", "submitFloatingLink", "isUrl", "forceSubmit", "getPluginOptions", "isValid", "upsertLink", "_url", "useFloatingLinkEnter", "open", "id", "useHotkeys", "key", "preventDefault", "enabled", "enableOnFormTags", "useFloatingLinkEscape", "enableOnContentEditable", "useVirtualFloatingLink", "floatingOptions", "useVirtualFloating", "onOpenChange", "middleware", "offset", "flip", "padding", "useFloatingLinkEdit", "keyEditor", "usePlateSelectors", "triggerFloatingLinkHotkeys", "getAboveNode", "getRangeBoundingClientRect", "anchor", "getStartPoint", "getEndPoint", "update", "style", "floating", "someNode", "zIndex", "triggerFloatingLinkInsert", "focused", "isRangeAcrossBlocks", "at", "hasLink", "useFloatingLinkInsert", "useFocused", "useOnClickOutside", "disabled", "getSelectionBoundingClientRect", "whileElementsMounted", "FloatingLinkEditRoot", "display", "FloatingLinkInsertRoot", "FloatingLink", "EditRoot", "InsertRoot", "UrlInput", "TextInput", "NewTabInput", "EditButton", "triggerFloatingLink", "insertLink", "createLinkNodeOptions", "options", "insertNodes", "withoutNormalizing", "split", "linkAboveAnchor", "splitNodes", "n", "linkAboveFocus", "unwrapNodes", "upsertLinkText", "newLink", "newLinkNode", "newLinkPath", "length", "firstText", "replaceNodeChildren", "nodes", "insertOptions", "select", "wrapLink", "wrapNodes", "insertTextInLink", "insertNodesOptions", "linkAbove", "insertText", "isDefined", "setNodes", "linkEntry", "linkNode", "linkPath", "shouldReplaceText", "linkText", "isExpanded", "removeNodes", "getNodeProps", "leaf", "getNodeLeaf", "withLink", "getUrlHref", "rangeBeforeOptions", "insertData", "apply", "normalizeNode", "insertBreak", "beforeWordRange", "getRangeBefore", "getRangeFromBlockStart", "beforeWordText", "collapseSelection", "edge", "isCollapsed", "getData", "textHref", "inserted", "operation", "range", "newProperties", "newPoint", "isStartPoint", "getPreviousNodeEndPoint", "isEndPoint", "getNextNodeStartPoint", "nextPoint", "nextPath", "Path", "next", "withRemoveEmptyNodes", "mockPlugin", "types", "createLinkPlugin", "createPluginFactory", "isInline", "nodeProps", "withOverrides", "matchString", "skipInvalid", "afterMatch", "then", "deserializeHtml", "rules", "validNodeName", "getNode", "el", "getAttribute"]
}
